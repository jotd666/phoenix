
*0000-3FFF: ROM

*4000-4FFF: video/general purpose RAM, banked with 2 memory banks

*4000-4340: fg tiles video ram (26*32 208*256)

* a few values explained
*4364   if != 0 the "killed bird" sound is played
*4390   player 1 lives
*4391   player 2 lives
*43A0 	IN0Current_43a0 	Current value of IN0
*43A1 	IN0Previous 	Previous value of IN0
*43A2 	game_in_play_43A2  0 game not playing, !=0: playing, 1 or 2 nb players
*43A4 	game_state_43A4 	Function table jump
*43A5 	timer_43A5 	general purpose state timer
*43A6   shield_timer_43A6  0x01-0xC0: inactive, cannot be enabled, 0: inactive, can be enabled, 0xC0-0xFF: active
*43B8   current stage, always odd (even values are used for transitions)
*43BA   nb enemies to kill before stage completed (not vultures, only birds stage)
*43BB   nb vultures to kill before stage completed
*438F 	CoinCount 	Number of coins inserted (max counted is 9)
*4398:4399 	intro 16 bit counter (MSB:LSB)
*439A:439B 	counter_439A 	16 bit counter (MSB:LSB)
*43C2:43C3  player ship X/Y (X changes, Y stays on the bottom of screen)
*4800-4B40: bg tiles video ram (scrollable part)
*4BD6: average_vulture_y_pos_in_chars_4BD6 cooked from vulture positions & alive state.
* all vultures alive + swarm on top: value is $A
* all vultures alive + lower vulture just above the player: value is $11
*4B70-...: vulture structures. Each structure is 8 bytes
*
* offset 0: vulture state: a few states:
*  - 0: dead
*  - 1/2: star (for intro)
*  - 3: small egg
*  - 7: full
*  - 8: hatching
*  - 0xC: missing right wing
*  - 0xD: missing left wing
*  - 0xE: missing both wings
* offset 1-2: screen address
* offset 3: animation frame for current state
	
	

* to skip a level, MAME cheat sets 43BA or 43BB depending on stage, and on final stage
* just changes game_state_43A4 to 6 to set boss explode sequence

*5000-53FF: video registers
*50xx: write a value with bit 0 cleared to enable memory bank 0
*      else bank 1 is mapped
*50xx: write a value with bit 1 cleared: select palette #1 else palette #2
*5800-5BFF: scroll registers
*6000-63ff: sound
*6800-6bff: sound
*7000-73ff: input
*7800-7bff: dip switches
*
* ram banks are used at startup but mostly used on 2 player mode to swap/store
* non-playing player screen & variables
*
* no interrupts are used at all (which allows for safe bank switching, which
* contains the stack...)
*
* "bird" means small birds, I'm calling the big birds vultures (or eagles?)

*http://www.computerarcheology.com/Arcade/Phoenix/

*	PORT_START("IN0")
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNUSED )
*	PORT_BIT( 0xf0, IP_ACTIVE_HIGH, IPT_CUSTOM ) PORT_CUSTOM_MEMBER(phoenix_state, player_input_r)
*
*	PORT_START("DSW0")
*	PORT_DIPNAME( 0x03, 0x00, DEF_STR( Lives ) )            PORT_DIPLOCATION( "SW1:1,2" )
*	PORT_DIPSETTING(    0x00, "3" )
*	PORT_DIPSETTING(    0x01, "4" )
*	PORT_DIPSETTING(    0x02, "5" )
*	PORT_DIPSETTING(    0x03, "6" )
*	PORT_DIPNAME( 0x0c, 0x00, DEF_STR( Bonus_Life ) )       PORT_DIPLOCATION( "SW1:3,4" )
*	PORT_DIPSETTING(    0x00, "3K 30K" )
*	PORT_DIPSETTING(    0x04, "4K 40K" )
*	PORT_DIPSETTING(    0x08, "5K 50K" )
*	PORT_DIPSETTING(    0x0c, "6K 60K" )
*	PORT_DIPNAME( 0x10, 0x00, DEF_STR( Coinage ) )          PORT_DIPLOCATION( "SW1:5" )
*	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
*	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )          PORT_DIPLOCATION( "SW1:6" )
*	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
*	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )          PORT_DIPLOCATION( "SW1:7" )
*	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
*	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_CUSTOM ) PORT_VBLANK("screen")
*
*	PORT_START("CAB")       // fake port for non-memory mapped dip switch
*	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION( "SW1:!8" )
*	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
*	PORT_DIPSETTING(    0x01, DEF_STR( Cocktail ) )
*
*	PORT_START("CTRL")      // fake port for multiplexed controls
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 )
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON2 )
*	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,EQUALS,0x01)
*	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,EQUALS,0x01)
*	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT  ) PORT_2WAY PORT_COCKTAIL PORT_CONDITION("CAB",0x01,EQUALS,0x01)
*	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL                  PORT_CONDITION("CAB",0x01,EQUALS,0x01)


	.include "phoenix.inc"
	.ifdef	__amiga__
	.include "phoenix_ram.68k"
	.align	2
	.endif	
	.global	phoenix_reset
	
	.ifdef	RELEASE
	.macro	DECL_ADDRESS	addr
	.endm
	.else
	.macro	DECL_ADDRESS	addr
	.asciz	"ADDRESS"
	.word	0x\addr
	.endm
	.endif
	
	.macro CLEAR_XC_FLAGS
	move.w	d7,-(a7)
	moveq	#0,d7
	roxl.b	#1,d7
	movem.w	(a7)+,d7
	.endm

	.macro SET_XC_FLAGS
	move.w	d7,-(a7)
	st	d7
	roxl.b	#1,d7
	movem.w	(a7)+,d7
	.endm

	.macro	INVERT_XC_FLAGS
	jcs	0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
	.endm

	.macro	SET_X_FROM_C
	jcc	0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
	.endm
	.macro	SET_C_FROM_X
	move.w	d7,-(a7)
	roxl.b	#1,d7
	roxr.b	#1,d7
	movem.w	(a7)+,d7
	.endm


	
	.macro	LOAD_D1_16_FROM_D1D2
	and.l	#0xFFFF,d1
	lsl.w	#8,d1
	move.b	d2,d1
	.endm
	
	.macro	LOAD_D3_16_FROM_D3D4
	and.l	#0xFFFF,d3
	lsl.w	#8,d3
	move.b	d4,d3
	.endm
	.macro	LOAD_D5_16_FROM_D5D6
	and.l	#0xFFFF,d5
	lsl.w	#8,d5
	move.b	d6,d5
	.endm
	.macro	LOAD_D1D2_FROM_D1_16
	move.b	d1,d2
	lsr.w	#8,d1
	.endm
	.macro	LOAD_D5D6_FROM_D5_16
	move.b	d5,d6
	lsr.w	#8,d5
	.endm
	.macro	LOAD_D3D4_FROM_D3_16
	move.b	d3,d4
	lsr.w	#8,d3
	.endm
	
ROM_TOP = 0x4000
RAM_START = ROM_TOP
RAM_TOP = 0x5000

load_rom_in_a0_from_d5d6:
	move.w	d5,-(a7)
	LOAD_D5_16_FROM_D5D6
	.ifndef	RELEASE
	cmp.w	#ROM_TOP,d5
	bcs.b	0f
	lea		load_rom_in_a0_from_d5d6_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal
0:
	.endif
	lea		game_rom,a0
	add.w	d5,a0
	move.w	(a7)+,d5
	rts

* < D0: byte possibly containing lowernibble > 9
* > D0: value corrected to full BCD
daa:
	move.w	d1,-(a7)
	move.b	d0,d1
	and.w	#0xF,d1
	sub.b	#10,d1
	bcs.b	0f		| no need to do anything
	* D1 = A-F: correct
	add.b	#0x16,d0
0:
	move.w	(a7)+,d1
	rts
	

	
load_rom_in_a4_from_d1d2:
	move.w	d1,-(a7)
	LOAD_D1_16_FROM_D1D2
	.ifndef	RELEASE
	cmp.w	#ROM_TOP,d1
	bcs.b	0f
	lea		load_rom_in_a4_from_d1d2_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal
0:
	.endif
	lea		game_rom,a4
	add.w	d1,a4
	move.w	(a7)+,d1
	rts
	
load_rom_in_a0_from_d3w:
	exg	d3,d6
	bsr		load_rom_in_a0_from_d6w
	exg	d6,d3
	rts
	
load_rom_in_a0_from_d6w:
	.ifndef	RELEASE
	cmp.w	#ROM_TOP,d6
	bcs.b	0f
	lea		load_rom_in_a0_from_d6w_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal
0:
	.endif
	lea		game_rom,a0
	add.w	d6,a0
	rts

load_ram_in_a4_from_d1d2:
	movem.w	d1/d2,-(a7)
	LOAD_D1_16_FROM_D1D2
	
	sub.w	#RAM_START,d1
	.ifndef	RELEASE
	bcc.b	1f
0:
	add.w	#RAM_START,d1
	lea		load_ram_in_a4_from_d1d2_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal
	.endif
1:
	.ifndef	RELEASE
	cmp.w	#RAM_TOP-RAM_START,d1
	bcc.b	0b
	.endif

	lea		game_ram,a4
	add.w	d1,a4
	movem.w	(a7)+,d1/d2
	rts
	
load_ram_in_a1_from_d3d4:
	movem.w	d3/d4,-(a7)
	LOAD_D3_16_FROM_D3D4
	
	sub.w	#RAM_START,d3
	.ifndef	RELEASE
	bcc.b	1f
0:
	add.w	#RAM_START,d3
	lea		load_ram_in_a1_from_d3d4_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal
	.endif
1:
	.ifndef	RELEASE
	cmp.w	#RAM_TOP-RAM_START,d3
	bcc.b	0b
	.endif

	lea		game_ram,a1
	add.w	d3,a1
	movem.w	(a7)+,d3/d4
	rts
	
read_ram:
	move.w	d7,-(a7)
	sub.w	#RAM_START,d7
	.ifndef	RELEASE
	bcc.b	1f
0:
	add.w	#RAM_START,d7
	lea		read_ram_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal
	.endif
1:	
	.ifndef	RELEASE
	cmp.w	#RAM_TOP-RAM_START,d7
	bcc.b	0b
	.endif

	lea		game_ram,a6
	move.b	(a6,d7.w),d0

	move.w	(a7)+,d7
	rts
	
load_ram_in_a0_from_d5d6:
	movem.w	d5/d6,-(a7)
	LOAD_D5_16_FROM_D5D6
	sub.w	#RAM_START,d5
	.ifndef	RELEASE
	bcc.b	1f
0:
	add.w	#RAM_START,d5
	move.w	d5,d7
	lea		read_ram_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal

	.endif
1:
	.ifndef	RELEASE
	cmp.w	#RAM_TOP-RAM_START,d5
	bcc.b	0b
	.endif

	lea		game_ram,a0
	add.w	d5,a0
	movem.w	(a7)+,d5/d6
	rts
	
load_ram_in_a0_from_d6w:
	move.w	d6,-(a7)
	sub.w	#RAM_START,d6
	.ifndef	RELEASE
	bcc.b	1f
0:
	add.w	#RAM_START,d6
	move.w	d6,d7
	lea		read_ram_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal

	.endif
1:
	.ifndef	RELEASE
	cmp.w	#RAM_TOP-RAM_START,d6
	bcc.b	0b
	.endif

	lea		game_ram,a0
	add.w	d6,a0
	move.w	(a7)+,d6
	rts
	
load_rom_in_a1_from_d3w:
	.ifndef	RELEASE
	cmp.w	#ROM_TOP,d3
	bcs.b	0f
	lea		load_rom_in_a1_from_d3w_error(pc),a1
	jbsr	osd_break
	illegal
0:
	.endif
	lea		game_rom,a1
	add.w	d3,a1
	rts
	
load_rom_in_a1_from_d3d4:
	move.w	d3,-(a7)
	LOAD_D3_16_FROM_D3D4
	.ifndef	RELEASE
	cmp.w	#ROM_TOP,d3
	bcs.b	0f
	lea		load_rom_in_a1_from_d3d4_error(pc),a1
	jbsr	osd_break
	illegal
	.word	ROM_TOP
	.ascii	"A1D3"
0:
	.endif
	lea		game_rom,a1
	add.w	d3,a1
	move.w	(a7)+,d3
	rts
	
	.ifndef	RELEASE
invalid_jump_table_index_error:
	.asciz	"invalid_jump_table_index_error"
load_rom_in_a4_from_d1d2_out_of_range_error:
	.asciz	"load_rom_in_a4_from_d1d2_out_of_range"
load_ram_in_a4_from_d1d2_out_of_range_error:
	.asciz	"load_ram_in_a4_from_d1d2_out_of_range"
load_rom_in_a0_from_d5d6_out_of_range_error:
	.asciz	"load_rom_in_a0_from_d5d6_out_of_range"
load_rom_in_a0_from_d6w_out_of_range_error:
	.asciz	"load_rom_in_a0_from_d6w_out_of_range"
load_ram_in_a1_from_d3d4_out_of_range_error:
	.asciz	"load_ram_in_a1_from_d3d4_out_of_range"
read_ram_out_of_range_error:
	.asciz	"read_ram_out_of_range"
load_rom_in_a1_from_d3w_error:
	.asciz	"load_rom_in_a1_from_d3w"
load_rom_in_a1_from_d3d4_error:
	.asciz	"load_rom_in_a1_from_d3d4"
	.endif
	.align	2

copy_a0_a1_d1_mem:
	move.b	(a1)+,(a0)+                         	| [$3520: LD      A,(DE)]
	                        	| [$3521: LD      (HL),A]
	                           	| [$3522: INC     DE]
	                           	| [$3523: INC     HL]
	move.b	(a1)+,(a0)                         	| [$3524: LD      A,(DE)]
	                         	| [$3525: LD      (HL),A]
	                           	| [$3526: INC     DE]
	add.w	d1,a0                            	| [$3527: ADD     HL,BC]
	rts
	
copy_2_byte_column_to_screen:
	move.b	(a1)+,d0                         	| [$3520: LD      A,(DE)]
	jbsr	osd_w_videoram                 | [$3521: LD      (HL),A]
	addq.w	#1,d7                          | [$3522: INC     DE]
	move.b	(a1)+,d0                       | [$3523: INC     HL]
	jbsr	osd_w_videoram                                	| [$3524: LD      A,(DE)]
	add.w	d1,d7                          | [$3525: LD      (HL),A]
	                                       | [$3526: INC     DE]  	
	                                   	| [$3527: ADD     HL,BC]     	
	                           	
   
	rts


STATE_START_NEW_LIFE = 0
STATE_INIT_NEW_PLAY_CLEAR_SCREEN = 1
STATE_INIT_NEW_PLAY_STEP_2 = 2
STATE_GAME_PLAYING = 3
STATE_PLAYER_HIT = 4
STATE_PLAYER_TURN_OVER = 5
STATE_BOSS_STAGE_COMPLETED = 6
STATE_END_OF_LEVEL_TRANSITION = 7
	DECL_ADDRESS	0
	
phoenix_reset:


l_0000:
	
	.ifndef	RELEASE
	* store base addresses
	move.l	#game_rom,0x100
	move.l	#fg_videoram_4000,0x104
	move.l	#bank_1,0x108
	move.l	#fg_videoram_4000+0x3A3,0x10C
	move.l	#bank_1+0x3A3,0x110
	tst.b	break_at_startup_flag
	beq.b	0f
	jbsr	osd_break
0:
	
	.endif
												| [$0000: NOP] Start/restart and interrupts end up at 0008
												| [$0001: NOP]
												| [$0002: NOP]
												| [$0003: NOP]
												| [$0004: NOP]
												| [$0005: NOP]
												| [$0006: NOP]
												| [$0007: NOP]

	lea		stack_top,a7						| LD      SP,unknown_4BFF            ; Top-ish of RAM

	moveq	#0,d0
	jbsr	osd_write_5000                 	| [$000b: LD      H,$50] 50xx video register
											| [$000d: LD      (HL),$00] Select the first bank of RAM & first palette
	jbsr	InitSoundScreen_0050              	| [$000f: CALL    InitSoundScreen_0050] Turn sound off and clear both screen areas
	
	
	lea	game_rom+0x1800,a0                      	| [$0012: LD      HL,$1800] Screen draw info
	move.b	#0x03,d2                        	| [$0015: LD      C,$03] 3 columns (rotated to 3 rows)
	jbsr	draw_game_status_01d0                            	| [$0017: CALL    $01D0] Draw the first 3 rows of the background (scores and coins);

	lea		highest_score_438B-2,a0
	jbsr	osd_read_high_scores
	jbsr	display_highscore_0306
	
* init has ended, enter the mainloop, always called no matter what
mainloop_001A:
	jbsr	WaitVBlankCoin_0080               	| [$001a: CALL    WaitVBlankCoin_0080] Wait for VBlank and count any coins
	move.b	game_in_play_43A2,d0            	| [$001d: LD      A,(game_in_play_43A2)]
	                               	| [$0020: AND     A]
	jeq	l_002d                             	| [$0021: JP      Z,$002D]
* called only when game is in play
	jbsr	in_game_scheduler_0400            	| [$0024: CALL    in_game_scheduler_0400]
	jbsr	l_2700                            	| [$0027: CALL    $2700]
	jra	mainloop_001A                      	| [$002a: JP      mainloop_001A]
* called only when game not in play
l_002d:
*	move.b	#0x0F,d0                        	| [$002d: LD      A,$0F]
*	move.b	#0x60,d5                        	| [$002f: LD      H,$60] 60xx sound A
*	move.b	d0,(a0)                         	| [$0031: LD      (HL),A]
*	move.b	#0x68,d5                        	| [$0032: LD      H,$68] 68xx sound B
*	move.b	d0,(a0)                         	| [$0034: LD      (HL),A]
	jbsr	l_0377                            	| [$0035: CALL    $0377]
	* if game has to reboot at some point it lands here
	                                    	| [$0038: NOP]
	jbsr	l_17e0                            	| [$0039: CALL    $17E0]
	tst.b	d0                               	| [$003c: AND     A]
	jeq	l_0046                             	| [$003d: JP      Z,$0046]
	jbsr	l_0288                            	| [$0040: CALL    $0288]
	jra	mainloop_001A                      	| [$0043: JP      mainloop_001A]
*
l_0046:
	jbsr	misc_event_trigger_routine_00e3                            	| [$0046: CALL    $00E3]
	jra	mainloop_001A                      	| [$0049: JP      mainloop_001A]

	DECL_ADDRESS	50

* Initialize the sound (off) and screen (clear)
InitSoundScreen_0050:
											| [$0050: LD      H,$68] 68xx sound B
												| [$0052: LD      (HL),$00] Sound off
											| [$0054: LD      H,$60] 60xx sound A
												| [$0056: LD      (HL),$00] Sound off
	moveq	#0,d0                        	| [$0058: LD      H,$58] 58xx scroll register
	jbsr	osd_set_scroll_value                    	| [$005a: LD      (HL),$00] set scrolling to zero
	* not necessary, all is zero
	*jbsr	ClearScreenPlane_006B             	| [$005c: CALL    ClearScreenPlane_006B] Clear the plane
	*move.b	#0x50,d5                        	| [$005f: LD      H,$50] 50xx video register
	*move.b	#0x01,(a0)                      	| [$0061: LD      (HL),$01] Second memory bank
	*jbsr	ClearScreenPlane_006B             	| [$0063: CALL    ClearScreenPlane_006B] Clear the plane
	*move.b	#0x50,d5                        	| [$0066: LD      H,$50] 50xx video register
	*clr.b	(a0)                             	| [$0068: LD      (HL),$00] Back to first memory bank

	rts                                    	| [$006a: RET] Done

* Clear a screen plane (foreground or background)
* Set the lower bit of the video register to pick fore/back.
* 4000 - 4BF8 (inclusive)
*
ClearScreenPlane_006B:
	lea	unknown_4BF8,a0                	| [$006b: LD      HL,unknown_4BF8] Highest point
	move.b	#0x3F,d0                        	| [$006e: LD      A,$3F] Stop when H reaches 3F
l_0070:
	clr.b	(a0)                             	| [$0070: LD      (HL),$00] Clear the memory
	subq.w	#1,a0                           	| [$0072: DEC     HL] Point to next
	cmp.l	#fg_videoram_4000,a0                            	| [$0073: CP      H] All done?
	jne	l_0070                             	| [$0074: JP      NZ,$0070] No ... go back for all
	rts                                    	| [$0077: RET] Done

l_0078:
	jbsr	draw_intro_text_0196                            	| [$0078: CALL    $0196]
	jra	l_06f0                             	| [$007b: JP      $06F0]



* Wait for the vertical blanking and then handle coin counting
*
WaitVBlankCoin_0080:
	* uncomment to pass intro sequence very fast
	* (cannot be skipped else it crashes the game)
	.ifne	OPT_SKIP_INTRO
	cmp.b	#3,sequence_timer_16bit_lsb_4399-1
	bcs.b	0f
	.endif
	jbsr	osd_wait_for_vblank
0:
	                	| [$0080: LD      H,$78] 78xx DSW0 Check ...
				| [$0082: LD      A,(HL)] ... screen blanking flag
			| [$0083: AND     $80] Wait for it ...
	              	| [$0085: JP      Z,WaitVBlankCoin_0080] ... to set

	                        	| [$0088: LD      A,(HL)] Check screen blanking flag
	     	| [$0089: AND     $80] Wait for it ...
	                   	| [$008b: JP      NZ,$0088] ... to clear (0=in blanking)
*
	jbsr	osd_read_inputs                        	| [$008e: LD      H,$70] 70xx IN0 Current value ...
	                         	| [$0090: LD      A,(HL)] ... of IN0 inputs
	lea	current_input_value_43A0,a0                	| [$0091: LD      HL,current_input_value_43A0] Value from ...
	move.b	(a0),d1                         	| [$0094: LD      B,(HL)] ... last read
	move.b	d0,(a0)+                         	| [$0095: LD      (HL),A] Store new value
	                           	| [$0096: INC     L] To 43A1
	move.b	d1,(a0)                         	| [$0097: LD      (HL),B] Store old value
	lea	random_seed_counter_value_439B,a0                        	| [$0098: LD      L,$9B] Bump the ...
	jbsr	AddOneToMem_0200                  	| [$009a: CALL    AddOneToMem_0200] ... ?? counter, probably used for random
	lea	CoinCount_438F,a0                        	| [$009d: LD      L,$8F] Get number ...
	move.b	(a0),d0                         	| [$009f: LD      A,(HL)] ... of coins
*
* !! There are two digits for "coins" on the screen, but only the one's digit is
* !! changed. Once you get to 9, the code stops counting. It takes the coin
* !! from you, but it doesn't give you credit.
*
	cmp.b	#0x09,d0                         	| [$00a0: CP      $09] Already 9?
	bne.b	0f                               	| [...]
	rts                                    	| [$00a2: RET     Z] Yes ... nothing more to check [...]
0:
	**jcc	l_0000                             	| [$00a3: JP      NC,$0000] More than 9? OOPS -- soft reset
	move.b	#0x01,d1                        	| [$00a6: LD      B,$01] Coin bit of the input register
	jbsr	check_input_bits_00bb                    	| [$00a8: CALL    check_input_bits_00bb] Has the coin input gone from 1 to 0?
	bne.b	0f                               	| [...]
	rts                                    	| [$00ab: RET     Z] No ... no coins inserted ... done [...]
0:
	* insert coin!
	lea	CoinCount_438F,a0                        	| [$00ac: LD      L,$8F] Add one ...
	addq.b	#1,(a0)                         	| [$00ae: INC     (HL)] ... to coin count (438F)
	move.b	(a0),d0                         	| [$00af: LD      A,(HL)] Current value ...
	add.b	#0x20,d0                         	| [$00b0: ADD     $20] ... to number tile
	move.w	#0x4142,d7
	jbsr	osd_w_videoram                 	| [$00b2: LD      (unknown_4142),A] Change number of coins on screen
	rts                                    	| [$00b5: RET] Done


	DECL_ADDRESS	bb
* Check to see if a particular bit(s) in the input register has changed
* from 1 to 0 since last we checked. Return NZ if transitioned from 1 to 0.
*
check_input_bits_00bb:
	lea	current_input_value_43A0,a0                	| [$00bb: LD      HL,current_input_value_43A0] Get current ...
	move.b	(a0)+,d0                         	| [$00be: LD      A,(HL)] ... input value
	not.b	d0                               	| [$00bf: CPL] Flip the current bits
	and.b	d1,d0                            	| [$00c0: AND     B] Mask off all but the ones we are checking
											| [$00c1: INC     L] Point to last input value
	and.b	(a0),d0                          	| [$00c2: AND     (HL)] Zero unles new bit is 0 and old is 1
	rts                                    	| [$00c3: RET] Return state

	DECL_ADDRESS	c4
* < A0: data to write (0x.0-0x.9) as BCD
* < D3: screen address
* < D1: number of digits to write

write_digits_to_screen_00c4:
	move.b	(a0),d0                         	| [$00c4: LD      A,(HL)]
	and.b	#0x0F,d0                         	| [$00c5: AND     $0F]
	* start of digits row
	or.b	#0x20,d0                          	| [$00c7: OR      $20]
	move.w	d3,d7
	jbsr	osd_w_videoram                         	| [$00c9: LD      (DE),A]
	jbsr	AddOneRow_0210                    	| [$00ca: CALL    AddOneRow_0210]
	subq.b	#1,d1                           	| [$00cd: DEC     B]
	bne.b	0f                               	| [...]
	rts                                    	| [$00ce: RET     Z] [...]
0:
	* second nibble
	move.b	(a0),d0                         	| [$00cf: LD      A,(HL)]
	ror.b	#4,d0                            	| [$00d0: RRCA] * 4
	and.b	#0x0F,d0                         	| [$00d4: AND     $0F]
	or.b	#0x20,d0                          	| [$00d6: OR      $20]
	move.w	d3,d7
	jbsr	osd_w_videoram                         	| [$00d8: LD      (DE),A]
	jbsr	AddOneRow_0210                    	| [$00d9: CALL    AddOneRow_0210]
	subq.w	#1,a0                           	| [$00dc: DEC     HL]
	subq.b	#1,d1                           	| [$00dd: DEC     B]
	jne	write_digits_to_screen_00c4                             	| [$00de: JP      NZ,$00C4]
	rts                                    	| [$00e1: RET]

* depending on counter, perform various stuff
* test_if_mem_between_d1_and_d3_0260 returns carry clear if timer (4399) is within the interval
* given by D1/D3: D1<=(4399.W)<=D3

misc_event_trigger_routine_00e3:
	lea	sequence_timer_16bit_lsb_4399,a0                	| [$00e3: LD      HL,sequence_timer_16bit_lsb_4399]
	jbsr	AddOneToMem_0200                  	| [$00e6: CALL    AddOneToMem_0200]
	move.w	#0x0001,d1                      	| [$00e9: LD      BC,$0001] 1
	jbsr	CompareBCtoMem_0258               	| [$00ec: CALL    CompareBCtoMem_0258]
	jeq	l_01e1                             	| [$00ef: JP      Z,$01E1]
	move.w	#0x0002,d1                      	| [$00f2: LD      BC,$0002] 2
	move.w	#0x011F,d3                      	| [$00f5: LD      DE,$011F]
	jbsr	test_if_mem_between_d1_and_d3_0260             	| [$00f8: CALL    test_if_mem_between_d1_and_d3_0260]
	jcc	draw_intro_text_0196                             	| [$00fb: JP      NC,$0196] draw text if timer in interval
	move.w	#0x0120,d1                      	| [$00fe: LD      BC,$0120]
	jbsr	CompareBCtoMem_0258               	| [$0101: CALL    CompareBCtoMem_0258]
	jeq	draw_bird_extended_winds_0bca                             	| [$0104: JP      Z,$0BCA]
	move.w	#0x01B0,d1                        	| [$0107: LD      C,$B0]
	jbsr	CompareBCtoMem_0258               	| [$0109: CALL    CompareBCtoMem_0258]
	jeq	l_01e1                             	| [$010c: JP      Z,$01E1]
	move.w	#0x01B8,d1                        	| [$010f: LD      C,$B8]
	jbsr	CompareBCtoMem_0258               	| [$0111: CALL    CompareBCtoMem_0258]
	jeq	init_scrolling_data_0580                             	| [$0114: JP      Z,$0580]
	move.w	#0x01C0,d1                        	| [$0117: LD      C,$C0]
	move.w	#0x02DF,d3                      	| [$0119: LD      DE,$02DF]
	jbsr	test_if_mem_between_d1_and_d3_0260             	| [$011c: CALL    test_if_mem_between_d1_and_d3_0260]
	jcc	l_0078                             	| [$011f: JP      NC,$0078]
	move.w	#0x0300,d1                      	| [$0122: LD      BC,$0300]
	move.w	#0x03AF,d3                      	| [$0125: LD      DE,$03AF]
	jbsr	test_if_mem_between_d1_and_d3_0260             	| [$0128: CALL    test_if_mem_between_d1_and_d3_0260]
	jcc	animate_title_vulture_21dc                             	| [$012b: JP      NC,$21DC]
	* after that, this is intro sequence
	move.w	#0x03E6,d1                      	| [$012e: LD      BC,$03E6]
	moveq	#-1,d3                      	| [$0131: LD      DE,$FFFF]
	jbsr	test_if_mem_between_d1_and_d3_0260             	| [$0134: CALL    test_if_mem_between_d1_and_d3_0260]
	jcc	rest_of_intro_sequence_03b0                             	| [$0137: JP      NC,$03B0]
	rts                                    	| [$013a: RET]



init_new_play_0140:
	jbsr	clear_background_tiles_03a0                            	| [$0140: CALL    $03A0]
	jbsr	WaitVBlankCoin_0080               	| [$0143: CALL    WaitVBlankCoin_0080]
	jbsr	clear_foreground_tiles_0380                            	| [$0146: CALL    $0380]
	lea	current_player_is_p2_43A3,a0                	| [$0149: LD      HL,current_player_is_p2_43A3]
	move.b	#0x02,(a0)+                      	| [$014c: LD      (HL),$02]
	                           	| [$014e: INC     L]
	clr.b	(a0)                             	| [$014f: LD      (HL),$00]
	                                    	| [$0151: NOP]
	                                    	| [$0152: NOP]
	                                    	| [$0153: NOP]
	lea	current_stage_43B8,a0                        	| [$0154: LD      L,$B8]
	move.b	#0x08,d1                        	| [$0156: LD      B,$08]
	jbsr	clear_area_05D8                   	| [$0158: CALL    clear_area_05D8]
	lea	nb_birds_to_kill_before_stage_completed_43BA,a0                        	| [$015b: LD      L,$BA]
	move.b	#0x10,(a0)                      	| [$015d: LD      (HL),$10]
	lea	extra_life_at_thousands_43BE,a0                        	| [$015f: LD      L,$BE]
	jbsr	osd_read_dipswitches                       	| [$0161: LD      A,($7800)] 78xx DSW0
	and.b	#0x0C,d0                         	| [$0164: AND     $0C] Bonus lives
	rol.b	#2,d0                            	| [$0166: RLCA] * 2
	add.b	#0x30,d0                         	| [$0168: ADD     $30]
	move.b	d0,(a0)                         	| [$016a: LD      (HL),A]
	moveq	#0,d0                        	| [$016b: LD      H,$58] 58xx scroll register
	jbsr	osd_set_scroll_value                             	| [$016d: LD      (HL),$00]
	jbsr	WaitVBlankCoin_0080               	| [$016f: CALL    WaitVBlankCoin_0080]
	rts                                    	| [$0172: RET]

l_0173:
	move.b	(a0),d0                         	| [$0173: LD      A,(HL)]
	and.b	#0x7F,d0                         	| [$0174: AND     $7F]
	move.b	#0xCE,d1                        	| [$0176: LD      B,$CE]
	cmp.b	#0x1F,d0                         	| [$0178: CP      $1F]
	bcc.b	0f                               	| [...]
	rts                                    	| [$017a: RET     C] [...]
0:
	move.b	#0xFE,d1                        	| [$017b: LD      B,$FE]
	cmp.b	#0x1F,d0
	bne.b	0f                               	| [...]
	rts                                    	| [$017d: RET     Z] [...]
0:
	move.b	#0xAE,d1                        	| [$017e: LD      B,$AE]
	cmp.b	#0x5F,d0                         	| [$0180: CP      $5F]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0182: RET     C] [...]
0:
	move.b	#0xFE,d1                        	| [$0183: LD      B,$FE]
	tst.b	d0
	bne.b	0f                               	| [...]
	rts                                    	| [$0185: RET     Z] [...]
0:
	move.b	#0xCE,d1                        	| [$0186: LD      B,$CE]
	cmp.b	#0x7F,d0                         	| [$0188: CP      $7F]
	bcc.b	0f                               	| [...]
	rts                                    	| [$018a: RET     C] [...]
0:
	move.b	#0xFE,d1                        	| [$018b: LD      B,$FE]
	                           	| [$018d: DEC     L]
	move.b	-(a0),d0                         	| [$018e: LD      A,(HL)]
	cmp.b	#0x09,d0                         	| [$018f: CP      $09]
	beq.b	0f                               	| [...]
	rts                                    	| [$0191: RET     NZ] [...]
0:
	move.b	#0x7E,d1                        	| [$0192: LD      B,$7E]
	rts                                    	| [$0194: RET]

* HL=$4399 on entry
draw_intro_text_0196:
	move.b	(a0),d0                         	| [$0196: LD      A,(HL)]
	and.b	#0x1F,d0                         	| [$0197: AND     $1F]
	cmp.b	#0x06,d0                         	| [$0199: CP      $06]
	bcc.b	0f                               	| [...]
	rts                                    	| [$019b: RET     C] [...]
0:
	move.b	d0,d4                           	| [$019c: LD      E,A]
	move.b	(a0),d0                         	| [$019d: LD      A,(HL)]
	and.b	#0xE0,d0                         	| [$019e: AND     $E0]
	move.b	d0,d2                           	| [$01a0: LD      C,A]
	                           	| [$01a1: DEC     L]
	move.b	-(a0),d1                         	| [$01a2: LD      B,(HL)]
	lea	unknown_43A8,a0                        	| [$01a3: LD      L,$A8]
	move.b	d1,(a0)+                         	| [$01a5: LD      (HL),B]
	                           	| [$01a6: INC     L]
	move.b	d2,(a0)                         	| [$01a7: LD      (HL),C]
	move.b	#0x18,d1                      	| [$01a8: LD      BC,$1860]
	move.b	#0x60,d2                      	| [$01a8: LD      BC,$1860]
	jbsr	AddBCtoMem_0206                   	| [$01ab: CALL    AddBCtoMem_0206]
	move.b	(a0),d0                         	| [$01ae: LD      A,(HL)]
	                           	| [$01af: DEC     L]
	move.b	-(a0),d5                         	| [$01b0: LD      H,(HL)]
	move.b	d0,d6                           	| [$01b1: LD      L,A]
	bsr		load_rom_in_a0_from_d5d6
	moveq	#0,d0
	move.b	d4,d0                           	| [$01b2: LD      A,E]
	* get screen address to display current char
	move.b	(a0),d3                         	| [$01b3: LD      D,(HL)]
	                           	| [$01b4: INC     L]
	move.b	(1,a0),d4                         	| [$01b5: LD      E,(HL)]
	                           	| [$01b6: DEC     L]
	                           	| [$01b7: LD      C,A]
	add.w	d0,a0                            	| [$01b8: ADD     A,L]
	                           	| [$01b9: LD      L,A]
	                           	| [$01ba: LD      A,C]
	LOAD_D3_16_FROM_D3D4
	subq.b	#0x06,d0                        	| [$01bb: SUB     $06]
	jeq	l_01c8                             	| [$01be: JP      Z,$01C8]
	move.b	d0,d2                           	| [$01bd: LD      C,A]
l_01c1:
	jbsr	SubtractOneRow_0217               	| [$01c1: CALL    SubtractOneRow_0217]
	subq.b	#1,d2                           	| [$01c4: DEC     C]
	jne	l_01c1                             	| [$01c5: JP      NZ,$01C1]
l_01c8:
	move.b	d0,d2                           	| [$01bd: LD      C,A]
	move.b	(a0),d0                         	| [$01c8: LD      A,(HL)]
	move.w	d3,d7
	jbsr	osd_w_videoram                         	| [$01c9: LD      (DE),A]
	jra	l_14e0                             	| [$01ca: JP      $14E0]
	                            	| [$01cd: JP      NZ,$01C0]

draw_game_status_01d0:
	move.b	(a0)+,d3                         	| [$01d0: LD      D,(HL)] Get ...
											| [$01d1: INC     L] ... the ...
	move.b	(a0),d4                         	| [$01d2: LD      E,(HL)] ... screen coord
											| [$01d3: LD      A,L] Add 5 ...
	addq.w	#0x05,a0                        	| [$01d4: ADD     $05] ... go get ...
												| [$01d6: LD      L,A] ... data
	move.b	#0x1A,d1                        	| [$01d7: LD      B,$1A] 26 columns
	LOAD_D3_16_FROM_D3D4

	
	
	jbsr	DrawColumn_01ED                   	| [$01d9: CALL    DrawColumn_01ED] Draw next column
	subq.b	#1,d2                           	| [$01dc: DEC     C] All columns done?
	jne	draw_game_status_01d0                             	| [$01dd: JP      NZ,$01D0] No ... draw all columns
	rts                                    	| [$01e0: RET] Done

l_01e1:
	jbsr	init_new_play_0140                            	| [$01e1: CALL    $0140]
l_01e4:
	lea	game_rom+0x1960,a0                      	| [$01e4: LD      HL,$1960]
	move.b	#0x03,d2                        	| [$01e7: LD      C,$03]
	jra	draw_game_status_01d0                             	| [$01e9: JP      $01D0]


* Remember the screen is rotated.
* The draws a column in screen memory (row on the screen)
*
DrawColumn_01ED:
	move.w	d3,d7
0:
	move.b	(a0)+,d0                         	| [$01ed: LD      A,(HL)] Copy the data ...
	jbsr	osd_w_videoram                         	| [$01ee: LD      (DE),A] .. to the screen
												| [$01ef: INC     HL] Next in data
	sub.w	#0x20,d7               	| [$01f0: CALL    SubtractOneRow_0217] Move DE to next row
	subq.b	#1,d1                           	| [$01f3: DEC     B] All drawn?
	jne	0b                    	| [$01f4: JP      NZ,DrawColumn_01ED] Draw them all
	rts                                    	| [$01f7: RET] Done


* Two-byte +1 to (HL-1) : (HL).
*
AddOneToMem_0200:
	addq.b	#1,(a0)                         	| [$0200: INC     (HL)] Add one to LSB
	beq.b	0f                               	| [...]
	rts                                    	| [$0201: RET     NZ] We didn't overflow ... done [...]
0:
	                           	| [$0202: DEC     L] Back up to MSB
	addq.b	#1,(-1,a0)                         	| [$0203: INC     (HL)] Carry into the MSB
	                           	| [$0204: INC     L] Restore point to LSB
	rts                                    	| [$0205: RET] Done

* Two-byte addition. BC is added to (HL-1) : (HL).
*
AddBCtoMem_0206:
	                         	| [$0206: LD      A,(HL)] Get the lower byte
	                          	| [$0207: ADD     A,C] Add C to the lower
	add.b	d2,(a0)                         	| [$0208: LD      (HL),A] Store the new lower
	                           	| [$0209: DEC     L] Back up to upper byte
	move.b	-(a0),d0                         	| [$020a: LD      A,(HL)] Add B and carry ...
	addx.b	d1,d0                           	| [$020b: ADC     A,B] ... to upper byte
	move.b	d0,(a0)+                         	| [$020c: LD      (HL),A] Store the new upper byte
	                           	| [$020d: INC     L] Restore pointer to LSB
	rts                                    	| [$020e: RET] Done


* Add 32 (one row) to DE (two bytes)
*
AddOneRow_0210:
	                           	| [$0210: LD      A,E] Add ...
	add.w	#0x20,d3                         	| [$0211: ADD     $20] ... 32 to ...
	                           	| [$0213: LD      E,A] ... E
	                               	| [...]
	rts                                    	| [$0214: RET     NC] No carry ... we are done [...]

                       	| [$0215: INC     D] Carry into D
                      	| [$0216: RET] Done

* Subtract 32 (one rom) from DE (two bytes)
SubtractOneRow_0217:
	sub.w	#0x20,d3
	rts
	
	   	| [$0217: LD      A,E] Subtract ...
	    	| [$0218: SUB     $20] ... 32 from ...
	   	| [$021a: LD      E,A] ... E
	    	| [...]
	  	| [$021b: RET     NC] No borrow ... we are done [...]
   	| [$021c: DEC     D] Borrow from D                                   	| [$021d: RET] Done


* 3-byte (6 digit) BCD addition. Add BC*10 to (HL-2):(HL-1):(HL).
* The games keeps the lowest digit of the scores to 0.
*
* < D1/D2: score to add
* < HL: pointer on score

AddToScore_0220:
	movem.l	a0-a1/d0-d1,-(a7)
	CLEAR_XC_FLAGS
	
	clr.b	d0                               	| [$0220: XOR     A] !! Pointless. We are about to change A and the flags
	move.b	(a0),d0                         	| [$0221: LD      A,(HL)] Lowest 2 digits
	abcd	d2,d0                            	| [$0222: ADD     A,C] Add C to score
												| Adjust for binary coded decimal
	move.b	d0,(a0)                         	| [$0224: LD      (HL),A] Update lowest 2 digits
	                           	| [$0225: DEC     L] Point to middle 2 digits
	move.b	-(a0),d0                         	| [$0226: LD      A,(HL)] Add B to ...
	abcd	d1,d0                           	| [$0227: ADC     A,B] ... score
                         | Adjust for BCD
	move.b	d0,(a0)                         	| [$0229: LD      (HL),A] Store the middle 2 digits
	                           	| [$022a: DEC     L] Point to the upper 2 digits
	move.b	-(a0),d0                         	| [$022b: LD      A,(HL)] Add in ...
	move.b	#0x00,d7                        	| [$022c: ADC     $00] ... any carry
	abcd	d7,d0                           	| [$022c: ADC     $00] ... any carry

                         | Adjust for binary coded decimal
	move.b	d0,(a0)                         	| [$022f: LD      (HL),A] Store the upper 2 digits
	                           	| [$0230: INC     L] * 2 Restore ...


	jbsr	update_highscore_02f0                            	| [$02b0: CALL    $02F0]
	movem.l	(a7)+,a0-a1/d0-d1
	rts                                    	| [$0232: RET] Done


                                 	| [$0252: RET] Done


* Two byte compare of BC to memory at (HL-1):(HL)
*
* < A0: memory (points to word)
* < D1.W: value to compare to

CompareBCtoMem_0258:
	move.b	(-1,a0),d0
	lsl.w	#8,d0
	move.b	(a0),d0                         	| [$0258: LD      A,(HL)] Value from memory
	
	cmp.w	d1,d0                            	| [$0259: CP      C] Are the values the same?
	rts

* Subtract DE from memory if memory is greater/equal to BC.
*
* < A0 points to 16 bit data
* < D3.W
test_if_mem_between_d1_and_d3_0260:
	jbsr	SubtractFromMemory_0270           	| [$0260: CALL    SubtractFromMemory_0270] Try subtraction. Is memory larger (or equal) to BC?
	bcc.b	0f                               	| [...]
	rts                                    	| [$0263: RET     C] No ... ignore request [...]
0:
	jbra	SubtractToMemory_0277             	| [$0264: CALL    SubtractToMemory_0277] Yes ... subtract DE from memory
	                                    	| [$0267: RET] Done



* Two byte subtraction of memory from BC. BC = BC -  (HL-1):(HL)
*
* better reimplemented as 16 bit comparison

SubtractFromMemory_0270:
	move.b	(-1,a0),d0
	lsl.w	#8,d0
	move.b	(a0),d0
	cmp.w	d1,d0
	rts
	

	                       	| [$0270: LD      A,(HL)] Get the low byte
	                        	| [$0271: SUB     C] Subtract from C
	          	| [$0272: DEC     L] Point to upper byte
	                         	| [$0273: LD      A,(HL)] Get the upper byte
	
	                       	| [$0274: SBC     B] Subtract from B (with borrow)
	          	| [$0275: INC     L] Restore pointer
	
	rts                                    	| [$0276: RET] Done

* Two byte subtraction of DE from memory. (HL-1):(HL) = (HL-1):(HL) - DE
SubtractToMemory_0277:
	move.b	(-1,a0),d0
	lsl.w	#8,d0
	move.b	(a0),d0

	cmp.w	d0,d3
	rts
	

	                     	| [$0277: LD      A,E] Lower byte
	                      	| [$0278: SUB     (HL)] Subtract it from memory
	        	| [$0279: DEC     L] Point to upper byte
	
	                     	| [$027a: LD      A,D] Value to A
	
	                        	| [$027b: SBC     (HL)] Subtract upper byte from memory (with borrow)
	                   	| [$027b: SBC     (HL)] Subtract upper byte from memory (with borrow)
	                           	| [$027c: INC     L] Restore pointer
	rts                                    	| [$027d: RET] Done


l_0288:
	jbsr	init_new_play_0140                            	| [$0288: CALL    $0140]
	lea	game_rom+0x19C0,a0                      	| [$028b: LD      HL,$19C0]
	move.b	#0x02,d2                        	| [$028e: LD      C,$02]
	jbsr	draw_game_status_01d0                            	| [$0290: CALL    $01D0]
	move.b	#0x02,d2                        	| [$0293: LD      C,$02]
	jbsr	l_17e0                            	| [$0295: CALL    $17E0]
	cmp.b	#0x02,d0                         	| [$0298: CP      $02]
	jcs	l_02a7                             	| [$029a: JP      C,$02A7]
	lea	game_rom+0x1BA0,a0                      	| [$029d: LD      HL,$1BA0]
	move.b	#0x01,d2                        	| [$02a0: LD      C,$01]
	jbsr	draw_game_status_01d0                            	| [$02a2: CALL    $01D0]
	move.b	#0x06,d2                        	| [$02a5: LD      C,$06]
l_02a7:
	jbsr	osd_read_inputs                       	| [$02a7: LD      A,($7000)] 70xx IN0
	not.b	d0                               	| [$02aa: CPL]
	* start bit(s) 1 or 2
	and.b	d2,d0                            	| [$02ab: AND     C]
	bne.b	0f                               	| [...]
	rts                                    	| [$02ac: RET     Z] [...]
0:
	jbsr	decrease_credits_02cb                            	| [$02ad: CALL    $02CB]
	* we should update highscore in real time like newer games
	jbsr	zero_player_scores_032e                            	| [$02b3: CALL    $032E]
	jbsr	init_player_lives_0350                            	| [$02b6: CALL    $0350]
	jbsr	init_new_play_0140                            	| [$02b9: CALL    $0140]

	moveq	#1,d0			
	jbsr	osd_write_5000                      	| [$02bc: LD      H,$50] 50xx video register
	                      	| [$02be: LD      (HL),$01] set bank 1, init new play for player 2???
	jbsr	init_new_play_0140                            	| [$02c0: CALL    $0140]
	moveq	#0,d0                        	| [$02c3: LD      H,$50] 50xx video register
	jbsr	osd_write_5000                             	| [$02c5: LD      (HL),$00] set bank 0

	* hack to also force screen refresh because switch to bank 1 also switched
	* palette and redrawn a cleared screen, but it's not drawn back when reswitching
	* to bank 0
	jbsr	osd_full_screen_redraw
	
	clr.b	vulture_sound_toggle
	move.w	#START_MUSIC_SND,d0
	jbsr	osd_sound_start

	rts                                    	| [$02c7: RET]


* start 1P or 2P game

decrease_credits_02cb:
	move.b	#0x01,d2                        	| [$02cb: LD      C,$01]
	cmp.b	#0x02,d0                         	| [$02cd: CP      $02]
	jeq	l_02d4                             	| [$02cf: JP      Z,$02D4]
	move.b	#0x02,d2                        	| [$02d2: LD      C,$02]
l_02d4:
	* set number of players
	lea	game_in_play_43A2,a0           	| [$02d4: LD      HL,game_in_play_43A2]
	move.b	d2,(a0)                         	| [$02d7: LD      (HL),C]
	jbsr	osd_read_dipswitches                       	| [$02d8: LD      A,($7800)] 78xx DSW0
	and.b	#0x10,d0                         	| [$02db: AND     $10] Coinage
	jeq	l_02e3                             	| [$02dd: JP      Z,$02E3]
	                          	| [$02e0: LD      A,C]
	rol.b	#1,d2                            	| [$02e1: RLCA]
	                           	| [$02e2: LD      C,A]
l_02e3:
	lea	CoinCount_438F,a0                        	| [$02e3: LD      L,$8F]
	move.b	(a0),d0                         	| [$02e5: LD      A,(HL)]
	sub.b	d2,d0                            	| [$02e6: SUB     C]
	move.b	d0,(a0)                         	| [$02e7: LD      (HL),A]
	add.b	#0x20,d0                         	| [$02e8: ADD     $20]
	move.w	#0x4142,d7                 	| [$02ea: LD      (unknown_4142),A]
	jbsr	osd_w_videoram
	rts                                    	| [$02ed: RET]


update_highscore_02f0:
	lea	player_2_score_end_4383,a1                	| [$02f0: LD      DE,player_2_score_end_4383]
	lea	highest_score_438B,a0                	| [$02f3: LD      HL,highest_score_438B]
	jbsr	compare_scores_0314                            	| [$02f6: CALL    $0314]
	bcs.b	0f                               	| [...]
	st.b	highscores_beaten_flag
	jbsr	copy_3_bytes_a0_a1_0320                            	| [$02f9: CALL    NC,$0320]
0:
	lea	player_score_end_4387,a1										| [$02fc: LD      E,$87]
	lea	highest_score_438B,a0										| [$02fe: LD      L,$8B]
	jbsr	compare_scores_0314                            	| [$0300: CALL    $0314]
	bcs.b	0f                               	| [...]
	st.b	highscores_beaten_flag
	jbsr	copy_3_bytes_a0_a1_0320                            	| [$0303: CALL    NC,$0320]
0:
display_highscore_0306:
	lea	highest_score_438B,a0                        	| [$0306: LD      L,$8B]
	move.w	#0x4141,d3                	| [$0308: LD      DE,unknown_4141]
	move.b	#0x06,d1                        	| [$030b: LD      B,$06]
	jbsr	write_digits_to_screen_00c4                            	| [$030d: CALL    $00C4]
	rts                                    	| [$0310: RET]


compare_scores_0314:
	move.b	(a1),d0                         	| [$0314: LD      A,(DE)]
	sub.b	(a0),d0                          	| [$0315: SUB     (HL)]
												| [$0316: DEC     E]
												| [$0317: DEC     L]
	move.b	-(a1),d0                         	| [$0318: LD      A,(DE)]
	move.b	-(a0),d7                         	| [$0319: SBC     (HL)]
	subx.b	d7,d0                         	| [$0319: SBC     (HL)]
	                           	| [$031a: DEC     E]
	                           	| [$031b: DEC     L]
	move.b	-(a1),d0                         	| [$031c: LD      A,(DE)]
	move.b	-(a0),d7                         	| [$031d: SBC     (HL)]
	subx.b	d7,d0                         	| [$031d: SBC     (HL)]
	rts                                    	| [$031e: RET]

copy_3_bytes_a0_a1_0320:
	move.b	(a1)+,(a0)+                         	| [$0320: LD      A,(DE)]
	                         	| [$0321: LD      (HL),A]
											| [$0322: INC     DE]
											| [$0323: INC     HL]
	move.b	(a1)+,(a0)+                         	| [$0324: LD      A,(DE)]
										| [$0325: LD      (HL),A]
											| [$0326: INC     DE]
	                           	| [$0327: INC     HL]
	move.b	(a1),d0                         	| [$0328: LD      A,(DE)]
	move.b	d0,(a0)                         	| [$0329: LD      (HL),A]
	rts                                    	| [$032a: RET]


zero_player_scores_032e:
	* clears 7 bytes for both player scores
	lea	player_scores_buffer_4380,a0                	| [$032e: LD      HL,player_scores_buffer_4380]
	clr.l	(a0)+
	clr.w	(a0)+
	clr.b	(a0)				
											| [$0331: LD      (HL),$00]
											| [$0333: INC     HL]
											| [$0334: LD      A,L]
							| [$0335: CP      $88]
												| [$0337: JP      NZ,$0331]
	lea	player_2_score_end_4383,a0                        	| [$033a: LD      L,$83]
	move.w	#0x4261,d3                	| [$033c: LD      DE,unknown_4261]
	move.b	#0x06,d1                        	| [$033f: LD      B,$06]
	jbsr	write_digits_to_screen_00c4                            	| [$0341: CALL    $00C4]
	lea	player_score_end_4387,a0                        	| [$0344: LD      L,$87]
	move.w	#0x4021,d3                	| [$0346: LD      DE,unknown_4021]
	move.b	#0x06,d1                        	| [$0349: LD      B,$06]
	jbsr	write_digits_to_screen_00c4                            	| [$034b: CALL    $00C4]
	rts                                    	| [$034e: RET]

	DECL_ADDRESS	350
	
init_player_lives_0350:
	jbsr	osd_read_dipswitches                       	| [$0350: LD      A,($7800)] 78xx DSW0
	and.b	#0x03,d0                         	| [$0353: AND     $03] Lives
	addq.b	#0x03,d0                        	| [$0355: ADD     $03]
	move.b	d0,d1                           	| [$0357: LD      B,A]
	lea	nb_lives_p1_4390,a0            	| [$0358: LD      HL,nb_lives_p1_4390]
	move.b	d1,(a0)                         	| [$035b: LD      (HL),B]
	lea	game_in_play_43A2,a0                        	| [$035c: LD      L,$A2]
	move.b	(a0),d0                         	| [$035e: LD      A,(HL)]
	cmp.b	#0x01,d0                         	| [$035f: CP      $01] current player
	jeq	display_players_lives_0367                             	| [$0361: JP      Z,$0367]
	lea	nb_lives_p2_4391,a0                        	| [$0364: LD      L,$91]
	move.b	d1,(a0)                         	| [$0366: LD      (HL),B] nb lives player 2
display_players_lives_0367:
	lea	nb_lives_p1_4390,a0                        	| [$0367: LD      L,$90]
	move.b	(a0)+,d0                         	| [$0369: LD      A,(HL)]
	or.b	#0x20,d0                          	| [$036a: OR      $20]
	move.w	#0x42A2,d7                 	| [$036c: LD      (unknown_42A2),A]
	jbsr	osd_w_videoram
	                           	| [$036f: INC     L]
	move.b	(a0),d0                         	| [$0370: LD      A,(HL)]
	or.b	#0x20,d0                          	| [$0371: OR      $20]
	move.w	#0x4062,d7                 	| [$0373: LD      (unknown_4062),A]
	jbsr	osd_w_videoram
	rts                                    	| [$0376: RET]

l_0377:
	lea	sound_buffer_438C,a0                	| [$0377: LD      HL,sound_buffer_438C]
	move.b	d0,(a0)+                         	| [$037a: LD      (HL),A]
	                           	| [$037b: INC     L]
	move.b	d0,(a0)                         	| [$037c: LD      (HL),A]
	rts                                    	| [$037d: RET]



clear_foreground_tiles_0380:
	move.w	#0x433F,d7                	| [$0380: LD      HL,unknown_433F]  bottom left corner
	                      	| [$0383: LD      DE,$001F] 31
	move.w	#0x1F,d4                      	| [$0383: LD      DE,$001F] 31
	move.b	#3,d1
	move.b	#0x3F,d2                   	| [$0386: LD      BC,$033F]
l_0389:
	clr.b	d0                         	| [$0389: LD      (HL),D]
	jbsr	osd_w_videoram                    	| [$038a: DEC     HL]
	subq.w	#1,d7
	jbsr	osd_w_videoram                         	| [$038b: LD      (HL),D]
	subq.w	#1,d7                           	| [$038c: DEC     HL]
	move.w	d7,d6
	move.b	d6,d0                           	| [$038d: LD      A,L]
	and.b	d4,d0                            	| [$038e: AND     E]
	cmp.b	d1,d0                            	| [$038f: CP      B]
	jne	l_0389                             	| [$0390: JP      NZ,$0389]
	clr.b	d0
	jbsr	osd_w_videoram                         	| [$0393: LD      (HL),D]
	subq.w	#4,d7                           	| [$0394: DEC     HL] * 4
	move.w	d7,d0                           	| [$0398: LD      A,H]
	ror.w	#8,d0
	cmp.b	d2,d0                            	| [$0399: CP      C]
	jne	l_0389                             	| [$039a: JP      NZ,$0389]
	rts                                    	| [$039d: RET]



clear_background_tiles_03a0:
	move.w	#0x4B3F,d7                	| [$03a0: LD      HL,unknown_4B3F]  bottom left corner, background
	move.w	#0x47,d4                      	| [$03a3: LD      DE,$0047] 71
l_03a6:
	clr.b	d0
	jbsr	osd_w_videoram                         	| [$03a6: LD      (HL),D]
	subq.w	#1,d7                           	| [$03a7: DEC     HL]
	jbsr	osd_w_videoram                         	| [$03a8: LD      (HL),D]
	subq.w	#1,d7                           	| [$03a9: DEC     HL]
	move.w	d7,d0                           	| [$03aa: LD      A,H]
	ror.w	#8,d0
	cmp.b	d4,d0                            	| [$03ab: CP      E]
	jne	l_03a6                             	| [$03ac: JP      NZ,$03A6]
	rts                                    	| [$03af: RET]
	
	
rest_of_intro_sequence_03b0:
	move.w	#0x07A0,d1                      	| [$03b0: LD      BC,$07A0]
	jbsr	SubtractFromMemory_0270           	| [$03b3: CALL    SubtractFromMemory_0270]
	jcs	l_03ce                             	| [$03b6: JP      C,$03CE]
	jbsr	CompareBCtoMem_0258               	| [$03b9: CALL    CompareBCtoMem_0258]
	jeq	l_03eb                             	| [$03bc: JP      Z,$03EB]
	move.w	#0x0B60,d1                      	| [$03bf: LD      BC,$0B60]
	jbsr	SubtractFromMemory_0270           	| [$03c2: CALL    SubtractFromMemory_0270]
	jcs	l_03ce                             	| [$03c5: JP      C,$03CE]
	jbsr	CompareBCtoMem_0258               	| [$03c8: CALL    CompareBCtoMem_0258]
	jeq	l_03e2                             	| [$03cb: JP      Z,$03E2]
l_03ce:
	jbsr	l_0173                            	| [$03ce: CALL    $0173]
	lea	current_input_value_43A0,a0                	| [$03d1: LD      HL,current_input_value_43A0]
	move.b	(a0),d0                         	| [$03d4: LD      A,(HL)]
	and.b	#0x01,d0                         	| [$03d5: AND     $01]
	or.b	d1,d0                             	| [$03d7: OR      B]
	move.b	d0,(a0)                         	| [$03d8: LD      (HL),A]
	jra	in_game_scheduler_0400             	| [$03d9: JP      in_game_scheduler_0400]
												| [$03dc: JP      in_game_scheduler_0400]


l_03e2:
	move.b	#1,d1
	move.b	#8,d2
	move.b	#1,d3
	move.b	#0,d4
											| [$03e2: LD      BC,$0108]
											| [$03e5: LD      DE,$1000]
	jra	l_03f1                             	| [$03e8: JP      $03F1]
l_03eb:
	move.b	#1,d1
	move.b	#4,d2
	move.b	#0,d3
	move.b	#8,d4

										| [$03eb: LD      BC,$0104]
									| [$03ee: LD      DE,$0008] 8
l_03f1:
	lea	game_state_43A4,a0             	| [$03f1: LD      HL,game_state_43A4]
	move.b	d1,(a0)                         	| [$03f4: LD      (HL),B]
	lea	current_stage_43B8,a0                       	| [$03f5: LD      L,$B8]
	move.b	d2,(a0)                         	| [$03f7: LD      (HL),C]
	lea	nb_birds_to_kill_before_stage_completed_43BA,a0                        	| [$03f8: LD      L,$BA]
	move.b	d3,(a0)                         	| [$03fa: LD      (HL),D]
	addq.w	#1,a0                           	| [$03fb: INC     L]
	move.b	d4,(a0)                         	| [$03fc: LD      (HL),E]
	rts                                    	| [$03fd: RET]


* seems to be the main scheduling routine
* Jump to ?? function by number in 43A4
in_game_scheduler_0400:
	lea	jump_table_040E,a0             	| [$0400: LD      HL,jump_table_040E] Jump table
	moveq	#0,d0
	move.b	game_state_43A4,d0              	| [$0403: LD      A,(game_state_43A4)] ??
	                          	| [$0406: RLCA] *2
	                          	| [$0407: ADD     A,L] Offset ...
	                         	| [$0408: LD      L,A] ... into the table
	                         	| [$0409: LD      A,(HL)] MSB of destination
	                         	| [$040a: INC     L] Get the
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),a0                         	| [$040b: LD      L,(HL)] ... LSB of destination
	                           	| [$040c: LD      H,A] Now point to function
	jra	(a0)                               	| [$040d: JP      (HL)] Jump to function

* Notice these addresses are MSB:LSB (backwards from the processors endianness)
jump_table_040E:
	.long	start_new_life_0430                  | STATE_START_NEW_LIFE = 0
	.long	init_new_play_clear_screen_04AC      | STATE_INIT_NEW_PLAY_CLEAR_SCREEN = 1
	.long	init_new_play_step_2_0515            | STATE_INIT_NEW_PLAY_STEP_2 = 2
	.long	game_playing_0800                    | STATE_GAME_PLAYING = 3
	.long	player_hit_0AEA                      | STATE_PLAYER_HIT = 4
	.long	player_turn_over_0B60                | STATE_PLAYER_TURN_OVER = 5
	.long	boss_stage_completed_2400            | STATE_BOSS_STAGE_COMPLETED = 6
	.long	end_of_level_transition_244C         | STATE_END_OF_LEVEL_TRANSITION = 7
* bpset 0406,(A==0)                     	|| (A==1)|| (A==2)|| (A==6)|| (A==7),{printf "%d",A;g}

* selects one of the two available palettes
* and select proper bank too according to player
set_proper_stage_palette_041E:
	move.b	current_player_is_p2_43A3,d0                 	| [$041e: LD      A,(current_player_is_p2_43A3)] seems to store memory bank bit with other things
	and.b	#0x01,d0                         	| [$0421: AND     $01]
	move.b	d0,d1                           	| [$0423: LD      B,A]
	move.b	current_stage_43B8,d0           	| [$0424: LD      A,(current_stage_43B8)]
	and.b	#0x02,d0                         	| [$0427: AND     $02]
	or.b	d1,d0                             	| [$0429: OR      B]
	jbsr	osd_write_5000                       	| [$042a: LD      ($5000),A] set memory bank & palette
	rts                                    	| [$042d: RET]


* initialize game or demo for current player
start_new_life_0430:
	move.b	#55,0x200
	
	lea	game_state_43A4,a0             	| [$0430: LD      HL,game_state_43A4] Next function to run ...
	move.b	#STATE_INIT_NEW_PLAY_CLEAR_SCREEN,(a0)+                      	| [$0433: LD      (HL),$01] ... is 1 ??
	                           	| [$0435: INC     L]
	move.b	#0x80,(a0)                      	| [$0436: LD      (HL),$80]
	lea	current_player_is_p2_43A3,a0            | [$0438: LD      L,$A3]
	move.b	(a0),d0                         	| [$043a: LD      A,(HL)]
	clr.b	(a0)                             	| [$043b: LD      (HL),$00]
	cmp.b	#0x02,d0                         	| [$043d: CP      $02]
	bne.b	0f                               	| [...]
	* it was 2 (undetermined?), now it's 0: first player
	rts                                    	| [$043f: RET     Z] [...]
0:
	* restore value in current_player_is_p2_43A3 if it was not 2 (can be 0 or 1)
	move.b	d0,(a0)                         	| [$0440: LD      (HL),A]
	                           	| [$0441: DEC     L]
	move.b	(-1,a0),d0                         	| [$0442: LD      A,(HL)] check game_in_play_43A2 for current player
	cmp.b	#0x01,d0                         	| [$0443: CP      $01]
	bne.b	0f                               	| [...]
	rts                                    	| [$0445: RET     Z] [...]
0:
											| [$0446: INC     L]
	move.b	(a0),d0                         	| [$0447: LD      A,(HL)]
	                               	| [$0448: AND     A]
	jeq	set_p2_as_current_player_04a0   | [$0449: JP      Z,$04A0] it was player 1, set player 2
	lea	nb_lives_p1_4390,a0                        	| [$044c: LD      L,$90]
	move.b	(a0),d0                         	| [$044e: LD      A,(HL)]
	                               	| [$044f: AND     A]
	bne.b	set_p1_as_current_player_0451     | player 1 still has lives, set player 1                	| [...]
	rts                                    	| [$0450: RET     Z] [...]
	
set_p1_as_current_player_0451:
	* we coming back from player 2, we're still with bank selector high (bank 1)
	lea	current_player_is_p2_43A3,a0                        	| [$0451: LD      L,$A3]
	clr.b	(a0)                             	| [$0453: LD      (HL),$00]
	* now we propagate state from current bank (bank 1) to bank 0.
	move.w	#0x0100,d1                      	| [$0455: LD      BC,$0100]
	jbsr	switch_to_other_bank_0460                    	| [$0458: CALL    switch_to_other_bank_0460]
	rts                                    	| [$045b: RET]



* Copy memory bank to bank and switch when switching players
* D1=from bank number, D2=to bank number
* used to swap player memory on 2P mode (never called on 1P mode)
* Starts at 4320
* it keeps in sync shared game state variables, preserving the player
* specific state (level, enemy status...) in the separate banks
* I've called that switch_to_other_bank_0460 just not "copy" because
* it also has a side effect: ends with current bank as value in D2
* so when called with $0100, in the end bank is 0


switch_to_other_bank_0460:
	* we decode from/to arg but we don't use source
	* as we know that source is CURRENT bank
	* we still need destination (d2) to switch to that bank
	LOAD_D1D2_FROM_D1_16
	* note that fg_videoram can contain bank 0 or 1 depending on
	* the mem swap that was done when calling osd_write_5000
	* the call is always done to sync from current bank to other bank
	* then bank is switched to other bank
	lea		fg_videoram,a0
	lea		bank_1,a1

	
* copy 4 bytes from 4320-4323, then 4300-4303 ... until reaching 42E0
* (video memory)
	
	                      	| [$0460: LD      HL,$5000] 50xx video register
    move.w	#0x320,d3      	| [$0463: LD      DE,unknown_4320]
          	| [$0463: LD      DE,unknown_4320]

l_0466:
	                         	| [$0466: LD      (HL),B]
	move.b	(a0,d3.w),d0                         	| [$0467: LD      A,(DE)]
	                         	| [$0468: LD      (HL),C]
	move.b	d0,(a1,d3.w)                         	| [$0469: LD      (DE),A]
	addq.b	#1,d3                           	| [$046a: INC     E]
	
	                           	| [$046b: LD      A,E]
	and.b	#0x03,d3                         	| [$046c: AND     $03]
	jne	l_0466                             	| [$046e: JP      NZ,$0466]

	                           	| [$0471: LD      A,E]
	and.b	#0xF0,d3                         	| [$0472: AND     $F0]
	sub.w	#0x20,d3                         	| [$0474: SUB     $20]
	                           	| [$0476: LD      E,A]
	                             	| [$0477: JP      NC,$0466]
      
	                           	| [$047a: DEC     D]
	                        	| [$047b: LD      A,D]
	
	                         	| [$047c: CP      $3F]
	jpl	l_0466                             	| [$047e: JP      NZ,$0466]

* then copies 4380 => 43B8 (player/game state)
	move.w	#0x380,d3                	| [$0481: LD      DE,player_scores_buffer_4380]
l_0484:
	                         	| [$0484: LD      (HL),B]
	move.b	(a0,d3.w),d0                         	| [$0485: LD      A,(DE)]
	                         	| [$0486: LD      (HL),C]
	move.b	d0,(a1,d3.w)                         	| [$0487: LD      (DE),A]
	addq.b	#1,d3                           	| [$0488: INC     E]
           
	                           	| [$0489: LD      A,E]
	cmp.b	#0xB8,d3                         	| [$048a: CP      $B8]
	jne	l_0484                             	| [$048c: JP      NZ,$0484]
*
* 4BC0 => 4C00 (stack area!) skip this!
*	lea	unknown_4BC0,a1                	| [$048f: LD      DE,unknown_4BC0]
*l_0492:
*	move.b	d1,(a0)                         	| [$0492: LD      (HL),B]
*	move.b	(a1),d0                         	| [$0493: LD      A,(DE)]
*	move.b	d2,(a0)                         	| [$0494: LD      (HL),C]
*	move.b	d0,(a1)                         	| [$0495: LD      (DE),A]
*	addq.w	#1,a1                           	| [$0496: INC     E]
*            
*	move.b	d4,d0                           	| [$0497: LD      A,E]
*	                               	| [$0498: CP      $00]
*	jne	l_0492                             	| [$049a: JP      NZ,$0492]


	jbsr	osd_swap_banks
	jbsr	osd_full_screen_redraw
	rts                                    	| [$049d: RET]



set_p2_as_current_player_04a0:
											| [$04a0: LD      L,$A3]
	move.b	#0x01,current_player_is_p2_43A3                      	| [$04a2: LD      (HL),$01]
	move.w	#0x0001,d1                      	| [$04a4: LD      BC,$0001] 1
	jbsr	switch_to_other_bank_0460                    	| [$04a7: CALL    switch_to_other_bank_0460]
	rts                                    	| [$04aa: RET]


	DECL_ADDRESS	4ac
	
* ?? Function 1
init_new_play_clear_screen_04AC:
	lea	timer_43A5,a0                  	| [$04ac: LD      HL,timer_43A5]
	subq.b	#1,(a0)                         	| [$04af: DEC     (HL)]
	move.b	(a0),d0                         	| [$04b0: LD      A,(HL)]
	                          	| [$04b1: DEC     L]
	move.b	#0x02,-(a0)                      	| [$04b2: LD      (HL),$02]
	tst.b	d0                               	| [$04b4: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$04b5: RET     Z] [...]
0:
	move.b	#0x01,(a0)                      	| [$04b6: LD      (HL),$01]
	cmp.b	#0x7F,d0                         	| [$04b8: CP      $7F]
	jeq	l_07f0                             	| [$04ba: JP      Z,$07F0]
	lea	counter_439A,a0                        	| [$04bd: LD      L,$9A]
	clr.w	(a0)                             	| [$04bf: LD      (HL),$00]
	                           	| [$04c1: INC     L]
 	                             	| [$04c2: LD      (HL),$00]
	and.b	#0x08,d0                         	| [$04c4: AND     $08]
	jne	l_04e6                             	| [$04c6: JP      NZ,$04E6]
	jbsr	l_06e8                            	| [$04c9: CALL    $06E8]
	* location of score depending on active player          	| [$04cc: NOP]
	lea	current_player_is_p2_43A3,a0                	| [$04cd: LD      HL,current_player_is_p2_43A3]
	move.w	#0x4261,d3                	| [$04d4: LD      DE,unknown_4261]
	tst.b	(a0)                         	| [$04d0: LD      A,(HL)]
	lea	player_2_score_end_4383,a0                        	| [$04d2: LD      L,$83]
	                               	| [$04d1: AND     A]
	jeq	l_04df                             	| [$04d7: JP      Z,$04DF]
	lea	player_score_end_4387,a0                        	| [$04da: LD      L,$87]
	move.w	#0x4021,d3                	| [$04dc: LD      DE,unknown_4021]
l_04df:
	* display player score
	move.b	#0x06,d1                        	| [$04df: LD      B,$06]
	jbsr	write_digits_to_screen_00c4                            	| [$04e1: CALL    $00C4]
	rts                                    	| [$04e4: RET]

l_04e6:
	lea	current_player_is_p2_43A3,a0                	| [$04e6: LD      HL,current_player_is_p2_43A3]
	move.w	#0x4261,d7                	| [$04eb: LD      DE,unknown_4261]
	move.b	(a0),d0                         	| [$04e9: LD      A,(HL)]
	                               	| [$04ea: AND     A]
	jeq	l_04f4                             	| [$04ee: JP      Z,$04F4]
	move.w	#0x4021,d7                	| [$04f1: LD      DE,unknown_4021]
l_04f4:
	move.b	#0x06,d1                        	| [$04f4: LD      B,$06]
	jbsr	clear_score_digits_04fb                            	| [$04f6: CALL    $04FB]
	rts                                   	| [$04f9: RET]
	
	DECL_ADDRESS	4fb
	
clear_score_digits_04fb:
	clr.b	d0                               	| [$04fb: LD      A,$00]
	jbsr	osd_w_videoram                         	| [$04fd: LD      (DE),A]
	add.w	#0x20,d7                    	| [$04fe: CALL    AddOneRow_0210] we work directly with D7 here
	subq.b	#1,d1                           	| [$0501: DEC     B]
	jne	clear_score_digits_04fb                             	| [$0502: JP      NZ,$04FB]
	rts                                    	| [$0505: RET]
l_0506:
	lea	unknown_4392,a0                	| [$0506: LD      HL,unknown_4392]
	move.b	#0x06,d1                        	| [$0509: LD      B,$06]
	jbsr	clear_area_05D8                   	| [$050b: CALL    clear_area_05D8]
	move.b	unknown_4B50,d0                 	| [$050e: LD      A,(unknown_4B50)]
	move.b	d0,unknown_4394                 	| [$0511: LD      (unknown_4394),A]
	rts                                    	| [$0514: RET]

* ?? Function 2
init_new_play_step_2_0515:
	jbsr	set_proper_stage_palette_041E     	| [$0515: CALL    set_proper_stage_palette_041E]
	lea	game_state_43A4,a0             	| [$0518: LD      HL,game_state_43A4]
	move.b	#STATE_GAME_PLAYING,(a0)                      	| [$051b: LD      (HL),$03] advance state machine to "playing"
	jbsr	init_scrolling_data_0580                            	| [$051d: CALL    $0580]
	jbsr	l_0547                            	| [$0520: CALL    $0547]
	jbsr	display_player_ship_and_shots_09a0                            	| [$0523: CALL    $09A0]
l_0526:
	jbsr	l_0532                            	| [$0526: CALL    $0532]
	jbsr	draw_birds_0a6c                            	| [$0529: CALL    $0A6C]
	jbsr	l_0506                            	| [$052c: CALL    $0506]
	jra	l_32b0                             	| [$052f: JP      $32B0]
*
l_0532:
	lea	unknown_4B50,a0                	| [$0532: LD      HL,unknown_4B50]
	move.b	#0xA0,d1                        	| [$0535: LD      B,$A0]
	jbsr	clear_area_05D8                   	| [$0537: CALL    clear_area_05D8]
	jbsr	l_05ec                            	| [$053a: CALL    $05EC]
	jbsr	l_0650                            	| [$053d: CALL    $0650]
	jbsr	l_0610                            	| [$0540: CALL    $0610]
	rts                                    	| [$0543: RET]



l_0547:
	lea	game_rom+0x0560,a0                      	| [$0547: LD      HL,$0560]
	lea	unknown_43C0,a1                	| [$054a: LD      DE,unknown_43C0]
	move.b	#0x20,d1                        	| [$054d: LD      B,$20]
	jbsr	copy_memory_05e0                            	| [$054f: CALL    $05E0]
	lea	unknown_43E0,a0                	| [$0552: LD      HL,unknown_43E0]
	move.b	#0x20,d1                        	| [$0555: LD      B,$20]
	jbra	clear_area_05D8                   	| [$0557: CALL    clear_area_05D8]
	                                    	| [$055a: RET]

init_scrolling_data_0580:
	lea		game_rom+0x598,a0
	subq.b	#1,d1                           	| [$0582: DEC     B] useless??
	move.b	current_stage_43B8,d0           	| [$0583: LD      A,(current_stage_43B8)]
	and.w	#0x0F,d0                         	| [$0586: AND     $0F]
	add.w	d0,a0                            	| [$0588: ADD     A,L]
	                           	| [$0589: LD      L,A]
	move.b	(a0),d6                         	| [$058a: LD      L,(HL)]
	move.b	#0x05,d5                        	| [$058b: LD      H,$05]
	jbsr	load_rom_in_a0_from_d5d6
	* scrolling parameters, depending on level
	lea	unknown_43AB,a1                	| [$058d: LD      DE,unknown_43AB]
	move.b	#0x0C,d1                        	| [$0590: LD      B,$0C]
	jbra	copy_memory_05e0                            	| [$0592: CALL    $05E0]
	                                    	| [$0595: RET]




* < HL: start address
* < B: number of bytes to clear
clear_area_05D8:
	clr.b	d0                               	| [$05d8: XOR     A]
l_05d9:
	move.b	d0,(a0)+                         	| [$05d9: LD      (HL),A]
								| [$05da: INC     HL]
	subq.b	#1,d1                           	| [$05db: DEC     B]
	jne	l_05d9                             	| [$05dc: JP      NZ,$05D9]

	rts                                    	| [$05df: RET]

* < A0: source address
* < A1: dest address
* < D1: number of bytes to copy

copy_memory_05e0:
	move.b	(a0)+,d0                         	| [$05e0: LD      A,(HL)]
	move.b	d0,(a1)+                         	| [$05e1: LD      (DE),A]
	                           	| [$05e2: INC     HL]
	                           	| [$05e3: INC     DE]
	subq.b	#1,d1                           	| [$05e4: DEC     B]
	jne	copy_memory_05e0                             	| [$05e5: JP      NZ,$05E0]
	rts                                    	| [$05e8: RET]

l_05ec:
	lea	game_rom+0x1500,a0                      	| [$05ec: LD      HL,$1500]
	move.b	current_stage_43B8,d0           	| [$05ef: LD      A,(current_stage_43B8)]
	and.w	#0x0F,d0                         	| [$05f2: AND     $0F]
	rol.b	#1,d0                            	| [$05f4: RLCA]
	add.w	d0,a0                            	| [$05f5: ADD     A,L]
	                           	| [$05f6: LD      L,A]
	move.b	(a0)+,d3                         	| [$05f7: LD      D,(HL)]
	                           	| [$05f8: INC     HL]
	move.b	(a0),d4                         	| [$05f9: LD      E,(HL)]
set_birds_params_05fa:
	lea	bird_data_4B70,a0                	| [$05fa: LD      HL,bird_data_4B70]
	move.b	nb_birds_to_kill_before_stage_completed_43BA,d0	| [$05fd: LD      A,(nb_birds_to_kill_before_stage_completed_43BA)]
	move.b	d0,d1                           	| [$0600: LD      B,A]
												| [$0601: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$0602: RET     Z] [...]
0:
l_0603:
	move.b	d3,(a0)+                         	| [$0603: LD      (HL),D]
	                           	| [$0604: INC     L]
	move.b	d4,(a0)                         	| [$0605: LD      (HL),E]
	addq.w	#3,a0                           	| [$0606: INC     L] * 3
	subq.b	#1,d1                           	| [$0609: DEC     B]
	jne	l_0603                             	| [$060a: JP      NZ,$0603]
	rts                                    	| [$060d: RET]

l_0610:
	lea	game_rom+0x063A,a0                      	| [$0610: LD      HL,$063A]
	move.b	current_stage_43B8,d0           	| [$0613: LD      A,(current_stage_43B8)]
	ror.b	#1,d0                            	| [$0616: RRCA]
	and.w	#0x0F,d0                         	| [$0617: AND     $0F]
	add.w	d0,a0                            	| [$0619: ADD     A,L]
	                           	| [$061a: LD      L,A]
	                                    	| [$061b: NOP]
	                                    	| [$061c: NOP]
	                                    	| [$061d: NOP]
	move.b	(a0),d6                         	| [$061e: LD      L,(HL)]
	move.b	#0x15,d5                        	| [$061f: LD      H,$15] rom $15xx
	bsr		load_rom_in_a0_from_d5d6
	lea	unknown_4B72,a1                	| [$0621: LD      DE,unknown_4B72]
	move.b	nb_birds_to_kill_before_stage_completed_43BA,d0	| [$0624: LD      A,(nb_birds_to_kill_before_stage_completed_43BA)]
	move.b	d0,d1                           	| [$0627: LD      B,A]
												| [$0628: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$0629: RET     Z] [...]
0:
l_062a:
	move.b	(a0)+,(a1)+                         	| [$062a: LD      A,(HL)]
	                         	| [$062b: LD      (DE),A]
	                           	| [$062c: INC     HL]
	                           	| [$062d: INC     DE]
	move.b	(a0)+,(a1)                         	| [$062e: LD      A,(HL)]
	                         	| [$062f: LD      (DE),A]
	                           	| [$0630: INC     HL]
	addq.w	#3,a1                           	| [$0631: INC     DE] * 3
	subq.b	#1,d1                           	| [$0634: DEC     B]
	jne	l_062a                             	| [$0635: JP      NZ,$062A]
	rts                                    	| [$0638: RET]

l_0650:
	lea	game_rom+0x1520,a0                      	| [$0650: LD      HL,$1520]
	move.b	current_stage_43B8,d0           	| [$0653: LD      A,(current_stage_43B8)]
	and.w	#0x0F,d0                         	| [$0656: AND     $0F]
	rol.b	#1,d0                            	| [$0658: RLCA]
	add.w	d0,a0                            	| [$0659: ADD     A,L]
	                           	| [$065a: LD      L,A]
	move.b	(a0)+,d3                         	| [$065b: LD      D,(HL)]
											| [$065c: INC     HL]
	move.b	(a0),d4                         	| [$065d: LD      E,(HL)]
	lea	unknown_4B50,a0                	| [$065e: LD      HL,unknown_4B50]
	move.b	nb_birds_to_kill_before_stage_completed_43BA,d0	| [$0661: LD      A,(nb_birds_to_kill_before_stage_completed_43BA)]
	move.b	d0,d1                           	| [$0664: LD      B,A]
												| [$0665: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$0666: RET     Z] [...]
0:
l_0667:
	move.b	d3,(a0)+                         	| [$0667: LD      (HL),D]
	                           	| [$0668: INC     L]
	move.b	d4,(a0)+                         	| [$0669: LD      (HL),E]
	                           	| [$066a: INC     L]
	subq.b	#1,d1                           	| [$066b: DEC     B]
	jne	l_0667                             	| [$066c: JP      NZ,$0667]
	rts                                    	| [$066f: RET]


	DECL_ADDRESS	067a

update_scrolling_067A:
	lea	current_scroll_value_43B9,a0   	| [$067a: LD      HL,current_scroll_value_43B9]
	move.b	(a0),d0                         	| [$067d: LD      A,(HL)]
	subq.b	#1,(a0)                         	| [$067e: DEC     (HL)] decrease scroll value
	jbsr	osd_set_scroll_value                       	| [$067f: LD      ($5800),A] 58xx scroll register, change scroll value
	and.b	#0x07,d0                         	| [$0682: AND     $07]
	beq.b	0f                               	| [...]
	rts                                    	| [$0684: RET     NZ] [...]
0:
* if 8 pixels were scrolled, then feed scroll
* by updating a character row
	move.w	#0x20,d1
									| [$0685: LD      BC,$2047] 0x20 in B for next char, 0x47 in C for 0x47xx limit
	move.w	#0x4B21,d7                	| [$0688: LD      DE,unknown_4B21] screen address (background tiles)
	move.b	(a0),d0                         	| [$068b: LD      A,(HL)] scroll value
	lsr.b	#3,d0                            	| [$068c: RRCA] * 3 divided by 8
												| [$068f: AND     $1F] masked
												| [$0691: ADD     A,E]
	add.b	d0,d7                           	| [$0692: LD      E,A]
	lea	current_background_rom_data_pointer_43B2,a0                        	| [$0693: LD      L,$B2]
	move.b	(a0)+,d5                         	| [$0695: LD      A,(HL)]
                           	| [$0696: INC     L]
	move.b	(a0),d6                         	| [$0697: LD      L,(HL)]
	                           	| [$0698: LD      H,A]
	bsr		load_rom_in_a0_from_d5d6
l_0699:
	move.b	(a0)+,d0                         	| [$0699: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$069a: LD      (DE),A]
	addq.b	#1,d6								| [$069b: INC     L] we need to follow a0/d6
	bne.b	0f
	* if wraps, then sub 0x100 to A0 to emulate that
	sub.w	#0x100,a0
0:
	                           	| [$069c: LD      A,E]
	sub.w	d1,d7                            	| [$069d: SUB     B] prev column
	                           	| [$069e: LD      E,A]
									| [$069f: JP      NC,$0699]
										| [$06a2: DEC     D]
	cmp.w	#0x4800,d7                           	| [$06a3: LD      A,D]
	
											| [$06a4: CP      C]
	jcc	l_0699                             	| [$06a5: JP      NZ,$0699]
	* update the pointer LSB for next time                           	| [$06a8: LD      A,L]
	move.b	d6,current_background_rom_data_pointer_43B2+1                 	| [$06a9: LD      (unknown_43B3),A]
	rts                                    	| [$06ac: RET]

	DECL_ADDRESS	06b0
	
l_06b0:
	lea	unknown_43AB,a0                	| [$06b0: LD      HL,unknown_43AB]
	move.b	current_scroll_value_43B9,d0    	| [$06b3: LD      A,(current_scroll_value_43B9)]
	move.b	d0,d2                           	| [$06b6: LD      C,A]
	cmp.b	(a0),d0                          	| [$06b7: CP      (HL)]
	beq.b	0f                               	| [...]
	rts                                    	| [$06b8: RET     NZ] [...]
0:
	move.b	(a0)+,d0                         	| [$06b9: LD      A,(HL)]
	                           	| [$06ba: INC     L]
	add.b	(a0),d0                          	| [$06bb: ADD     A,(HL)]
	                           	| [$06bc: DEC     L]
	move.b	d0,-(a0)                         	| [$06bd: LD      (HL),A]
	addq.w	#2,a0                           	| [$06be: INC     L]*2
 	addq.b	#1,(a0)                         	| [$06c0: INC     (HL)]
	move.b	(a0)+,d1                         	| [$06c1: LD      B,(HL)]
	                           	| [$06c2: INC     L]
 	addq.b	#1,(a0)                         	| [$06c3: INC     (HL)]
	move.b	(a0),d0                         	| [$06c4: LD      A,(HL)]
	lea	game_rom+0x1E20,a0                      	| [$06c5: LD      HL,$1E20]
	and.w	#0x1F,d0                         	| [$06c8: AND     $1F]
	add.w	d0,a0                            	| [$06ca: ADD     A,L]
											| [$06cb: LD      L,A]
	move.b	(a0),d3                         	| [$06cc: LD      D,(HL)]
	add.w	#0x20,a0                         	| [$06cd: ADD     $20]
	                           	| [$06cf: LD      L,A]
	move.b	(a0),d4                         	| [$06d0: LD      E,(HL)]
	move.b	d2,d0                           	| [$06d1: LD      A,C]
	ror.b	#3,d0                            	| [$06d2: RRCA] * 3
	and.b	#0x1E,d0                         	| [$06d5: AND     $1E]
	add.b	d4,d0                            	| [$06d7: ADD     A,E]
	addq.b	#0x02,d0                        	| [$06d8: ADD     $02]
	move.b	d0,d4                           	| [$06da: LD      E,A]
	lea	game_rom+0x1E60,a0                      	| [$06db: LD      HL,$1E60]
	move.b	d1,d0                           	| [$06de: LD      A,B]
	and.b	#0x1F,d0                         	| [$06df: AND     $1F]
	add.w	d0,a0                            	| [$06e1: ADD     A,L]
	                           	| [$06e2: LD      L,A]
	moveq	#0,d6
	move.b	(a0),d6                         	| [$06e3: LD      L,(HL)]
	lea	game_rom+0x1E00,a0
	add.w	d6,a0
	jbra	write_2x2_chars_07dc                            	| [$06e4: CALL    $07DC]
	                                    	| [$06e7: RET]
	
	
l_06e8:
	lea	game_rom+0x1800,a0                      	| [$06e8: LD      HL,$1800]
	move.b	#0x01,d2                        	| [$06eb: LD      C,$01]
	jra	draw_game_status_01d0                             	| [$06ed: JP      $01D0]

l_06f0:
	jbsr	update_scrolling_067A             	| [$06f0: CALL    update_scrolling_067A]
	jbsr	l_2040                            	| [$06f3: CALL    $2040]
	jra	l_06b0                             	| [$06f6: JP      $06B0]


display_player_ship_and_shots_0700:
	lea	unknown_43C0,a4                	| [$0700: LD      BC,unknown_43C0]
	lea	unknown_43E0,a1                	| [$0703: LD      DE,unknown_43E0]
l_0706:
	jbsr	do_game_selected_routines_0718                            	| [$0706: CALL    $0718]
	                           	| [$0709: LD      A,C]
	addq.w	#0x04,a4                        	| [$070a: ADD     $04]
	                           	| [$070c: LD      C,A]
	* sync A1 with A4
	lea		(0x20,a4),a1                         	| [$070d: ADD     $20]
												| [$070f: LD      E,A]
											| [$0710: LD      D,B]
	cmp.l	#unknown_43E0+0xC,a1                         	| [$0711: CP      $EC]
	jne	l_0706                             	| [$0713: JP      NZ,$0706]
	rts                                    	| [$0716: RET]
	                                    	| [$0717: RET]
do_game_selected_routines_0718:
	jbsr	select_game_jump_routine_0720                            	| [$0718: CALL    $0720]
	jra	select_game_jump_routine_0740                             	| [$071b: JP      $0740]


select_game_jump_routine_0720:
	move.b	(a4),d0                         	| [$0720: LD      A,(BC)]
	move.b	d0,d5                           	| [$0721: LD      H,A]
	and.b	#0x10,d0                         	| [$0722: AND     $10]
	bne.b	0f                               	| [...]
	rts                                    	| [$0724: RET     Z] [...]
0:
	move.b	d5,d0                           	| [$0725: LD      A,H]
	and.b	#0xEF,d0                         	| [$0726: AND     $EF]
	move.b	d0,(a4)                         	| [$0728: LD      (BC),A]
	rol.b	#3,d0                            	| [$0729: RLCA] A rotated 3 times * 3
* select one address out of 8 in table from $738
* some slots are illegal and aren't reached (else game reboots)
* allowed states are 0,1,3,4 only
	and.w	#0x07,d0                         	| [$072c: AND     $07]
	                         	| [$072e: ADD     $38] table from $738
	                        	| [$0730: LD      L,A]
	                        	| [$0731: LD      H,$07]
	                        	| [$0733: LD      L,(HL)]
	add.w	d0,d0
	add.w	d0,d0
	lea		jump_table_0738(pc),a0
	move.l	(a0,d0.w),d7
	.ifndef		RELEASE
	bpl.b	0f
	lsr.w	#2,d0
	sub.l	#fg_videoram_4000,a4
	lea		invalid_jump_table_index_error,a1
	jbsr	osd_break
	ILLEGAL
0:
	.endif
	move.l	d7,a0
* jump from jump table to $07xx
	jra	(a0)                               	| [$0734: JP      (HL)]

	DECL_ADDRESS	738
	
jump_table_0738:
	.long	erase_shots_0763       | $763
	.long	erase_remaining_char_0779       | $779
	.long	-1          |
	.long	erase_attacking_birds_079E       | $79E
	.long	erase_remaining_char_07BE       | $7BE
	.long	-1       
	.long	-1       
	.long	-1       

	DECL_ADDRESS	740
* < A1:
* < A4;
select_game_jump_routine_0740:
	move.b	(a4),d0                         	| [$0740: LD      A,(BC)]
	move.b	d0,d5                           	| [$0741: LD      H,A]
	and.b	#0x08,d0                         	| [$0742: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$0744: RET     Z] [...]
0:
	move.b	d5,d0                           	| [$0745: LD      A,H]
	and.b	#0x07,d0                         	| [$0746: AND     $07]
	move.b	d0,d5                           	| [$0748: LD      H,A]
	ror.b	#3,d0                            	| [$0749: RRCA] * 3
	or.b	d5,d0                             	| [$074c: OR      H]
	or.b	#0x18,d0                          	| [$074d: OR      $18]
	move.b	d0,(a4)+                         	| [$074f: LD      (BC),A]
	                           	| [$0750: INC     BC]
	move.b	d5,d0                           	| [$0751: LD      A,H]
	                         	| [$0752: ADD     $5B] table from $75B
* some slots are illegal and aren't reached (else game reboots)
* allowed states are 0,1,3,4 only
	and.w	#0xFF,d0
	add.w	d0,d0
	add.w	d0,d0
	lea		jump_table_075B(pc),a0
	                       	| [$0754: LD      L,A]
	                       	| [$0755: LD      H,$07]
	move.l	(a0,d0.w),d7
	.ifndef		RELEASE
	bpl.b	0f
	lsr.w	#2,d0
	sub.l	#fg_videoram_4000,a4
	lea		invalid_jump_table_index_error,a1
	jbsr	osd_break
	ILLEGAL
	ILLEGAL
	ILLEGAL
0:
	.endif
	move.l	d7,a0                         	| [$0757: LD      L,(HL)]
* jump from jump table to $07xx
	jra	(a0)                               	| [$0758: JP      (HL)]

jump_table_075B:
	.long	animate_appearing_birds_076d      | $76D
	.long	animate_bird_in_swarm_0788      | $788
	.long	0xFF        |
	.long	display_attacking_birds_07AA      | $7AA
	.long	display_attacking_bird_07D2      | $7D2  ????
	.long	0XFF      
	.long	0XFF      
	.long	0XFF      

	DECL_ADDRESS	763
	
erase_shots_0763:
	exg	a1,a0                              	| [$0763: EX      DE,HL]
	move.b	(a0),d3                         	| [$0764: LD      D,(HL)]
	                           	| [$0765: INC     HL]
	move.b	(1,a0),d4                         	| [$0766: LD      E,(HL)]
	                           	| [$0767: DEC     HL]
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d7
	clr.b	d0                               	| [$0768: XOR     A]
	jbsr	osd_w_videoram                         	| [$0769: LD      (DE),A]
	exg	a1,a0                              	| [$076a: EX      DE,HL]
	rts                                    	| [$076b: RET]

	DECL_ADDRESS	76D
* a bird appears from the void
* < A1: contains screen address to plot to
* < A4: points on character to be plotted
* ex: first level first call writes 6C to DE=41A9 from BC=4B71
*
* also used to display enemy shots
*
animate_appearing_birds_076d:
	exg	a1,a0                              	| [$076d: EX      DE,HL]
	addq.w	#2,a0                           	| [$076e: INC     HL] * 2
	move.b	(a0)+,d3                         	| [$0770: LD      D,(HL)]
	                           	| [$0771: INC     HL]
	move.b	(a0),d4                         	| [$0772: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d7
	move.b	(a4),d0                         	| [$0773: LD      A,(BC)]
	jbsr	osd_w_videoram                         	| [$0774: LD      (DE),A]
	subq.w	#1,a4                           	| [$0775: DEC     BC]
	rts                                    	| [$0776: RET]
	

                       	| [$0777: LD      (DE),A]
                       	| [$0778: INC     HL]
						
	DECL_ADDRESS	779	
	
* remove remaining character of bird/ship when needed (not all the time)
* (this is optimized to avoid erasing when it's not needed)
erase_remaining_char_0779:
	exg	a1,a0                              	| [$0779: EX      DE,HL]
	move.b	(a0),d3                         	| [$077a: LD      D,(HL)]
	                           	| [$077b: INC     HL]
	move.b	(1,a0),d4                         	| [$077c: LD      E,(HL)]
	                           	| [$077d: DEC     HL]
	LOAD_D3_16_FROM_D3D4
	clr.b	d0                               	| [$077e: XOR     A]
	exg		d3,d7                         	| [$077f: LD      (DE),A]
	jbsr	osd_w_videoram
	sub.w	#0x20,d7               	| [$0780: CALL    SubtractOneRow_0217]
	cmp.w	#0x4000,d7
	bcs.b	0f					| can try to write in ROM
	clr.b	d0                               	| [$0783: XOR     A]
	jbsr	osd_w_videoram                         	| [$0784: LD      (DE),A]
0:
	exg	a1,a0                              	| [$0785: EX      DE,HL]
	rts                                    	| [$0786: RET]
	
	DECL_ADDRESS	788

	                           	| [$0787: INC     HL]
animate_bird_in_swarm_0788:
	exg	a1,a0                              	| [$0788: EX      DE,HL]
	addq.w	#2,a0                           	| [$0789: INC     HL] * 2
	move.b	(a0)+,d3                         	| [$078b: LD      D,(HL)]
	                           	| [$078c: INC     HL]
	move.b	(a0),d4                         	| [$078d: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d7
	move.b	(a4),d0                         	| [$078e: LD      A,(BC)]
	move.b	d0,d6                           	| [$078f: LD      L,A]
	move.b	#0x14,d5                        	| [$0790: LD      H,$14]
	jbsr	load_rom_in_a0_from_d5d6
	move.b	(a0)+,d0                         	| [$0792: LD      A,(HL)]
	cmp.w	#0x4000,d7
	bcs.b	0f
	* in the real game, ROM write to address 8 can happen there
	jbsr	osd_w_videoram                         	| [$0793: LD      (DE),A]
	                           	| [$0794: INC     HL]
	sub.w	#0x20,d7               	| [$0795: CALL    SubtractOneRow_0217]
	move.b	(a0),d0                         	| [$0798: LD      A,(HL)]
	* in the real game, ROM write can happen there
	cmp.w	#0x4000,d7
	bcs.b	0f
	jbsr	osd_w_videoram                         	| [$0799: LD      (DE),A]
0:
	subq.w	#1,a4                           	| [$079a: DEC     BC]
	rts                                    	| [$079b: RET]

	DECL_ADDRESS	79e
	                              	| [$079d: EX      DE,HL]
erase_attacking_birds_079E:
	exg	a1,a0                              	| [$079e: EX      DE,HL]
	move.b	(a0),d3                         	| [$079f: LD      D,(HL)]
	                           	| [$07a0: INC     HL]
	move.b	(1,a0),d4                         	| [$07a1: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	                           	| [$07a2: DEC     HL]
	clr.b	d0                               	| [$07a3: XOR     A]
	move.w	d3,d7
	jbsr	osd_w_videoram                         	| [$07a4: LD      (DE),A]
	addq.w	#1,d7                           	| [$07a5: INC     DE]
	jbsr	osd_w_videoram                         	| [$07a6: LD      (DE),A]
	exg	a1,a0                              	| [$07a7: EX      DE,HL]
	rts                                    	| [$07a8: RET]
	
	DECL_ADDRESS	7aa

display_attacking_birds_07AA:
	exg	a1,a0                              	| [$07aa: EX      DE,HL]
	addq.w	#2,a0                           	| [$07ab: INC     HL] * 2
	move.b	(a0)+,d3                         	| [$07ad: LD      D,(HL)]
	                           	| [$07ae: INC     HL]
	move.b	(a0),d4                         	| [$07af: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	move.b	(a4),d6                         	| [$07b0: LD      A,(BC)]
											| [$07b1: LD      L,A]
	move.b	#0x14,d5                        	| [$07b2: LD      H,$14]
	jbsr	load_rom_in_a0_from_d5d6
	move.w	d3,d7
	move.b	(a0)+,d0                         	| [$07b4: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$07b5: LD      (DE),A]
	                           	| [$07b6: INC     HL]
	addq.w	#1,d7                           	| [$07b7: INC     DE]
	move.b	(a0),d0                         	| [$07b8: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$07b9: LD      (DE),A]
	subq.w	#1,a4                           	| [$07ba: DEC     BC]
	rts                                    	| [$07bb: RET]
	
	
	                           	| [$07bc: INC     HL]
	                           	| [$07bd: INC     DE]
* erase char for bird & ship
erase_remaining_char_07BE:
	exg	a1,a0                              	| [$07be: EX      DE,HL]
	move.b	(a0),d3                         	| [$07bf: LD      D,(HL)]
	                           	| [$07c0: INC     HL]
	move.b	(1,a0),d4                         	| [$07c1: LD      E,(HL)]
	                           	| [$07c2: DEC     HL]
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d7
	clr.b	d0                               	| [$07c3: XOR     A]
	jbsr	osd_w_videoram                         	| [$07c4: LD      (DE),A]
	addq.w	#1,d7                           	| [$07c5: INC     DE]
	jbsr	osd_w_videoram                         	| [$07c6: LD      (DE),A]
	sub.w	#0x20,d7               	| [$07c7: CALL    SubtractOneRow_0217]
	clr.b	d0                               	| [$07ca: XOR     A]
	jbsr	osd_w_videoram                         	| [$07cb: LD      (DE),A]
	subq.w	#1,d7                           	| [$07cc: DEC     DE]
	jbsr	osd_w_videoram                         	| [$07cd: LD      (DE),A]
	exg	a1,a0                              	| [$07ce: EX      DE,HL]
	rts                                    	| [$07cf: RET]


display_attacking_bird_07D2: 
	exg	a1,a0
	addq.w	#2,a0                           	| [$07d3: INC     HL] * 2
	move.b	(a0)+,d3                         	| [$07d5: LD      D,(HL)]
												| [$07d6: INC     HL]
	move.b	(a0),d4                         	| [$07d7: LD      E,(HL)]
	move.b	(a4),d0                         	| [$07d8: LD      A,(BC)]
	move.b	d0,d6                           	| [$07d9: LD      L,A]
	move.b	#0x14,d5                        	| [$07da: LD      H,$14] ROM lsb 0x14xx
	bsr		load_rom_in_a0_from_d5d6
	* also used when updating scrolling
write_2x2_chars_07dc:
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d7
	move.b	(a0)+,d0                         	| [$07dc: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$07dd: LD      (DE),A]
	                           	| [$07de: INC     HL]
	addq.w	#1,d7                           	| [$07df: INC     DE]
	move.b	(a0)+,d0                         	| [$07e0: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$07e1: LD      (DE),A]
	                           	| [$07e2: INC     HL]
	                           	| [$07e3: DEC     DE]
	sub.w	#0x21,d7               	| [$07e4: CALL    SubtractOneRow_0217]
	
	move.b	(a0)+,d0                         	| [$07e7: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$07e8: LD      (DE),A]
	                           	| [$07e9: INC     HL]
	addq.w	#1,d7                           	| [$07ea: INC     DE]
	move.b	(a0),d0                         	| [$07eb: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$07ec: LD      (DE),A]
0:
	subq.w	#1,a4                           	| [$07ed: DEC     BC]
	rts                                    	| [$07ee: RET]

	DECL_ADDRESS	7f0
	
l_07f0:
	move.b	current_scroll_value_43B9,d0    	| [$07f0: LD      A,(current_scroll_value_43B9)]
	jbsr	osd_set_scroll_value                       	| [$07f3: LD      ($5800),A] 58xx scroll register
	jbsr	clear_foreground_tiles_0380                            	| [$07f6: CALL    $0380]
	jra	set_proper_stage_palette_041E      	| [$07f9: JP      set_proper_stage_palette_041E]


	DECL_ADDRESS	800

game_playing_0800:
	lea	jump_table_0814,a0             	| [$0800: LD      HL,jump_table_0814]
	move.b	current_stage_43B8,d0           	| [$0803: LD      A,(current_stage_43B8)]
	rol.b	#1,d0                            	| [$0806: RLCA]
	and.w	#0x1E,d0                         	| [$0807: AND     $1E]
	
	add.w	d0,d0
	move.l	(a0,d0.w),a0
	                 	| [$0809: ADD     A,L]
	                	| [$080a: LD      L,A]
	                	| [$080b: LD      A,(HL)]
	                	| [$080c: INC     L]
   
	                       	| [$080d: LD      L,(HL)]
	                       	| [$080e: LD      H,A]
	jra	(a0)                               	| [$080f: JP      (HL)]

jump_table_0814:
	.long	transition_to_birds_level_0834
	.long	birds_level_2000
	.long	transition_to_birds_level_0834
	.long	birds_level_2000
	.long	transition_to_vultures_and_last_level_2230
	.long	vultures_level_3400
	.long	transition_to_vultures_and_last_level_2230
	.long	vultures_level_3400
	.long	transition_to_vultures_and_last_level_2230
	.long	mothership_arrives_22B4
	.long	mothership_level_22CA
	.long	birds_level_2000
	* seems difficult to reach!
	.long	l_224c
	.long	l_224c
	.long	l_224c
	.long	l_224c

* scrolls & shows next birds level
transition_to_birds_level_0834:
	jbsr	l_06f0                            	| [$0834: CALL    $06F0]
	lea	unknown_43B4,a0                	| [$0837: LD      HL,unknown_43B4]
	subq.b	#1,(a0)                         	| [$083a: DEC     (HL)]
	move.b	(a0),d0                         	| [$083b: LD      A,(HL)]
	cmp.b	#0x15,d0                         	| [$083c: CP      $15]
	bcs.b	0f                               	| [...]
	rts                                    	| [$083e: RET     NC] [...]
0:
	jbsr	select_birds_params_depending_on_phase_085a       	| [$083f: CALL    $085A]
	jbsr	set_birds_params_05fa                            	| [$0842: CALL    $05FA]
	jbsr	birds_stuff_0a50                            	| [$0845: CALL    $0A50]
l_0848:
	lea	unknown_43B4,a0                	| [$0848: LD      HL,unknown_43B4]
	move.b	(a0),d0                         	| [$084b: LD      A,(HL)]
	                               	| [$084c: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$084d: RET     NZ] [...]
0:
	lea	current_stage_43B8,a0                        	| [$084e: LD      L,$B8]
	addq.b	#1,(a0)                         	| [$0850: INC     (HL)] next stage
	lea	game_state_43A4,a0                        	| [$0851: LD      L,$A4]
	move.b	#STATE_INIT_NEW_PLAY_STEP_2,(a0)                      	| [$0853: LD      (HL),$02]
	rts                                    	| [$0855: RET]

	DECL_ADDRESS	85a

* > D4: bird starting char
* > D0: ?
* > D3: ?
select_birds_params_depending_on_phase_085a:
	move.b	#8,d3                      	| [$085a: LD      DE,$086C]
	move.b	#0x6C,d4                      	| [$085a: LD      DE,$086C]
	cmp.b	#0x11,d0                         	| [$085d: CP      $11]
	bcs.b	0f                               	| [...]
	rts                                    	| [$085f: RET     NC] [...]
0:
	move.b	#0x6D,d4                        	| [$0860: LD      E,$6D]
	cmp.b	#0x0D,d0                         	| [$0862: CP      $0D]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0864: RET     NC] [...]
0:
	move.b	#0x6E,d4                        	| [$0865: LD      E,$6E]
	cmp.b	#0x09,d0                         	| [$0867: CP      $09]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0869: RET     NC] [...]
0:
	move.b	#0x6F,d4                        	| [$086a: LD      E,$6F]
	cmp.b	#0x05,d0                         	| [$086c: CP      $05]
	bcs.b	0f                               	| [...]
	rts                                    	| [$086e: RET     NC] [...]
0:
	move.b	#0x68,d4                        	| [$086f: LD      E,$68]
	rts                                    	| [$0871: RET]


* handle player ship and enemy shots, shared between birds and
* vultures levels

common_game_routines_0876:
	jbsr	display_player_ship_and_shots_0700                            	| [$0876: CALL    $0700]
	jbsr	erase_player_shots_0886                            	| [$0879: CALL    $0886]
	jbsr	handle_player_shots_08a0                            	| [$087c: CALL    $08A0]
	jbsr	display_player_ship_and_shots_09a0                            	| [$087f: CALL    $09A0]
	jbsr	compute_player_ship_boundaries_097a                            	| [$0882: CALL    $097A]
	rts                                    	| [$0885: RET]
	
	DECL_ADDRESS	886

* copies byte pairs 2 bytes below
erase_player_shots_0886:
	lea	unknown_43EB,a0                	| [$0886: LD      HL,unknown_43EB]
	move.b	#0x03,d1                        	| [$0889: LD      B,$03]
l_088b:
	move.b	(a0),d3                         	| [$088b: LD      D,(HL)]
										| [$088c: DEC     HL]
	move.b	-(a0),d4                         	| [$088d: LD      E,(HL)]
	                           	| [$088e: DEC     HL]
	move.b	d3,-(a0)                         	| [$088f: LD      (HL),D]
	                           	| [$0890: DEC     HL]
	move.b	d4,-(a0)                         	| [$0891: LD      (HL),E]
	subq.w	#1,a0                           	| [$0892: DEC     HL]
	subq.b	#1,d1                           	| [$0893: DEC     B]
	jne	l_088b                             	| [$0894: JP      NZ,$088B]
	rts                                    	| [$0897: RET]
	
handle_player_shots_08a0:
	jbsr	handle_player_controls_08c4                            	| [$08a0: CALL    $08C4]
	lea	player_shot_1_structure_43C4,a0	| [$08a3: LD      HL,player_shot_1_structure_43C4]
	jbsr	handle_player_shot_0930                            	| [$08a6: CALL    $0930]
	move.b	current_stage_43B8,d0           	| [$08a9: LD      A,(current_stage_43B8)]
	and.b	#0x0F,d0                         	| [$08ac: AND     $0F]
	cmp.b	#0x03,d0                         	| [$08ae: CP      $03]
	beq.b	0f                               	| [...]
	* nop to get 2 bullets all the time [...], but this isn't as easier like this
	* as vulture stage only checks first bullet
	rts                                    	| [$08b0: RET     NZ]
0:
	lea	player_shot_2_structure_43C8,a0	| [$08b1: LD      HL,player_shot_2_structure_43C8]
	jbsr	handle_player_shot_0930                            	| [$08b4: CALL    $0930]
	rts                                    	| [$08b7: RET]

	DECL_ADDRESS	8c4

handle_player_controls_08c4:
	lea	unknown_43C0,a0                	| [$08c4: LD      HL,unknown_43C0]
	move.b	(a0),d0                         	| [$08c7: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$08c8: AND     $08]
	jeq	l_0aa0                             	| [$08ca: JP      Z,$0AA0]
	lea	shield_timer_43A6,a0                        	| [$08cd: LD      L,$A6]
	move.b	(a0),d0                         	| [$08cf: LD      A,(HL)]
	                               	| [$08d0: AND     A]
	jne	l_08ea                             	| [$08d1: JP      NZ,$08EA] can't enable shield: timer already running
	move.b	#0x80,d1                        	| [$08d4: LD      B,$80]
	jbsr	check_input_bits_00bb                    	| [$08d6: CALL    check_input_bits_00bb]
	jeq	l_08eb                             	| [$08d9: JP      Z,$08EB]
	* shield requested (button 2)
	lea	unknown_4362,a0                        	| [$08dc: LD      L,$62]
	move.b	#0x40,(a0)                      	| [$08de: LD      (HL),$40]
	lea	unknown_43C0,a0                        	| [$08e0: LD      L,$C0]
	move.b	(a0),d0                         	| [$08e2: LD      A,(HL)]
	and.b	#0xF7,d0                         	| [$08e3: AND     $F7]
	move.b	d0,(a0)                         	| [$08e5: LD      (HL),A]
	move.w	#SHIELD_SND,d0
	jbsr	osd_sound_start
	lea	shield_timer_43A6,a0                        	| [$08e6: LD      L,$A6]
	st.b	(a0)                      	| [$08e8: LD      (HL),$FF] enable shield
l_08ea:
	subq.b	#1,(a0)                         	| [$08ea: DEC     (HL)]
l_08eb:
	lea	player_ship_x_43C2,a0                        	| [$08eb: LD      L,$C2]
	jbsr	read_controls_to_move_ship_0900   	| [$08ed: CALL    read_controls_to_move_ship_0900]
	lea	game_rom+0x1600,a4                      	| [$08f0: LD      BC,$1600]
	jra	l_0926                             	| [$08f3: JP      $0926]

	DECL_ADDRESS	900
	
read_controls_to_move_ship_0900:
	move.b	current_input_value_43A0,d0                   	| [$0900: LD      A,(current_input_value_43A0)]
	not.b	d0                               	| [$0903: CPL] inverted logic
	and.b	#0x60,d0                         	| [$0904: AND     $60]
	bne.b	0f                               	| [...] a bit is set, test it
	rts                                    	| [$0906: RET     Z] [...]
0:
	and.b	#0x40,d0                         	| [$0907: AND     $40]
	jeq	player_move_right_requested_0917                             	| [$0909: JP      Z,$0917]
	move.b	(a0),d0                         	| [$090c: LD      A,(HL)]
	cmp.b	#0x0D,d0                         	| [$090d: CP      $0D]
	bcc.b	0f                               	| [...]
	rts                                    	| [$090f: RET     C] [...]
0:
	* move to left
	subq.b	#1,(a0)                         	| [$0910: DEC     (HL)]
	st.b	d0                                	| [$0911: LD      A,$FF]
	move.b	d0,unknown_4360                 	| [$0913: LD      (unknown_4360),A]
	rts                                    	| [$0916: RET]
	
player_move_right_requested_0917:
	move.b	(a0),d0                         	| [$0917: LD      A,(HL)]
	cmp.b	#0xC0,d0                         	| [$0918: CP      $C0]
	bcs.b	0f                               	| [...]
	rts                                    	| [$091a: RET     NC] [...]
0:
	* move to right
	addq.b	#1,(a0)                         	| [$091b: INC     (HL)]
	st.b	d0                                	| [$091c: LD      A,$FF]
	move.b	d0,unknown_4360                 	| [$091e: LD      (unknown_4360),A]
	rts                                    	| [$0921: RET]

l_0926:
	moveq	#0,d0
	move.b	(a0),d0                         	| [$0926: LD      A,(HL)]
	and.b	#0x07,d0                         	| [$0927: AND     $07]
	add.w	d0,a4
	                            	| [$0929: ADD     A,C]
	                           	| [$092a: LD      C,A]
	move.b	(a4),d0                         	| [$092b: LD      A,(BC)]
	                           	| [$092c: DEC     L]
	move.b	d0,-(a0)                         	| [$092d: LD      (HL),A]
	rts                                    	| [$092e: RET]
	
	DECL_ADDRESS	930
	
handle_player_shot_0930:
	move.b	(a0),d0                         	| [$0930: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$0931: AND     $08]
	jne	l_0964                             	| [$0933: JP      NZ,$0964]
	exg	a1,a0                              	| [$0936: EX      DE,HL]
	move.b	#0x10,d1                        	| [$0937: LD      B,$10]
	jbsr	check_input_bits_00bb                    	| [$0939: CALL    check_input_bits_00bb]
	bne.b	0f                               	| [...]
	rts                                    	| [$093c: RET     Z] [...]
0:
	move.b	(a0),d0                         	| [$093d: LD      A,(HL)]
	and.b	#0xEF,d0                         	| [$093e: AND     $EF]
	move.b	d0,(a0)                         	| [$0940: LD      (HL),A]
	move.b	(a1),d0                         	| [$0941: LD      A,(DE)]
	or.b	#0x08,d0                          	| [$0942: OR      $08]
	move.b	d0,(a1)                         	| [$0944: LD      (DE),A]
	addq.w	#2,a1                           	| [$0945: INC     DE] * 2
	move.b	player_ship_x_43C2,d0           	| [$0947: LD      A,(player_ship_x_43C2)]
	addq.b	#0x04,d0                        	| [$094a: ADD     $04]
	move.b	d0,(a1)+                         	| [$094c: LD      (DE),A]
	                           	| [$094d: INC     DE]
	move.b	player_ship_y_43C3,d0           	| [$094e: LD      A,(player_ship_y_43C3)]
	sub.b	#0x08,d0                         	| [$0951: SUB     $08]
	move.b	d0,(a1)                         	| [$0953: LD      (DE),A]
	subq.w	#1,a1                           	| [$0954: DEC     DE]
	exg	a1,a0                              	| [$0955: EX      DE,HL]
	lea	game_rom+0x1620,a4                      	| [$0956: LD      BC,$1620]
	jbsr	l_0926                            	| [$0959: CALL    $0926]
	move.b	#0x30,d0                        	| [$095C: LD      A,$30]
	move.b	d0,shot_sound_counter_4361                 	| [$095e: LD      (shot_sound_counter_4361),A]
	* play player shot sound
	move.w	#SHOT_SND,d0
	jra		osd_sound_start                                    	| [$0961: RET]

l_0964:
	addq.w	#3,a0                           	| [$0964: INC     L]
	move.b	(a0),d0                         	| [$0967: LD      A,(HL)]
	sub.b	#0x08,d0                         	| [$0968: SUB     $08]
	move.b	d0,(a0)                         	| [$096a: LD      (HL),A]
	cmp.b	#0x1F,d0                         	| [$096b: CP      $1F]
	bcs.b	0f                               	| [...]
	rts                                    	| [$096d: RET     NC] [...]
0:
disable_player_shot_096e:
	subq.w	#3,a0                           	| [$096e: DEC     L]
 	move.b	(a0),d0                         	| [$0971: LD      A,(HL)]
	and.b	#0xF7,d0                         	| [$0972: AND     $F7]
	move.b	d0,(a0)                         	| [$0974: LD      (HL),A]
	rts                                    	| [$0975: RET]

	DECL_ADDRESS	97a

* compute fine min x/max x depending on the position but also of the shape
* of the ship.
* without this routine, player is invincible, also, birds/vultures don't shoot

compute_player_ship_boundaries_097a:
	move.b	  player_ship_x_43C2,d0                       	| [$097A: LD      A,(player_ship_x_43C2)]
	move.b	d0,d1								| [$097D : LD      B,A]
	and.w	#0x07,d0                         	| [$097e: AND     $07]
	rol.b	#1,d0                            	| [$0980: RLCA]
	lea	game_rom+0x0B38,a0                      	| [$0981: LD      HL,$0B38]
	add.w	d0,a0
												| [$0984: ADD     A,L]
											| [$0985: LD      L,A]
	move.b	d1,d0                           	| [$0986: LD      A,B]
	sub.b	(a0)+,d0                          	| [$0987: SUB     (HL)]
	move.b	d0,player_ship_left_x_439E                 	| [$0988: LD      (player_ship_left_x_439E),A]
	                           	| [$098b: INC     HL]
	move.b	d1,d0                           	| [$098c: LD      A,B]
	add.b	(a0),d0                          	| [$098d: ADD     A,(HL)]
	move.b	d0,player_ship_right_x_439F                 	| [$098e: LD      (player_ship_right_x_439F),A]
	rts                                    	| [$0991: RET]
	               	| [$0992: LD      (player_ship_right_x_439F),A]
	              	| [$0995: RET]

	DECL_ADDRESS	9a0

display_player_ship_and_shots_09a0:
	lea	player_ship_x_43C2,a4          	| [$09a0: LD      BC,player_ship_x_43C2]
	lea	screen_address_43E2,a1                	| [$09a3: LD      DE,screen_address_43E2]
l_09a6:
	jbsr	l_09ba                            	| [$09a6: CALL    $09BA]
	addq.w	#3,a4                           	| [$09a9: INC     BC] * 3
	addq.w	#3,a1                           	| [$09ac: INC     DE] * 3
												| [$09af: LD      A,C]
	cmp.l	#player_ship_x_43C2+12,a4                         	| [$09b0: CP      $CE]
	jne	l_09a6                             	| [$09b2: JP      NZ,$09A6]
	rts                                    	| [$09b5: RET]
	
	DECL_ADDRESS	9ba
	
l_09ba:
	lea	game_rom+0x0A00,a0                      	| [$09ba: LD      HL,$0A00]
	moveq	#0,d0
	move.b	(a4)+,d0                         	| [$09bd: LD      A,(BC)]
	and.b	#0xF8,d0                         	| [$09be: AND     $F8]
	ror.b	#2,d0                            	| [$09c0: RRCA] * 2
	add.w	d0,a0		| okay to add as L is 0x00
	                            	| [$09c2: ADD     A,L]
	                           	| [$09c3: LD      L,A]
	move.b	(a0)+,(a1)+                         	| [$09c4: LD      A,(HL)]
		
											| [$09c5: LD      (DE),A]
	                           	| [$09c6: INC     BC]
	                           	| [$09c7: INC     DE]
	                           	| [$09c8: INC     HL]
	move.b	(a4),d0                         	| [$09c9: LD      A,(BC)]
	and.b	#0xF8,d0                         	| [$09ca: AND     $F8]
	ror.b	#3,d0                            	| [$09cc: RRCA] * 3
	add.b	(a0),d0                          	| [$09cf: ADD     A,(HL)]
	move.b	d0,(a1)                         	| [$09d0: LD      (DE),A]
	rts                                    	| [$09d1: RET]


birds_stuff_0a50:
	lea	bird_data_4B70,a4                	| [$0a50: LD      BC,bird_data_4B70]
	lea	unknown_4BB0,a1                	| [$0a53: LD      DE,unknown_4BB0]
l_0a56:
	move.l	a4,-(sp)                    	| [$0a56: PUSH    BC]
	jbsr	do_game_selected_routines_0718                            	| [$0a57: CALL    $0718]
	move.l	(sp)+,a4                    	| [$0a5a: POP     BC]
	addq.w	#4,a4                     	| [$0a5b: LD      A,C]
	* a1 follows a4
	lea		(0x40,a4),a1                     	| [$0a5c: ADD     $04]
	                     	| [$0a5e: LD      C,A]
	                      	| [$0a5f: ADD     $40]
	                     	| [$0a61: LD      E,A]
	                     	| [$0a62: LD      D,B]
	cmp.l	#unknown_4BB0+0x50,a1                         	| [$0a63: AND     A]  reached 0x4C00?
	jne	l_0a56                             	| [$0a64: JP      NZ,$0A56]
	rts                                    	| [$0a67: RET]

	DECL_ADDRESS	a6c
	
draw_birds_0a6c:
	lea	bird_data_4B70,a4                	| [$0a6c: LD      BC,bird_data_4B70]
	lea	unknown_4BB3,a1                	| [$0a6f: LD      DE,unknown_4BB3]
l_0a72:
	move.l	a4,-(sp)						| [$0a72: PUSH    BC]
	move.l	a1,-(sp)                    	| [$0a73: PUSH    DE]
	move.b	(a4),d0                         	| [$0a74: LD      A,(BC)]
	and.b	#0x18,d0                         	| [$0a75: AND     $18]
	jeq	l_0a8a                             	| [$0a77: JP      Z,$0A8A]
	exg	a1,a0                              	| [$0a7a: EX      DE,HL]
	move.b	(a0),d3                         	| [$0a7b: LD      D,(HL)]
	                           	| [$0a7c: DEC     HL]
	move.b	-(a0),d4                         	| [$0a7d: LD      E,(HL)]
	                           	| [$0a7e: DEC     HL]
	move.b	d3,-(a0)                         	| [$0a7f: LD      (HL),D]
	                           	| [$0a80: DEC     HL]
	move.b	d4,-(a0)                         	| [$0a81: LD      (HL),E]
	
	* no need to update a1 from d3/d4, a0 is loaded at l_09ba
	exg	a1,a0                              	| [$0a82: EX      DE,HL]
	addq.w	#2,a1                           	| [$0a83: INC     DE] * 2
	addq.w	#2,a4                           	| [$0a85: INC     BC] * 2
	jbsr	l_09ba                            	| [$0a87: CALL    $09BA]
l_0a8a:
	move.l	(sp)+,a1                    	| [$0a8a: POP     DE]
	move.l	(sp)+,a4                    	| [$0a8b: POP     BC]
	addq.w	#4,a4                        	| [$0a8c: LD      A,C]
	addq.w	#4,a1                        	| [$0a8d: ADD     $04]
	                        	| [$0a8f: LD      C,A]
	                        	| [$0a90: LD      A,E]
	                        	| [$0a91: ADD     $04]
	                        	| [$0a93: LD      E,A]
	cmp.l	#unknown_4BB3+0x50,a1                         	| [$0a94: CP      $03] wrapped to $4C03 ?
	jne	l_0a72                             	| [$0a96: JP      NZ,$0A72]
	rts                                    	| [$0a99: RET]
	
	DECL_ADDRESS	aa0
	* enters here with HL=$43C0
l_0aa0:
	lea		screen_address_43E2,a0                        	| [$0aa0: LD      L,$E2]
	move.b	(a0)+,d3                         	| [$0aa2: LD      D,(HL)]
	                           	| [$0aa3: INC     HL]
	move.b	(a0),d4                         	| [$0aa4: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	jbsr	AddOneRow_0210                    	| [$0aa5: CALL    AddOneRow_0210]
	subq.w	#1,d3                           	| [$0aa8: DEC     DE]
	move.b	#0x04,d1
	move.b	#0x04,d2                      	| [$0aa9: LD      BC,$0404]
	lea		shield_timer_43A6,a0                        	| [$0aac: LD      L,$A6]
	subq.b	#1,(a0)                         	| [$0aae: DEC     (HL)]
	move.b	(a0),d0                         	| [$0aaf: LD      A,(HL)]
	lea	game_rom+0x17F0,a0                      	| [$0ab0: LD      HL,$17F0]
	cmp.b	#0xC0,d0                         	| [$0ab3: CP      $C0]
	jeq	l_0b48                             	| [$0ab5: JP      Z,$0B48]
	lea	game_rom+0x1770,a0                      	| [$0ab8: LD      HL,$1770]
	and.w	#0x0C,d0                         	| [$0abb: AND     $0C]
	rol.b	#2,d0                            	| [$0abd: RLCA] * 2
	add.w	d0,a0                            	| [$0abf: ADD     A,L]
												| [$0ac0: LD      L,A]
										| [$0ac1: JP      $0AD6]
* < A0: block data (from ROM)
* < d1: number of columns
* < d2: number of rows
* < D3: start address

copy_block_to_screen_0ad6:
	movem.w	d3/d4,-(sp)                    	| [$0ad6: PUSH    DE]
	movem.w	d1/d2,-(sp)                    	| [$0ad7: PUSH    BC]
l_0ad8:
	move.b	(a0)+,d0                         	| [$0ad8: LD      A,(HL)]
	move.w	d3,d7
	jbsr	osd_w_videoram                         	| [$0ad9: LD      (DE),A]
	                           	| [$0ada: INC     HL]
	addq.w	#1,d3                           	| [$0adb: INC     DE]
	subq.b	#1,d1                           	| [$0adc: DEC     B]
	jne	l_0ad8                             	| [$0add: JP      NZ,$0AD8]
	movem.w	(sp)+,d1/d2                    	| [$0ae0: POP     BC]
	movem.w	(sp)+,d3/d4                    	| [$0ae1: POP     DE]
	jbsr	SubtractOneRow_0217               	| [$0ae2: CALL    SubtractOneRow_0217]
	subq.b	#1,d2                           	| [$0ae5: DEC     C]
 	jne	copy_block_to_screen_0ad6                             	| [$0ae6: JP      NZ,$0AD6]
	rts                                    	| [$0ae9: RET]

	DECL_ADDRESS	aea
	
* called all the time player is exploding
player_hit_0AEA:
	* align scrolling
	lea	current_scroll_value_43B9,a0   	| [$0aea: LD      HL,current_scroll_value_43B9]
	move.b	(a0),d0                         	| [$0aed: LD      A,(HL)]
	and.b	#0xF8,d0                         	| [$0aee: AND     $F8]
	move.b	d0,(a0)                         	| [$0af0: LD      (HL),A]
	jbsr	osd_set_scroll_value                       	| [$0af1: LD      ($5800),A] 58xx scroll register
	lea		screen_address_43E2,a0                        	| [$0af4: LD      L,$E2]
	move.b	(a0)+,d3                         	| [$0af6: LD      D,(HL)]
	                           	| [$0af7: INC     L]
	move.b	(a0),d4                         	| [$0af8: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	jbsr	AddOneRow_0210                    	| [$0af9: CALL    AddOneRow_0210]
	subq.w	#1,d3                           	| [$0afc: DEC     DE]
	LOAD_D3D4_FROM_D3_16                                 	| [$0afd: NOP]
	lea		timer_43A5,a0                        	| [$0afe: LD      L,$A5]
	subq.b	#1,(a0)                         	| [$0b00: DEC     (HL)]
	move.b	(a0),d0                         	| [$0b01: LD      A,(HL)]
	jeq	l_0b15                             	| [$0b02: JP      Z,$0B15]
	cmp.b	#0x20,d0                         	| [$0b05: CP      $20]
	jcs	l_0ba0                             	| [$0b07: JP      C,$0BA0]
	jeq	clear_foreground_tiles_0380                             	| [$0b0a: JP      Z,$0380]
	jra	l_0bba                             	| [$0b0d: JP      $0BBA]
	
l_0b15:
	                         	| [$0b15: DEC     L]
	move.b	#STATE_PLAYER_TURN_OVER,-(a0)                      	| [$0b16: LD      (HL),$05] sets game state to 05: lose a life, switch player
	lea		nb_lives_p1_4390,a0
	tst.b	current_player_is_p2_43A3                           	| [$0b18: DEC     L]
	beq.b	0f            	| [$0b1a: ADD     $90]
	lea		nb_lives_p2_4391,a0
0:
	          	| [$0b1c: LD      L,A]  selects 
	move.b	(a0),d0                         	| [$0b1d: LD      A,(HL)]
	                               	| [$0b1e: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$0b1f: RET     Z] [...]
0:
	tst.b	infinite_lives_flag
	bne.b	0f
	subq.b	#1,(a0)                         	| [$0b20: DEC     (HL)] remove one life
0:
	move.l	a0,-(sp)                        	| [$0b21: PUSH    HL]
	jbsr	display_players_lives_0367                            	| [$0b22: CALL    $0367]
	move.l	(sp)+,a0                        	| [$0b25: POP     HL]
	move.b	(a0),d0                         	| [$0b26: LD      A,(HL)]
	                               	| [$0b27: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$0b28: RET     Z] [...]
0:
	lea		game_state_43A4,a0			| [$0b29: LD      L,$A4]
	clr.b	(a0)                             	| [$0b2b: LD      (HL),$00] STATE_START_NEW_LIFE
	rts                                    	| [$0b2d: RET]

	DECL_ADDRESS	b48

l_0b48:
	jbsr	copy_block_to_screen_0ad6                            	| [$0b48: CALL    $0AD6]
	lea	unknown_43C0,a0                	| [$0b4b: LD      HL,unknown_43C0]
	move.b	#0x0C,(a0)+                      	| [$0b4e: LD      (HL),$0C]
                           	| [$0b50: INC     L]
	move.b	#0x0C,(a0)+                      	| [$0b51: LD      (HL),$0C]
                          	| [$0b53: INC     L]
	move.b	(a0),d0                         	| [$0b54: LD      A,(HL)]
	and.b	#0xF8,d0                         	| [$0b55: AND     $F8]
	or.b	#0x03,d0                          	| [$0b57: OR      $03]
	move.b	d0,(a0)                         	| [$0b59: LD      (HL),A]
	rts                                    	| [$0b5a: RET]
	
	DECL_ADDRESS	b60

* called during "game over" screen
* but also when a player loses a life, with possible switch to other player
player_turn_over_0B60:
	tst.b	highscores_beaten_flag
	beq.b	0f
	lea		highest_score_438B-2,a0
	jbsr	osd_write_high_scores
	clr.b	highscores_beaten_flag
0:
	lea	timer_43A5,a0                  	| [$0b60: LD      HL,timer_43A5]
	addq.b	#1,(a0)                         	| [$0b63: INC     (HL)]
	move.b	(a0),d0                         	| [$0b64: LD      A,(HL)]
	cmp.b	#0x40,d0                         	| [$0b65: CP      $40]
	jeq	clear_background_tiles_03a0                             	| [$0b67: JP      Z,$03A0]
	lea	game_rom+0x1A00,a0                      	| [$0b6a: LD      HL,$1A00]
	move.b	#0x01,d2                        	| [$0b6d: LD      C,$01]
	cmp.b	#0x80,d0                         	| [$0b6f: CP      $80]
	jne	l_0b95                             	| [$0b71: JP      NZ,$0B95]
	lea	game_state_43A4,a0             	| [$0b74: LD      HL,game_state_43A4]
	clr.b	(a0)                             	| [$0b77: LD      (HL),$00] STATE_START_NEW_LIFE
	lea	nb_lives_p1_4390,a0                        	| [$0b79: LD      L,$90]
	move.b	(a0)+,d0                         	| [$0b7b: LD      A,(HL)]
	                           	| [$0b7c: INC     L]
	or.b	(a0),d0                           	| [$0b7d: OR      (HL)]
	beq.b	0f                               	| [...]
	rts                                    	| [$0b7e: RET     NZ] [...]
0:
	clr.b	d0                               	| [$0b7f: XOR     A]
	lea	unknown_4398,a0                        	| [$0b80: LD      L,$98]
	move.b	d0,(a0)+                         	| [$0b82: LD      (HL),A]
	                           	| [$0b83: INC     L]
	move.b	d0,(a0)                         	| [$0b84: LD      (HL),A]
	lea	game_in_play_43A2,a0                        	| [$0b85: LD      L,$A2]
	move.b	d0,(a0)+                         	| [$0b87: LD      (HL),A]
	                           	| [$0b88: INC     L]
	move.b	(a0),d0                         	| [$0b89: LD      A,(HL)]
	                               	| [$0b8a: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$0b8b: RET     Z] [...]
0:
	clr.b	(a0)                             	| [$0b8c: LD      (HL),$00]
	move.w	#0x100,d1                      	| [$0b8e: LD      BC,$0100]
	jbsr	switch_to_other_bank_0460                    	| [$0b91: CALL    switch_to_other_bank_0460]
	rts                                    	| [$0b94: RET]
l_0b95:
	jbsr	draw_game_status_01d0                            	| [$0b95: CALL    $01D0]
	jbsr	l_01e4                            	| [$0b98: CALL    $01E4]
	rts                             	| [$0b9b: JP      screen_copyright_check_1df0]

l_0ba0:
	lea	current_stage_43B8,a0          	| [$0ba0: LD      HL,current_stage_43B8]
	move.b	(a0),d0                         	| [$0ba3: LD      A,(HL)]
	and.b	#0x0F,d0                         	| [$0ba4: AND     $0F]
	cmp.b	#0x04,d0                         	| [$0ba6: CP      $04]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0ba8: RET     C] [...]
0:
	cmp.b	#0x09,d0                         	| [$0ba9: CP      $09]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0bab: RET     NC] [...]
0:
	addq.w	#1,a0                           	| [$0bac: INC     L]
	clr.b	d0                               	| [$0bad: XOR     A]
	move.b	d0,(a0)                         	| [$0bae: LD      (HL),A]
	jbsr	osd_set_scroll_value                       	| [$0baf: LD      ($5800),A] 58xx scroll register
	jra	clear_background_tiles_03a0                             	| [$0bb2: JP      $03A0]

	DECL_ADDRESS	bba
	
l_0bba:
	move.b	d0,d1                           	| [$0bba: LD      B,A]
	ror.b	#1,d0                            	| [$0bbb: RRCA]
	jcc	l_0fc0                             	| [$0bbc: JP      NC,$0FC0]
	ror.b	#1,d0                            	| [$0bbf: RRCA]
	jcs	l_2070                             	| [$0bc1: JP      C,$2070]
	move.b	d1,d0                           	| [$0bc0: LD      A,B]
	jra	l_20e8                             	| [$0bc4: JP      $20E8]

draw_bird_extended_winds_0bca:
	move.w	#0x42D0,d7                	| [$0bca: LD      HL,unknown_42D0]
	move.w	#0xFFDF,d1                      	| [$0bcd: LD      BC,$FFDF]
	move.b	#0x64,d0                      	| [$0bd0: LD      (HL),$64]
	jbsr	osd_w_videoram
	add.w	d1,d7                            	| [$0bd2: ADD     HL,BC]
	addq.w	#1,d7                           	| [$0bd3: INC     HL]
	move.b	#0x65,d0                      	| [$0bd4: LD      (HL),$65]
	jbsr	osd_w_videoram
	move.w	#0x42F2,d7                	| [$0bd6: LD      HL,unknown_42F2]
	lea	game_rom+0x0A40,a1                      	| [$0bd9: LD      DE,$0A40]
	jbsr	copy_4_columns_to_screen_3538                            	| [$0bdc: CALL    $3538]
	move.w	#0x4B15,d7                	| [$0bdf: LD      HL,unknown_4B15]
	lea	game_rom+0x3C00,a1                      	| [$0be2: LD      DE,$3C00]
	jbsr	copy_6_columns_to_screen_3528                            	| [$0be5: CALL    $3528]
	move.w	#0x4AD8,d7                	| [$0be8: LD      HL,unknown_4AD8]
	lea	game_rom+0x0A48,a1                      	| [$0beb: LD      DE,$0A48]
	jbsr	copy_2_columns_to_screen_3548                            	| [$0bee: CALL    $3548]
	rts                                    	| [$0bf1: RET]

moving_bird_shot_0C00:

	* here A0 points on ram at 0x4Bxx
	move.l	a0,-(sp)                        	| [$0c00: PUSH    HL]
	* compute A0 lsb
	move.l	a0,d6
	sub.l	#unknown_4B40-0x40,d6			| 4B00
	                           	| [$0c01: LD      A,L]
	sub.b	#0x72,d6                         	| [$0c02: SUB     $72]
	ror.b	#1,d6                            	| [$0c04: RRCA]
	add.b	#0x50,d6                         	| [$0c05: ADD     $50]
	                           	| [$0c07: LD      L,A]  recompute a0
	lea		unknown_4B40-0x40,a0
	add.w	d6,a0
	move.b	(a0)+,d0                         	| [$0c08: LD      A,(HL)]
												| [$0c09: INC     L]


	move.b	(a0),d6                         	| [$0c0a: LD      L,(HL)]
	move.b	d0,d5                           	| [$0c0b: LD      H,A]
	bsr		load_rom_in_a0_from_d5d6
	
	move.b	#0x0C,d3
	move.b	#0x04,d4                      	| [$0c0c: LD      DE,$0C04]
	move.b	(a0),d0                         	| [$0c0f: LD      A,(HL)]
	move.l	(sp)+,a0                        	| [$0c10: POP     HL]
	cmp.b	#0x07,d0                         	| [$0c11: CP      $07]
	jcs	bird_shot_0EA4                     	| [$0c13: JP      C,bird_shot_0EA4]
	cmp.b	#0x09,d0                         	| [$0c16: CP      $09]
	jcc	bird_shot_0EA4                     	| [$0c18: JP      NC,bird_shot_0EA4]
	move.b	#0x10,d3
	move.b	#0x20,d4                      	| [$0c1b: LD      DE,$1020]
	st.b	d0                                	| [$0c1e: LD      A,$FF]
	move.b	d0,unknown_4369                 	| [$0c20: LD      (unknown_4369),A]
	jra	bird_shot_0EA4                     	| [$0c23: JP      bird_shot_0EA4]

l_0c40:
	lea	unknown_43FF,a0                	| [$0c40: LD      HL,unknown_43FF]
	move.b	#0x05,d1                        	| [$0c43: LD      B,$05]
	jbsr	l_088b                            	| [$0c45: CALL    $088B]
	jbsr	l_0c56                            	| [$0c48: CALL    $0C56]
	jbsr	l_0c6b                            	| [$0c4b: CALL    $0C6B]
	jbsr	l_0cd8                            	| [$0c4e: CALL    $0CD8]
	rts                                    	| [$0c51: RET]

l_0c56:
	lea	player_shot_3_structure_43CC,a0	| [$0c56: LD      HL,player_shot_3_structure_43CC]
l_0c59:
	move.l	a0,-(sp)                        	| [$0c59: PUSH    HL]
	jbsr	l_0c84                            	| [$0c5a: CALL    $0C84]
	move.l	(sp)+,a0                        	| [$0c5d: POP     HL]
	                           	| [$0c5e: LD      A,L]
	addq.w	#0x04,a0                        	| [$0c5f: ADD     $04]
	                           	| [$0c61: LD      L,A]
	cmp.l	#unknown_43E0,a0                         	| [$0c62: CP      $E0]
	jne	l_0c59                             	| [$0c64: JP      NZ,$0C59]
	rts                                    	| [$0c67: RET]

l_0c6b:
	lea	unknown_43CE,a4                	| [$0c6b: LD      BC,unknown_43CE]
	lea	unknown_43EE,a1                	| [$0c6e: LD      DE,unknown_43EE]
l_0c71:
	jbsr	l_09ba                            	| [$0c71: CALL    $09BA]
	addq.w	#3,a4                           	| [$0c74: INC     BC] * 3
	addq.w	#3,a1                           	| [$0c77: INC     DE] * 3
												| [$0c7a: LD      A,C]
	cmp.l	#unknown_43CE+0xE2-0XCE,a4                         	| [$0c7b: CP      $E2]
	jne	l_0c71                             	| [$0c7d: JP      NZ,$0C71]
	rts                                    	| [$0c80: RET]

l_0c84:
	move.b	(a0),d0                         	| [$0c84: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$0c85: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$0c87: RET     Z] [...]
0:
													| [$0c88: NOP]
													| [$0c89: NOP]
	addq.w	#1,a0                           	| [$0c8a: INC     L]
	move.b	(a0),d0                         	| [$0c8b: LD      A,(HL)]
	eor.b	#0x04,d0                         	| [$0c8c: XOR     $04]
	move.b	d0,(a0)                         	| [$0c8e: LD      (HL),A]
	addq.w	#2,a0                           	| [$0c8f: INC     L]
	move.b	(a0),d0                         	| [$0c91: LD      A,(HL)]
	addq.b	#0x04,d0                        	| [$0c92: ADD     $04]
	move.b	d0,(a0)                         	| [$0c94: LD      (HL),A]
	cmp.b	#0xF9,d0                         	| [$0c95: CP      $F9]
	jcc	disable_player_shot_096e                             	| [$0c97: JP      NC,$096E]
	subq.w	#1,a0                           	| [$0c9a: DEC     L]
	jbsr	player_vs_enemy_collision_0cb4                            	| [$0c9b: CALL    $0CB4]
	
	lea		(0x20,a0),a1
												| [$0c9e: LD      D,H]
												| [$0c9f: LD      A,L]
												| [$0ca0: ADD     $20]
												| [$0ca2: LD      E,A]
	exg	a1,a0                              	| [$0ca3: EX      DE,HL]
	move.b	(a0)+,d1                         	| [$0ca4: LD      B,(HL)]
	                           	| [$0ca5: INC     HL]
	move.b	(a0),d2                         	| [$0ca6: LD      C,(HL)]
	bsr		load_ram_in_a4_from_d1d2
	move.b	(a4),d0                         	| [$0ca7: LD      A,(BC)]
	exg	a1,a0                              	| [$0ca8: EX      DE,HL]
	addq.w	#1,a0                           	| [$0ca9: INC     L]
	cmp.b	#0xE8,d0                         	| [$0caa: CP      $E8]
	jcc	disable_player_shot_096e                             	| [$0cac: JP      NC,$096E]
	rts                                    	| [$0caf: RET]

player_vs_enemy_collision_0cb4:
	cmp.b	#0xDC,d0                         	| [$0cb4: CP      $DC] first check object Y
	bcc.b	0f                               	| [...]
	rts                                    	| [$0cb6: RET     C] [...]
0:
	cmp.b	#0xE9,d0                         	| [$0cb7: CP      $E9] if doesn't match player Y, skip
	bcs.b	0f                               	| [...]
	rts                                    	| [$0cb9: RET     NC] [...]
0:
	move.b	player_ship_right_x_439F,d0                 	| [$0cba: LD      A,(player_ship_right_x_439F)]
	cmp.b	(a0),d0                          	| [$0cbd: CP      (HL)]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0cbe: RET     C] [...]
0:
	move.b	player_ship_left_x_439E,d0                 	| [$0cbf: LD      A,(player_ship_left_x_439E)]
	cmp.b	(a0),d0                          	| [$0cc2: CP      (HL)]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0cc3: RET     NC] [...]
0:
player_hit_0cc4:
	tst.b	invincible_flag
	beq.b	0f
	rts
0:
	jbsr	osd_sound_stop
	move.w	#EXPLOSION_SND,d0
	jbsr	osd_sound_start
	
	move.b	#STATE_PLAYER_HIT,d0                        	| [$0cc4: LD      A,$04]
	move.b	d0,game_state_43A4              	| [$0cc6: LD      (game_state_43A4),A]
	move.b	#0x60,d0                        	| [$0cc9: LD      A,$60]
	move.b	d0,timer_43A5                   	| [$0ccb: LD      (timer_43A5),A]
	move.b	#0x10,d0                        	| [$0cce: LD      A,$10]
	move.b	d0,unknown_4363                 	| [$0cd0: LD      (unknown_4363),A]
	rts                                    	| [$0cd3: RET]

	DECL_ADDRESS	cd8
l_0cd8:
	lea	player_shot_3_structure_43CC,a4	| [$0cd8: LD      BC,player_shot_3_structure_43CC]
	lea	unknown_43EC,a1                	| [$0cdb: LD      DE,unknown_43EC]
l_0cde:
	move.l	a4,-(sp)                        	| [$0cde: PUSH    BC]
	jbsr	do_game_selected_routines_0718                            	| [$0cdf: CALL    $0718]
	move.l	(sp)+,a4                        	| [$0ce2: POP     BC]
	addq.w	#4,a4                           	| [$0ce3: LD      A,C]
	lea		(0x20,a4),a1                     	| [$0ce4: ADD     $04]
	                     	| [$0ce6: LD      C,A]
	                      	| [$0ce7: ADD     $20]
	                     	| [$0ce9: LD      E,A]
	                     	| [$0cea: LD      D,B]
	cmp.l	#unknown_43EC+0x14,a1          	| [$0ceb: AND     A] reached $4400?
	jne	l_0cde                             	| [$0cec: JP      NZ,$0CDE]
	rts                                    	| [$0cef: RET]

	DECL_ADDRESS	cf4
l_0cf4:
	movem.w	(sp)+,d3/d4                    	| [$0cf4: POP     DE]
	movem.w	(sp)+,d1/d2                    	| [$0cf5: POP     BC]
	rts                                    	| [$0cf6: RET]

l_0d1c:
	lea	bird_data_4B70,a4                	| [$0d1c: LD      BC,bird_data_4B70]
	lea	unknown_4B50,a0                	| [$0d1f: LD      HL,unknown_4B50]
l_0d22:
	jbsr	l_0d30                            	| [$0d22: CALL    $0D30]
	addq.w	#2,a4                           	| [$0d25: INC     C]
	addq.w	#1,a0                           	| [$0d27: INC     L]
												| [$0d28: LD      A,$B0]
	cmp.l	#bird_data_4B70+0xB0-0x70,a4                            	| [$0d2a: CP      C]
	jne	l_0d22                             	| [$0d2b: JP      NZ,$0D22]
	rts                                    	| [$0d2e: RET]

l_0d30:
	move.b	(a0)+,d3                         	| [$0d30: LD      D,(HL)]
											| [$0d31: INC     HL]
	move.b	(a4),d0                         	| [$0d32: LD      A,(BC)]
	addq.w	#2,a4                           	| [$0d33: INC     BC] * 2
	and.b	#0x08,d0                         	| [$0d35: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$0d37: RET     Z] [...]
0:
	move.b	(a0),d4                         	| [$0d38: LD      E,(HL)]
	bsr		load_rom_in_a1_from_d3d4
	exg	a1,a0                              	| [$0d39: EX      DE,HL]
	move.b	(a0),d0                         	| [$0d3a: LD      A,(HL)]
	rol.b	#1,d0                            	| [$0d3b: RLCA]
	                        	| [$0d3c: ADD     $00]
	and.w	#0xFF,d0
	lea		game_rom+0x1700,a0
	add.w	d0,a0                           	| [$0d3e: LD      L,A]
												| [$0d3f: LD      H,$17]
	clr.b	d0                               	| [$0d41: XOR     A]
	cmp.b	(a0),d0                          	| [$0d42: CP      (HL)]
	jeq	l_0d4f                             	| [$0d43: JP      Z,$0D4F]
	addq.w	#1,a0                           	| [$0d46: INC     HL]
	cmp.b	(a0),d0                          	| [$0d47: CP      (HL)]
	jeq	l_0d5e                             	| [$0d48: JP      Z,$0D5E]
	                           	| [$0d4b: DEC     HL]
	move.b	(a4),d0                         	| [$0d4c: LD      A,(BC)]
	add.b	-(a0),d0                          	| [$0d4d: ADD     A,(HL)]
	move.b	d0,(a4)                         	| [$0d4e: LD      (BC),A]
l_0d4f:
	addq.w	#1,a4                           	| [$0d4f: INC     BC]
	addq.w	#1,a0                           	| [$0d50: INC     HL]
	move.b	(a4),d0                         	| [$0d51: LD      A,(BC)]
	add.b	(a0),d0                          	| [$0d52: ADD     A,(HL)]
	move.b	d0,(a4)                         	| [$0d53: LD      (BC),A]
	subq.w	#1,a4                           	| [$0d54: DEC     BC]
	exg	a1,a0                              	| [$0d57: EX      DE,HL]
	and.b	#0x07,d0                         	| [$0d55: AND     $07]
	beq.b	0f                               	| [...]
	rts                                    	| [$0d58: RET     NZ] [...]
0:
	addq.b	#1,(a0)                         	| [$0d59: INC     (HL)]
	rts                                    	| [$0d5a: RET]

l_0d5e:
	                           	| [$0d5e: DEC     HL]
	move.b	(a4),d0                         	| [$0d5f: LD      A,(BC)]
	add.b	-(a0),d0                          	| [$0d60: ADD     A,(HL)]
	move.b	d0,(a4)                         	| [$0d61: LD      (BC),A]
	and.b	#0x07,d0                         	| [$0d62: AND     $07]
	exg	a1,a0                              	| [$0d64: EX      DE,HL]
	beq.b	0f                               	| [...]
	rts                                    	| [$0d65: RET     NZ] [...]
0:
	addq.b	#1,(a0)                         	| [$0d66: INC     (HL)]
	rts                                    	| [$0d67: RET]

l_0d70:
	lea	bird_data_4B70,a4                	| [$0d70: LD      BC,bird_data_4B70]
	lea	unknown_4B50,a0                	| [$0d73: LD      HL,unknown_4B50]
	* loops
l_0d76:
	jbsr	animate_birds_0d86                            	| [$0d76: CALL    $0D86]
	                           	| [$0d79: LD      A,C]
	addq.w	#0x04,a4                        	| [$0d7a: ADD     $04]
	                           	| [$0d7c: LD      C,A]
	cmp.l	#bird_data_4B70+0xB0-0x70,a4                        	| [$0d7d: LD      A,$B0]
	                            	| [$0d7f: CP      C]
	jne	l_0d76                             	| [$0d80: JP      NZ,$0D76]
	rts                                    	| [$0d83: RET]

	DECL_ADDRESS	d86
	
* when commented out, birds aren't animated at all. They move but with the same char
* (and occasionally go berzerk)
* < A0:
* < A4:
animate_birds_0d86:
	
	move.b	(a0)+,d3                         	| [$0d86: LD      D,(HL)]
	                           	| [$0d87: INC     HL]
	move.b	(a0)+,d4                         	| [$0d88: LD      E,(HL)]
	                           	| [$0d89: INC     HL]
	move.b	(a4),d0                         	| [$0d8a: LD      A,(BC)]
	and.b	#0x08,d0                         	| [$0d8b: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$0d8d: RET     Z] [...]
0:
	bsr		load_rom_in_a1_from_d3d4			| l_0dde needs to write in A1
	* put value of a1 in a0, save a0 in a1
	
	exg		a0,a1                              	| [$0d8e: EX      DE,HL]
	
	move.b	(a0),d0                         	| [$0d8f: LD      A,(HL)]
	                               	| [$0d90: AND     A]
	bne.b	0f                               	| [...]
	* if d0=0 we have to retrieve a non-zero value from the call below (0 is an invalid slot)
	jbsr	l_0dde                            	| [$0d91: CALL    Z,$0DDE]
0:
	* select ROM slot from $16A0 (3 values per slot, 0 is invalid as it points to FF FF FF)
	move.b	d0,d6                           	| [$0d94: LD      L,A]
	rol.b	#1,d0                            	| [$0d95: RLCA]
	add.b	d6,d0                            	| [$0d96: ADD     A,L] d0=d0 times 3
	add.b	#0xA0,d0                         	| [$0d97: ADD     $A0]  lsb A0
	move.b	d0,d6                           	| [$0d99: LD      L,A]
	move.b	#0x16,d5                        	| [$0d9a: LD      H,$16] msb 16xx of rom
	move.b	(a4),d0                         	| [$0d9c: LD      A,(BC)]
	and.b	#0xF8,d0                         	| [$0d9d: AND     $F8]
	bsr		load_rom_in_a0_from_d5d6
	or.b	(a0)+,d0                           	| [$0d9f: OR      (HL)]
	move.b	d0,(a4)                         	| [$0da0: LD      (BC),A]
	addq.w	#3,a4                           	| [$0da1: INC     BC] * 3
	                           	| [$0da4: INC     HL]
	move.b	(a0)+,d0                         	| [$0da5: LD      A,(HL)]
	                           	| [$0da6: INC     HL]
	ror.b	#1,d0                            	| [$0da7: RRCA]
	jcs	l_0dbb                             	| [$0da8: JP      C,$0DBB]
	ror.b	#1,d0                            	| [$0dab: RRCA]
	jcs	l_0dcc                             	| [$0dac: JP      C,$0DCC]
	move.b	(a4),d0                         	| [$0daf: LD      A,(BC)]
	ror.b	#1,d0                            	| [$0db0: RRCA]
	and.b	#0x03,d0                         	| [$0db1: AND     $03]
	add.b	(a0),d0                          	| [$0db3: ADD     A,(HL)]
	subq.w	#1,a4                           	| [$0db4: DEC     BC]
	jra	l_0dd2                             	| [$0db5: JP      $0DD2]

l_0dbb:
	move.b	(a4),d0                         	| [$0dbb: LD      A,(BC)]
	ror.b	#1,d0                            	| [$0dbc: RRCA]
	and.b	#0x03,d0                         	| [$0dbd: AND     $03]
	add.b	(a0),d0                          	| [$0dbf: ADD     A,(HL)]
	move.b	d0,d5                           	| [$0dc0: LD      H,A]
												| [$0dc1: DEC     BC]
	move.b	-(a4),d0                         	| [$0dc2: LD      A,(BC)]
	and.b	#0x04,d0                         	| [$0dc3: AND     $04]
	add.b	d5,d0                            	| [$0dc5: ADD     A,H]
	jra	l_0dd2                             	| [$0dc6: JP      $0DD2]

l_0dcc:
												| [$0dcc: DEC     BC]
	move.b	-(a4),d0                         	| [$0dcd: LD      A,(BC)]
	ror.b	#1,d0                            	| [$0dce: RRCA]
	and.b	#0x03,d0                         	| [$0dcf: AND     $03]
	add.b	(a0),d0                          	| [$0dd1: ADD     A,(HL)]
l_0dd2:
	move.b	d0,d6                           	| [$0dd2: LD      L,A]
	move.b	#0x16,d5                        	| [$0dd3: LD      H,$16] msb of $16xx
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0),d0                         	| [$0dd5: LD      A,(HL)]
	                           	| [$0dd6: DEC     BC]
	move.b	d0,-(a4)                         	| [$0dd7: LD      (BC),A]
	subq.w	#1,a4                           	| [$0dd8: DEC     BC]
	* restore value of a0
	exg		a0,a1                           	| [$0dd9: EX      DE,HL]
	rts                                    	| [$0dda: RET]

	DECL_ADDRESS	dde
	
* change value of HL (D5/D6)
* also stores in DE (A1)
l_0dde:
	subq.w	#2,a1                           	| [$0dde: DEC     DE]
	                           	| [$0ddf: DEC     DE]
	move.b	unknown_4394,d0                 	| [$0de0: LD      A,(unknown_4394)]
	move.b	d0,(a1)+                         	| [$0de3: LD      (DE),A]
	move.b	d0,d5                           	| [$0de4: LD      H,A]
	                           	| [$0de5: INC     DE]
	move.b	unknown_4395,d0                 	| [$0de6: LD      A,(unknown_4395)]
	move.b	d0,(a1)+                         	| [$0de9: LD      (DE),A]
	move.b	d0,d6                           	| [$0dea: LD      L,A]
	                           	| [$0deb: INC     DE]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0),d0                         	| [$0dec: LD      A,(HL)]
	rts                                    	| [$0ded: RET]

player_shots_vs_birds_collision_0DF0:
	lea	player_shot_1_structure_43C4,a4	| [$0df0: LD      BC,player_shot_1_structure_43C4]
	lea	ram_pointer_on_flying_enemies_table_43E6,a0	| [$0df3: LD      HL,ram_pointer_on_flying_enemies_table_43E6] contains pointer on birds table
	jbsr	player_shot_vs_bird_collision_0E10	| [$0df6: CALL    player_shot_vs_bird_collision_0E10]
	lea	player_shot_2_structure_43C8,a4	| [$0df9: LD      BC,player_shot_2_structure_43C8]
	lea	ram_pointer_on_birds_table_43EA,a0	| [$0dfc: LD      HL,ram_pointer_on_birds_table_43EA] contains pointer on birds table (same one!)
	 	| [$0dff: JP      player_shot_vs_bird_collision_0E10]


player_shot_vs_bird_collision_0E10:
	move.b	(a4),d0                         	| [$0e10: LD      A,(BC)]
	and.b	#0x08,d0                         	| [$0e11: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$0e13: RET     Z] shot not active: return [...]
0:
* this shot is active
	move.b	(a0)+,d3                         	| [$0e14: LD      D,(HL)]
									| [$0e15: INC     L]
 	move.b	(a0),d4                         	| [$0e16: LD      E,(HL)] DE points to contents of HL (433A)
	bsr		load_ram_in_a1_from_d3d4
	move.b	(a1),d0                         	| [$0e17: LD      A,(DE)]
	cmp.b	#0xC0,d0                         	| [$0e18: CP      $C0]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0e1a: RET     NC] [...]
0:
	cmp.b	#0x60,d0                         	| [$0e1b: CP      $60]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0e1d: RET     C] [...]
0:
	cmp.b	#0x68,d0                         	| [$0e1e: CP      $68]
	jcc	l_0e39                             	| [$0e20: JP      NC,$0E39]
	and.b	#0x07,d0                         	| [$0e23: AND     $07]
	rol.b	#2,d0                            	| [$0e25: RLCA] * 2
* set HL to A*4+$1740 (table in ROM), offset table or something
	add.b	#0x40,d0                         	| [$0e27: ADD     $40]
	move.b	d0,d6                           	| [$0e29: LD      L,A]
	move.b	#0x17,d5                        	| [$0e2a: LD      H,$17]
	addq.w	#2,a4                           	| [$0e2c: INC     BC] * 2
	move.b	(a4),d0                         	| [$0e2e: LD      A,(BC)]
	and.b	#0x07,d0                         	| [$0e2f: AND     $07]
	bsr		load_rom_in_a0_from_d5d6
	cmp.b	(a0),d0                          	| [$0e31: CP      (HL)]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0e32: RET     NC] [...]
0:
	addq.w	#1,a0                           	| [$0e33: INC     HL]
	cmp.b	(a0),d0                          	| [$0e34: CP      (HL)]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0e35: RET     C] [...]
0:
	jra	l_0e70                             	| [$0e36: JP      $0E70]

l_0e39:
	addq.w	#2,a4                           	| [$0e39: INC     BC]
	                           	| [$0e3a: INC     BC]
	move.b	(a4)+,d0                         	| [$0e3b: LD      A,(BC)]
	move.b	d0,d3                           	| [$0e3c: LD      D,A]
	                           	| [$0e3d: INC     BC]
	move.b	(a4),d0                         	| [$0e3e: LD      A,(BC)]
	and.b	#0xF8,d0                         	| [$0e3f: AND     $F8]
	move.b	d0,d4                           	| [$0e41: LD      E,A]
	* shot close to a bird in motion (not in swarm)
	lea	bird_data_4B70,a0                	| [$0e42: LD      HL,bird_data_4B70]
l_0e45:
	move.b	(a0),d0                         	| [$0e45: LD      A,(HL)]
	addq.w	#2,a0                           	| [$0e46: INC     HL] * 2
	and.b	#0x08,d0                         	| [$0e48: AND     $08]
	beq.b	0f                               	| [...]
	jbsr	moving_bird_close_to_shot_0E58    	| [$0e4a: CALL    NZ,moving_bird_close_to_shot_0E58]
0:
	addq.w	#2,a0                           	| [$0e4d: INC     HL] * 2
	cmp.l	#bird_data_4B70+0xB0-0x70,a0                        	| [$0e4f: LD      A,$B0]
											| [$0e51: CP      L]
	jne	l_0e45                             	| [$0e52: JP      NZ,$0E45]
	rts                                    	| [$0e55: RET]

* D3/D4 shots coordinates
moving_bird_close_to_shot_0E58:
	move.b	d3,d0                           	| [$0e58: LD      A,D]
	cmp.b	(a0),d0                          	| [$0e59: CP      (HL)]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0e5a: RET     C] [...]
0:
	move.b	(a0),d0                         	| [$0e5b: LD      A,(HL)]
	add.b	#0x08,d0                         	| [$0e5c: ADD     $08]
	cmp.b	d3,d0                            	| [$0e5e: CP      D]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0e5f: RET     C] [...]
0:
	                           	| [$0e60: INC     HL]
	move.b	(1,a0),d0                         	| [$0e61: LD      A,(HL)]
	                           	| [$0e62: DEC     HL]
	addq.b	#0x04,d0                        	| [$0e63: ADD     $04]
	cmp.b	d4,d0                            	| [$0e65: CP      E]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0e66: RET     C] [...]
0:
	sub.b	#0x0C,d0                         	| [$0e67: SUB     $0C]
	cmp.b	d4,d0                            	| [$0e69: CP      E]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0e6a: RET     NC] [...]
0:
	jra	moving_bird_shot_0C00              	| [$0e6b: JP      moving_bird_shot_0C00]


l_0e70:
	addq.w	#1,a0                           	| [$0e70: INC     HL]
	move.b	(a4)+,d0                         	| [$0e71: LD      A,(BC)]
	and.b	#0xF8,d0                         	| [$0e72: AND     $F8]
	add.b	(a0),d0                          	| [$0e74: ADD     A,(HL)]
	move.b	d0,d3                           	| [$0e75: LD      D,A]
											| [$0e76: INC     BC]
	move.b	(a4),d0                         	| [$0e77: LD      A,(BC)]
	and.b	#0xF8,d0                         	| [$0e78: AND     $F8]
	move.b	d0,d4                           	| [$0e7a: LD      E,A]
	lea	bird_data_4B70,a0                	| [$0e7b: LD      HL,bird_data_4B70]
l_0e7e:
	move.b	(a0),d0                         	| [$0e7e: LD      A,(HL)]
	addq.w	#2,a0                           	| [$0e7f: INC     HL] * 2
	and.b	#0x08,d0                         	| [$0e81: AND     $08]
	beq.b	0f                               	| [...]
	jbsr	swarm_bird_close_to_shot_0E90     	| [$0e83: CALL    NZ,swarm_bird_close_to_shot_0E90]
0:
	addq.w	#2,a0                           	| [$0e86: INC     HL] * 2
	                        	| [$0e88: LD      A,$B0]
	cmp.l	#bird_data_4B70+0xB0-0x70,a0                            	| [$0e8a: CP      L]
	jne	l_0e7e                             	| [$0e8b: JP      NZ,$0E7E]
	rts                                    	| [$0e8e: RET]

	DECL_ADDRESS	e90
	
swarm_bird_close_to_shot_0E90:
	move.b	(a0),d0                         	| [$0e90: LD      A,(HL)]
	addq.b	#0x02,d0                        	| [$0e91: ADD     $02]
	cmp.b	d3,d0                            	| [$0e93: CP      D]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0e94: RET     C] [...]
0:
	subq.b	#0x05,d0                        	| [$0e95: SUB     $05]
	cmp.b	d3,d0                            	| [$0e97: CP      D]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0e98: RET     NC] [...]
0:
	                           	| [$0e99: INC     HL]
	move.b	(1,a0),d0                         	| [$0e9a: LD      A,(HL)]
	                           	| [$0e9b: DEC     HL]
	and.b	#0xF8,d0                         	| [$0e9c: AND     $F8]
	cmp.b	d4,d0                            	| [$0e9e: CP      E]
	beq.b	0f                               	| [...]
	rts                                    	| [$0e9f: RET     NZ] [...]
0:
	* from now on, function isn't going to return to caller
	* regular explosion (swarm) then return to caller's caller
	move.b	#0x0C,d3
	move.b	#0x02,d4                      	| [$0ea0: LD      DE,$0C02]
	                                    	| [$0ea3: NOP]

* swarm or moving, when shot, ends up here
* deactivates bird, player shot and counts one less enemy
* < HL: pointer on current enemy
* < BC: pointer on current player shot
bird_shot_0EA4:
* position ourselves on the previous enemy/shot, those are the
* ones we need to deactivate
	subq.w	#2,a0                           	| [$0ea4: DEC     HL] * 2
	subq.w	#3,a4                           	| [$0ea6: DEC     BC] * 3
	move.b	(a4),d0                         	| [$0ea9: LD      A,(BC)]
	and.b	#0xF7,d0                         	| [$0eaa: AND     $F7]
	move.b	d0,(a4)                         	| [$0eac: LD      (BC),A] disable shot ($18 => $10)
l_0ead:
	move.b	(a0),d0                         	| [$0ead: LD      A,(HL)]
	and.b	#0xF7,d0                         	| [$0eae: AND     $F7]
	move.b	d0,(a0)                         	| [$0eb0: LD      (HL),A] disable enemy
	                           	| [$0eb1: LD      A,L]
	add.w	#0x42,a0                         	| [$0eb2: ADD     $42]
	                           	| [$0eb4: LD      L,A]
	move.b	(a0)+,d1                         	| [$0eb5: LD      B,(HL)]
	                           	| [$0eb6: INC     HL]
	move.b	(a0),d2                         	| [$0eb7: LD      C,(HL)] load into BC (ram pointer)
	move.w	#VULTURE_SHOT_SND,d5

	lea	slot_for_special_animation_4378,a0                	| [$0eb8: LD      HL,slot_for_special_animation_4378]
	move.b	d3,d0                           	| [$0ebb: LD      A,D]
	cmp.b	#0x10,d0                         	| [$0ebc: CP      $10]	Are we to use the special animation?
	jeq	l_0ec3                             	| [$0ebe: JP      Z,$0EC3]
	move.w	#BIRD_SHOT_SND,d5
	lea	slot_for_regular_animation_4370,a0                        	| [$0ec1: LD      L,$70]
l_0ec3:
	move.b	d5,d0
	jbsr	osd_sound_start

	move.b	(a0),d0                         	| [$0ec3: LD      A,(HL)]
	                               	| [$0ec4: AND     A]
	jeq	l_0ed5                             	| [$0ec5: JP      Z,$0ED5]
	addq.w	#4,a0                           	| [$0ec8: INC     L]   Increase HL by 4. [now at 2nd or 4th slot]
	move.b	(a0),d0                         	| [$0ecc: LD      A,(HL)] 
	                               	| [$0ecd: AND     A]	Is this slot available?

* else use the next slot.  Bugged when birds are flying upwards.
* source of 204K bug. HL becomes #4380 which is start of score.
	jeq	l_0ed5                             	| [$0ece: JP      Z,$0ED5] Yes, skip ahead, we will use this slot
	addq.w	#4,a0                           	| [$0ed1: INC     L] 
* there should have been a check here to see if HL==#4380 and change it if so.
* else, score bug appears. Adapted Don Hodges patch directly here

	cmp.l	#slot_for_regular_animation_4370+0x10,a0
	bne.b	l_0ed5
	sub.w	#0x10,a0			| fixes animation score bug trash directly
	* init explosion animation
l_0ed5:
	move.b	d3,(a0)+                         	| [$0ed5: LD      (HL),D]
	                           	| [$0ed6: INC     L]
 	move.b	d4,(a0)+                         	| [$0ed7: LD      (HL),E]
	                          	| [$0ed8: INC     L]
	move.b	d1,(a0)+                         	| [$0ed9: LD      (HL),B]
	                           	| [$0eda: INC     L]
 	move.b	d2,(a0)                         	| [$0edb: LD      (HL),C]
	lea	killed_sfx_flag_4364,a0                        	| [$0edc: LD      L,$64]
	st		(a0)                      	| [$0ede: LD      (HL),$FF] sets 4364 to $FF: triggers "killed" sfx
	lea	nb_birds_to_kill_before_stage_completed_43BA,a0                        	| [$0ee0: LD      L,$BA]
	subq.b	#1,(a0)                         	| [$0ee2: DEC     (HL)] one less enemy to kill (43BA)
* pops stack and jumps
* occurs when bird enemy is shot
	move.l	(sp)+,a0                        	| [$0ee3: POP     HL] skips immediate caller
	rts               				         	| [$0ee4: POP     HL]
												| [$0ee5: JP      (HL)] what's wrong with using RET??

l_0f00:
	lea	shield_timer_43A6,a0                	| [$0f00: LD      HL,shield_timer_43A6]
	move.b	(a0),d0                         	| [$0f03: LD      A,(HL)]
	cmp.b	#0xC0,d0                         	| [$0f04: CP      $C0]
	jcc	l_0f74                             	| [$0f06: JP      NC,$0F74]
	lea	screen_address_43E2,a0                        	| [$0f09: LD      L,$E2]
	move.b	(a0)+,d3                         	| [$0f0b: LD      D,(HL)]
                           	| [$0f0c: INC     L]
	move.b	(a0),d4                         	| [$0f0d: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	move.b	#2,d1                      	| [$0f0e: LD      BC,$0202]
	move.b	#2,d2                      	| [$0f0e: LD      BC,$0202]
	jbsr	l_0f56                            	| [$0f11: CALL    $0F56]
	bne.b	0f                               	| [...]
	rts                                    	| [$0f14: RET     Z] [...]
0:
	                                    	| [$0f15: NOP]
	                                    	| [$0f16: NOP]
	lea	player_ship_left_x_439E,a0                	| [$0f17: LD      HL,player_ship_left_x_439E]
	move.b	(a0)+,d0                         	| [$0f1a: LD      A,(HL)]
	subq.b	#0x06,d0                        	| [$0f1b: SUB     $06]
	move.b	d0,d1                           	| [$0f1d: LD      B,A]
	                           	| [$0f1e: INC     L]
	move.b	(a0),d2                         	| [$0f1f: LD      C,(HL)]
	lea	bird_data_4B70,a0                	| [$0f20: LD      HL,bird_data_4B70]
l_0f23:
	move.b	(a0),d0                         	| [$0f23: LD      A,(HL)]
	addq.w	#2,a0                           	| [$0f24: INC     L]
	and.b	#0x08,d0                         	| [$0f26: AND     $08]
	beq.b	0f                               	| [...]
	jbsr	l_0f38                            	| [$0f28: CALL    NZ,$0F38]
0:
	addq.w	#2,a0                           	| [$0f2b: INC     L]
	cmp.l	#bird_data_4B70+0xB0-0x70,a0                        	| [$0f2d: LD      A,$B0]
	                            	| [$0f2f: CP      L]
	jne	l_0f23                             	| [$0f30: JP      NZ,$0F23]
	rts                                    	| [$0f33: RET]
l_0f38:
	                           	| [$0f38: INC     L]
 	move.b	(1,a0),d0                         	| [$0f39: LD      A,(HL)]
												| [$0f3a: DEC     L]
	cmp.b	#0xD2,d0                         	| [$0f3b: CP      $D2]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0f3d: RET     C] [...]
0:
	cmp.b	#0xE7,d0                         	| [$0f3e: CP      $E7]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0f40: RET     NC] [...]
0:
	move.b	(a0),d0                         	| [$0f41: LD      A,(HL)]
	cmp.b	d2,d0                            	| [$0f42: CP      C]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0f43: RET     NC] [...]
0:
	cmp.b	d1,d0                            	| [$0f44: CP      B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0f45: RET     C] [...]
0:
	jbsr	player_hit_0cc4                            	| [$0f46: CALL    $0CC4]
	move.b	#0x0D,d3
	move.b	#0x04,d4                      	| [$0f49: LD      DE,$0D04]
	subq.w	#2,a0                           	| [$0f4c: DEC     HL] * 2
	jra	l_0ead                             	| [$0f4e: JP      $0EAD]

	DECL_ADDRESS	0f56
	
l_0f56:
	movem.w	d1/d2,-(sp)                    	| [$0f56: PUSH    BC]
	movem.w	d3/d4,-(sp)                    	| [$0f57: PUSH    DE]
l_0f58:
	move.w	d3,d7                         	| [$0f58: LD      A,(DE)]
	bsr	read_ram
	cmp.b	#0x60,d0                         	| [$0f59: CP      $60]
	jcs	l_0f63                             	| [$0f5b: JP      C,$0F63]
	cmp.b	#0xC0,d0                         	| [$0f5e: CP      $C0]
	jcs	l_0cf4                             	| [$0f60: JP      C,$0CF4]
l_0f63:
	addq.w	#1,d3                           	| [$0f63: INC     DE]
	subq.b	#1,d1                           	| [$0f64: DEC     B]
	jne	l_0f58                             	| [$0f65: JP      NZ,$0F58]
	movem.w	(sp)+,d3/d4                    	| [$0f68: POP     DE]
	movem.w	(sp)+,d1/d2                    	| [$0f69: POP     BC]
	jbsr	SubtractOneRow_0217               	| [$0f6a: CALL    SubtractOneRow_0217]
	subq.b	#1,d2                           	| [$0f6d: DEC     C]
	jne	l_0f56                             	| [$0f6e: JP      NZ,$0F56]
	rts                                    	| [$0f71: RET]

	DECL_ADDRESS	0f74

l_0f74:
	lea	screen_address_43E2,a0                        	| [$0f74: LD      L,$E2]
	move.b	(a0)+,d3                         	| [$0f76: LD      D,(HL)]
												| [$0f77: INC     L]
	move.b	(a0),d4                         	| [$0f78: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
											| [$0f79: CALL    SubtractOneRow_0217]
	sub.w	#0x21,d3                           	| [$0f7c: DEC     DE]
	move.b	#0x04,d1
	move.b	#0x04,d2                      	| [$0f7d: LD      BC,$0404]
	jbsr	l_0f56                            	| [$0f80: CALL    $0F56]
	bne.b	0f                               	| [...]
	rts                                    	| [$0f83: RET     Z] [...]
0:
	move.b	player_ship_x_43C2,d0           	| [$0f86: LD      A,(player_ship_x_43C2)]
	sub.b	#0x0E,d0                         	| [$0f89: SUB     $0E]
	move.b	d0,d1                           	| [$0f8b: LD      B,A]
	add.b	#0x2D,d0                         	| [$0f8c: ADD     $2D]
	move.b	d0,d2                           	| [$0f8e: LD      C,A]
	lea	bird_data_4B70,a0                	| [$0f8f: LD      HL,bird_data_4B70]
l_0f92:
	move.b	(a0),d0                         	| [$0f92: LD      A,(HL)]
	addq.w	#2,a0                           	| [$0f93: INC     L]
	and.b	#0x08,d0                         	| [$0f95: AND     $08]
	beq.b	0f                               	| [...]
	jbsr	l_0fa6                            	| [$0f97: CALL    NZ,$0FA6]
0:
	addq.w	#2,a0                           	| [$0f9a: INC     L]
										| [$0f9c: LD      A,$B0]
	cmp.l	#unknown_4BB0,a0                            	| [$0f9e: CP      L]
	jne	l_0f92                             	| [$0f9f: JP      NZ,$0F92]
	rts                                    	| [$0fa2: RET]
l_0fa6:
	                           	| [$0fa6: INC     L]
	move.b	(1,a0),d0                         	| [$0fa7: LD      A,(HL)]
	                           	| [$0fa8: DEC     L]
	cmp.b	#0xCA,d0                         	| [$0fa9: CP      $CA]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0fab: RET     C] [...]
0:
	cmp.b	#0xEF,d0                         	| [$0fac: CP      $EF]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0fae: RET     NC] [...]
0:
	move.b	(a0),d0                         	| [$0faf: LD      A,(HL)]
	cmp.b	d2,d0                            	| [$0fb0: CP      C]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0fb1: RET     NC] [...]
0:
	cmp.b	d1,d0                            	| [$0fb2: CP      B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0fb3: RET     C] [...]
0:
	move.b	#0x0D,d3
	move.b	#0x02,d4                      	| [$0fb4: LD      DE,$0D02]
	subq.w	#2,a0                           	| [$0fb7: DEC     HL] * 2
	jra	l_0ead                             	| [$0fb9: JP      $0EAD]

	DECL_ADDRESS	0fc0

l_0fc0:
	lea	slot_for_regular_animation_4370,a0                	| [$0fc0: LD      HL,slot_for_regular_animation_4370]
	jbsr	l_0fd8                            	| [$0fc3: CALL    $0FD8]
	lea	slot_for_animation_4374,a0                	| [$0fc6: LD      HL,slot_for_animation_4374]
	jbsr	l_0fd8                            	| [$0fc9: CALL    $0FD8]
	lea	slot_for_special_animation_4378,a0                	| [$0fcc: LD      HL,slot_for_special_animation_4378]
	jbsr	l_3758                            	| [$0fcf: CALL    $3758]
	lea	slot_for_special_animation_437C,a0                	| [$0fd2: LD      HL,slot_for_special_animation_437C]
	jra	l_3758                             	| [$0fd5: JP      $3758]
l_0fd8:
	move.b	(a0),d0                         	| [$0fd8: LD      A,(HL)]
	                               	| [$0fd9: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$0fda: RET     Z] [...]
0:
	move.b	(a0),d1                         	| [$0fdb: LD      B,(HL)]
	subq.b	#1,(a0)                         	| [$0fdc: DEC     (HL)] decrease animation frame counter
	addq.w	#2,a0                           	| [$0fdd: INC     L] * 2
	move.b	(a0)+,d3                         	| [$0fdf: LD      D,(HL)]
	                           	| [$0fe0: INC     L]
	move.b	(a0),d4                         	| [$0fe1: LD      E,(HL)]
                                    	| [$0fe2: NOP]
	LOAD_D3_16_FROM_D3D4
	jbsr	AddOneRow_0210                    	| [$0fe3: CALL    AddOneRow_0210]
	move.b	d1,d0                           	| [$0fe6: LD      A,B]
	and.b	#0x0E,d0                         	| [$0fe7: AND     $0E]
	ror.b	#1,d0                            	| [$0fe9: RRCA]
	add.b	#0xB0,d0                         	| [$0fea: ADD     $B0]
	moveq	#0,d6
	move.b	d0,d6                           	| [$0fec: LD      L,A]
	lea		game_rom+0x1700,a0
	add.w	d6,a0
	                        	| [$0fed: LD      H,$17]
	move.b	(a0),d6                         	| [$0fef: LD      L,(HL)]
	* re-apply offset we just read
	lea		game_rom+0x1700,a0
	add.w	d6,a0

	exg	a1,a0                              	| [$0ff0: EX      DE,HL]
	move.w	d3,d7		| screen dest address
	                      	| [$0ff1: LD      BC,$FFDF]
	move.w	#0xFFDF,d1
	
	jra	copy_3_columns_to_screen_3540                             	| [$0ff4: JP      $3540]
	
	DECL_ADDRESS	14e0

l_14e0:
	
	move.b	d0,d1                           	| [$14e0: LD      B,A]
	jbsr	osd_read_dipswitches                       	| [$14e1: LD      A,($7800)] 78xx DSW0
	and.b	#0x10,d0                         	| [$14e4: AND     $10] Coinage
	bne.b	0f                               	| [...]
	rts                                    	| [$14e6: RET     Z] [...]
0:
* coinage settings, not interesting for us, skip it
* (not called with default dipswitch settings)
	rts
	exg	a1,a0                              	| [$14e7: EX      DE,HL]
	move.b	d3,d0                           	| [$14e8: LD      A,D]
	cmp.b	#0x18,d0                         	| [$14e9: CP      $18]
	beq.b	0f                               	| [...]
	rts                                    	| [$14eb: RET     NZ] [...]
0:
	move.b	d4,d0                           	| [$14ec: LD      A,E]
	move.b	#0x22,(a0)                      	| [$14ef: LD      (HL),$22]
	cmp.b	#0x95,d0                         	| [$14ed: CP      $95]
	bne.b	0f                               	| [...]
	rts                                    	| [$14f1: RET     Z] [...]
0:
	move.b	#0x13,(a0)                      	| [$14f4: LD      (HL),$13]
	cmp.b	#0x9A,d0                         	| [$14f2: CP      $9A]
	bne.b	0f                               	| [...]
	rts                                    	| [$14f6: RET     Z] [...]
0:
	move.b	#0x24,(a0)                      	| [$14f9: LD      (HL),$24]
	cmp.b	#0xB5,d0                         	| [$14f7: CP      $B5]
	bne.b	0f                               	| [...]
	rts                                    	| [$14fb: RET     Z] [...]
0:
	move.b	d1,(a0)                         	| [$14fc: LD      (HL),B]
	rts                                    	| [$14fd: RET]

l_17e0:
	jbsr	osd_read_dipswitches                       	| [$17e0: LD      A,($7800)] 78xx DSW0
	and.b	#0x10,d0                         	| [$17e3: AND     $10] Coinage
	bne.b	0f                               	| [...]
	move.b	CoinCount_438F,d0                    	| [$17e5: LD      A,(CoinCount_438F)]
	rts                                    	| [$17e8: RET     Z] [...]
0:
	move.b	CoinCount_438F,d0                    	| [$17e5: LD      A,(CoinCount_438F)]
	ror.b	#1,d0                            	| [$17e9: RRCA]
	and.b	#0x0F,d0                         	| [$17ea: AND     $0F]
	rts                                    	| [$17ec: RET]




l_1ee0:
	move.w	#0x433D,d3                	| [$1ee0: LD      DE,unknown_433D]
	moveq	#0x00,d1                      	| [$1ee3: LD      BC,$001A] 26
	moveq	#0x1A,d2                      	| [$1ee3: LD      BC,$001A] 26
l_1ee6:
	move.w	d3,d7
	jbsr	read_ram                         	| [$1ee6: LD      A,(DE)]
	add.b	d1,d0                            	| [$1ee7: ADD     A,B]
	move.b	d0,d1                           	| [$1ee8: LD      B,A]
	jbsr	SubtractOneRow_0217               	| [$1ee9: CALL    SubtractOneRow_0217]
	subq.b	#1,d2                           	| [$1eec: DEC     C]
	jne	l_1ee6                             	| [$1eed: JP      NZ,$1EE6]
	move.w	d3,d7
	cmp.w	#0x3FFD,d7
	beq.b	0f
	jbsr	read_ram                         	| [$1ef0: LD      A,(DE)]
	bra.b	1f
0:
	* probably gone too low, now reading from ROM??
	move.b	#0xB8,d0	| what's in 3FFD now
1:
	add.b	d1,d0                            	| [$1ef1: ADD     A,B]
	add.b	#0x27,d0                         	| [$1ef2: ADD     $27]
	lea	unknown_4389,a0                	| [$1ef4: LD      HL,unknown_4389]
	add.b	(a0),d0                          	| [$1ef7: ADD     A,(HL)]
	move.b	d0,(a0)                         	| [$1ef8: LD      (HL),A]
	                                    	| [$1ef9: NOP]
	rts                                    	| [$1efa: RET]

birds_level_2000:
	jbsr	common_game_routines_0876                            	| [$2000: CALL    $0876]
	jbsr	player_shots_vs_birds_collision_0DF0	| [$2003: CALL    player_shots_vs_birds_collision_0DF0]
	jbsr	mothership_shot_collision_24a0                            	| [$2006: CALL    $24A0]
	lea	unknown_435F,a0                	| [$2009: LD      HL,unknown_435F]
	move.b	(a0),d0                         	| [$200c: LD      A,(HL)]
	and.b	#0x03,d0                         	| [$200d: AND     $03]
	move.b	d0,d1                           	| [$200f: LD      B,A]
	addq.b	#1,(a0)                         	| [$2010: INC     (HL)]
	move.b	nb_birds_to_kill_before_stage_completed_43BA,d0	| [$2011: LD      A,(nb_birds_to_kill_before_stage_completed_43BA)]
	                               	| [$2014: AND     A]
	jeq	l_21ba                             	| [$2015: JP      Z,$21BA]
	cmp.b	#0x05,d0                         	| [$2018: CP      $05]
	jcc	l_2130                             	| [$201a: JP      NC,$2130]
	subq.w	#1,a0                           	| [$201d: DEC     L]
	move.b	d1,d0                           	| [$201e: LD      A,B]
	                               	| [$201f: AND     A]
	jne	l_2025                             	| [$2020: JP      NZ,$2025]
	st	(a0)                      	| [$2023: LD      (HL),$FF]
l_2025:
	move.b	(a0),d0                         	| [$2025: LD      A,(HL)]
	                               	| [$2026: AND     A]
	jeq	l_2130                             	| [$2027: JP      Z,$2130]
	jra	l_2146                             	| [$202a: JP      $2146]


l_2030:
	move.b	d1,d0                           	| [$23a1: LD      A,B]
	and.b	#0x03,d0                         	| [$2030: AND     $03]
	lea	game_rom+0x1B50,a1                      	| [$2034: LD      DE,$1B50]
	cmp.b	#0x01,d0                         	| [$2032: CP      $01]
	jra	l_23ac                             	| [$2037: JP      $23AC]

l_2040:
	lea	unknown_43AF,a0                	| [$2040: LD      HL,unknown_43AF]
	move.b	current_scroll_value_43B9,d0    	| [$2043: LD      A,(current_scroll_value_43B9)]
	move.b	d0,d2                           	| [$2046: LD      C,A]
	cmp.b	(a0),d0                          	| [$2047: CP      (HL)]
	beq.b	0f                               	| [...]
	rts                                    	| [$2048: RET     NZ] [...]
0:
	move.b	(a0)+,d0                         	| [$2049: LD      A,(HL)]
	                           	| [$204a: INC     L]
	sub.b	(a0),d0                          	| [$204b: SUB     (HL)]
	                           	| [$204c: DEC     L]
	move.b	d0,-(a0)                         	| [$204d: LD      (HL),A]
	addq.w	#2,a0                           	| [$204e: INC     L] * 2
 	addq.b	#1,(a0)                         	| [$2050: INC     (HL)]
	move.b	(a0),d0                         	| [$2051: LD      A,(HL)]
	lea	game_rom+0x1E80,a0                      	| [$2052: LD      HL,$1E80]
	and.w	#0x1F,d0                         	| [$2055: AND     $1F]
	add.w	d0,a0                            	| [$2057: ADD     A,L]
										| [$2058: LD      L,A]
	move.b	(a0),d1                         	| [$2059: LD      B,(HL)]
	add.b	#0x20,d0                         	| [$205a: ADD     $20]
	lea	game_rom+0x1E00,a0                      | [$2052: LD      HL,$1E80]
	add.w	d0,a0                           	| [$205c: LD      L,A]
	move.b	(a0),d3                         	| [$205d: LD      D,(HL)]
	add.w	#0x20,a0                         	| [$205e: ADD     $20]
											| [$2060: LD      L,A]
	move.b	(a0),d4                         	| [$2061: LD      E,(HL)]
	move.b	d2,d0                           	| [$2062: LD      A,C]
	ror.b	#3,d0                            	| [$2063: RRCA] * 3
	and.b	#0x1F,d0                         	| [$2066: AND     $1F]
	add.b	d4,d0                            	| [$2068: ADD     A,E]
	addq.b	#1,d0                           	| [$2069: INC     A]
	move.b	d0,d4                           	| [$206a: LD      E,A]
	move.b	d1,d0                           	| [$206b: LD      A,B]
	bsr		load_ram_in_a1_from_d3d4
	move.b	d0,(a1)                         	| [$206c: LD      (DE),A]
	rts                                    	| [$206d: RET]
	       
                             	| [$206e: RET]
	DECL_ADDRESS	2070
	
l_2070:
	move.b	d4,d0                           	| [$2070: LD      A,E]
	sub.b	#0x0A,d0                         	| [$2071: SUB     $0A]
	add.b	#0xC0,d0                         	| [$2073: ADD     $C0]
	move.b	d0,d2                           	| [$2075: LD      C,A]
	move.b	d3,d0                           	| [$2076: LD      A,D]
	moveq	#0,d7                        	| [$2077: ADC     $00]
	addx.b	d7,d0                           	| [$2077: ADC     $00]
 	move.b	d0,d1                           	| [$2079: LD      B,A]
	move.b	(a0),d0                         	| [$207a: LD      A,(HL)]
	* those are rom addresses, aligned to 0x100 boundary
	* game does some computations with lsb, better leave them as virtual addresses
	* until data is actually read!
	move.w	#0x2800,d3                      	| [$207b: LD      DE,$2800]
	move.w	#0x2900,d6                      	| [$207e: LD      HL,$2900]
	                             	| [$2081: JP      $2085]
l_2085:
	* TODO fix issue with explosion D1/D2 vs D1.W
	LOAD_D1_16_FROM_D1D2
	sub.b	#0x20,d0                         	| [$2085: SUB     $20]
	rol.b	#2,d0                            	| [$2087: RLCA] * 2
	                                    	| [$2089: NOP]
	and.b	#0xE0,d0                         	| [$208a: AND     $E0]
	move.b	d0,d6                           	| [$208c: LD      L,A]
	move.b	#0xE0,d0                        	| [$208d: LD      A,$E0]
	sub.b	d6,d0                            	| [$208f: SUB     L]
	move.b	d0,d6                           	| [$2090: LD      L,A]
l_2091:
	move.b	#0x3F,d0                        	| [$2091: LD      A,$3F]
	sub.b	d2,d0                            	| [$2093: SUB     C]
	move.b	#0x43,d0                        	| [$2094: LD      A,$43]
	subx.b	d1,d0                           	| [$2096: SBC     B]
	jcc	player_exploding_20b0                             	| [$2097: JP      NC,$20B0]
	addq.w	#2,d6                           	| [$209a: INC     HL] * 2
	                           	| [$209c: LD      A,E]
	add.b	#0x10,d3                         	| [$209d: ADD     $10]
	                           	| [$209f: LD      E,A]
	                          	| [$20a0: LD      A,C]
	sub.w	#0x20,d1                         	| [$20a1: SUB     $20]
	                           	| [$20a3: LD      C,A]
	                           	| [$20a4: LD      A,B]
		
								| [$20a5: SBC     $00]
	                           	| [$20a7: LD      B,A]
	jra	l_2091                             	| [$20a8: JP      $2091]

	DECL_ADDRESS	20b0
	
	.macro	EX_HL_SP
	move.w	(sp),d7
	exg		d6,d7
	move.w	d7,(sp)
	.endm
	
player_exploding_20b0:
	* the routine swaps registers with the stack
	* contents. It's meant to update d1/d2 (BC) on exit
	move.w	d1,-(sp)                    	| [$20b0: PUSH    BC]
	* D1/D2 holds a ROM address. We're going to copy it in D7
	LOAD_D1_16_FROM_D1D2
	move.w	d1,d7		| d7 is d1+d2 now
l_20b1:
	bsr		load_rom_in_a0_from_d6w
	move.b	(a0),d0                         	| [$20b1: LD      A,(HL)]
	EX_HL_SP                            	| [$20b2: EX      (SP),HL]
	move.b	#0x08,d1                        	| [$20b3: LD      B,$08]
l_20b5:
	cmp.w	#RAM_START,d6
	bcs.b	0f
	move.w	d6,d7
	exg		d5,d0                             	| [$20b5: LD      (HL),$00]
	moveq	#0,d0
	jbsr	osd_w_videoram
	exg		d5,d0
0:
	ror.b	#1,d0                            	| [$20b7: RRCA]
	jcc	l_20bf                             	| [$20b8: JP      NC,$20BF]
	exg	d3,d6                              	| [$20bb: EX      DE,HL]
	bsr		load_rom_in_a0_from_d6w
	move.b	(a0),d2                         	| [$20bc: LD      C,(HL)]
	exg	d3,d6                              	| [$20bd: EX      DE,HL]
	
	move.w	d6,d7
	move.b	d2,d0
	jbsr	osd_w_videoram					| [$20be: LD      (HL),C]

l_20bf:
	addq.w	#1,d6                           	| [$20bf: INC     HL]
	addq.w	#1,d3                           	| [$20c0: INC     DE]
	subq.b	#1,d1                           	| [$20c1: DEC     B]
	jne	l_20b5                             	| [$20c2: JP      NZ,$20B5]
	EX_HL_SP                            	| [$20c5: EX      (SP),HL]
	addq.w	#1,d6                           	| [$20c6: INC     HL]
	move.b	d6,d0                           	| [$20c7: LD      A,L]
	ror.b	#1,d0                            	| [$20c8: RRCA]
	jcs	l_20b1                             	| [$20c9: JP      C,$20B1]
	move.b	d6,d0                           	| [$20cc: LD      A,L]
	and.b	#0x1F,d0                         	| [$20cd: AND     $1F]
	jeq	l_20e1                             	| [$20cf: JP      Z,$20E1] aligned
	EX_HL_SP                            	| [$20d2: EX      (SP),HL]
	                           	| [$20d3: LD      A,L]
	sub.w	#0x30,d6                         	| [$20d4: SUB     $30]
											| [$20d6: LD      L,A]
											| [$20d7: LD      A,H]
											| [$20d8: SBC     $00]
											| [$20da: LD      H,A]
	EX_HL_SP                            	| [$20db: EX      (SP),HL]
	cmp.b	#0x3F,d0                         	| [$20dc: CP      $3F]
	jne	l_20b1                             	| [$20de: JP      NZ,$20B1]
l_20e1:
	move.w	(sp)+,d1                    	| [$20e1: POP     BC]
	rts                                    	| [$20e2: RET]

	DECL_ADDRESS	20e8
	
l_20e8_2:
	move.b	d1,d0                           	| [$2411: LD      A,B]

l_20e8:
	move.b	d0,d1                           	| [$20e8: LD      B,A]
	move.b	d3,d0                           	| [$20e9: LD      A,D]
	add.b	#0x08,d0                         	| [$20ea: ADD     $08]
	move.b	d0,d3                           	| [$20ec: LD      D,A]
	jbsr	wrap_scroll_value_211C                            	| [$20ed: CALL    $211C]
	ror.b	#3,d0                            	| [$20f0: RRCA] * 3
	add.b	d4,d0                            	| [$20f3: ADD     A,E]
	and.b	#0x1F,d0                         	| [$20f4: AND     $1F]
	move.b	d0,d2                           	| [$20f6: LD      C,A]
	move.b	d4,d0                           	| [$20f7: LD      A,E]
	and.b	#0xE0,d0                         	| [$20f8: AND     $E0]
	or.b	d2,d0                             	| [$20fa: OR      C]
	move.b	d0,d4                           	| [$20fb: LD      E,A]
	move.b	d1,d0                           	| [$20fc: LD      A,B]
	ror.b	#2,d0                            	| [$20fd: RRCA] * 2
	and.b	#0x0E,d0                         	| [$20ff: AND     $0E]
	add.b	#0x90,d0                         	| [$2101: ADD     $90]
	move.b	d0,d6                           	| [$2103: LD      L,A]
	move.b	#0x1B,d5                        	| [$2104: LD      H,$1B]
	jbsr	load_rom_in_a0_from_d5d6
	move.b	(a0)+,d0                         	| [$2106: LD      A,(HL)]
	                           	| [$2107: INC     L]
 	move.b	(a0),d6                         	| [$2108: LD      L,(HL)]
	move.b	d0,d5                           	| [$2109: LD      H,A]
	LOAD_D3_16_FROM_D3D4
	bsr		load_rom_in_a0_from_d5d6
	move.w	#0x04,d1
	move.w	#0x04,d2                      	| [$210a: LD      BC,$0404]
	jra	copy_block_to_screen_0ad6                             	| [$210d: JP      $0AD6]

	DECL_ADDRESS	211c
	
wrap_scroll_value_211C:
	lea	current_scroll_value_43B9,a0   	| [$211c: LD      HL,current_scroll_value_43B9]
	move.b	(a0),d0                         	| [$211f: LD      A,(HL)]
	cmp.b	#0x10,d0                         	| [$2120: CP      $10]
	bcc.b	0f                               	| [...]
	rts                                    	| [$2122: RET     C] [...]
0:
	cmp.b	#0x30,d0                         	| [$2123: CP      $30]
	bcs.b	0f                               	| [...]
	rts                                    	| [$2125: RET     NC] [...]
0:
	move.b	#0x10,d0                        	| [$2126: LD      A,$10]
	move.b	d0,(a0)                         	| [$2128: LD      (HL),A]
	jbsr	osd_set_scroll_value                       	| [$2129: LD      ($5800),A] 58xx scroll register
 	rts                                    	| [$212c: RET]

l_2130:
	move.b	d1,d0                           	| [$2130: LD      A,B]
	                               	| [$2131: AND     A]
	jeq	l_2150                             	| [$2132: JP      Z,$2150]
	cmp.b	#0x01,d0                         	| [$2135: CP      $01]
	jeq	l_2160                             	| [$2137: JP      Z,$2160]
	cmp.b	#0x02,d0                         	| [$213a: CP      $02]
	jeq	l_2170                             	| [$213c: JP      Z,$2170]
	jra	l_2180                             	| [$213f: JP      $2180]
											| [$2142: SUB     B]
											| [$2143: AND     L]
										| [$2144: LD      D,B]
										| [$2145: LD      H,B]
l_2146:
	move.b	d1,d0                           	| [$2146: LD      A,B]
	ror.b	#1,d0                            	| [$2147: RRCA]
	jcc	l_2190                             	| [$2148: JP      NC,$2190]
	jra	l_21a5                             	| [$214b: JP      $21A5]
	bmi.b	0f                               	| [...]
	rts                                    	| [$214e: RET     P] [...]
0:
	illegal		| doesn't seem reached

l_2150:
	jbsr	birds_stuff_0a50                            	| [$2150: CALL    $0A50]
	jbsr	handle_small_birds_attacks_3000                            	| [$2153: CALL    $3000]
	jra	l_0f00                             	| [$2156: JP      $0F00]

l_2160:
	jbsr	animate_mothership_24c4                            	| [$2160: CALL    $24C4]
	jbsr	l_0c40                            	| [$2163: CALL    $0C40]
	jbsr	l_0d1c                            	| [$2166: CALL    $0D1C]
	jra	l_0fc0                             	| [$2169: JP      $0FC0]

l_2170:
	jbsr	l_0d70                            	| [$2170: CALL    $0D70]
	jra	l_2560                             	| [$2173: JP      $2560]

l_2180:
	jbsr	animate_mothership_24c4                            	| [$2180: CALL    $24C4]
	jbsr	l_0c40                            	| [$2183: CALL    $0C40]
	jbsr	draw_birds_0a6c                            	| [$2186: CALL    $0A6C]
	jra	l_0fc0                             	| [$2189: JP      $0FC0]

l_2190:
	jbsr	birds_stuff_0a50                            	| [$2190: CALL    $0A50]
	jbsr	handle_small_birds_attacks_3000                            	| [$2193: CALL    $3000]
	jbsr	l_0f00                            	| [$2196: CALL    $0F00]
	jbsr	l_2560                            	| [$2199: CALL    $2560]
	jra	l_0c40                             	| [$219c: JP      $0C40]

l_21a5:
	jbsr	l_0d1c                            	| [$21a5: CALL    $0D1C]
	jbsr	l_0d70                            	| [$21a8: CALL    $0D70]
	jbsr	draw_birds_0a6c                            	| [$21ab: CALL    $0A6C]
	jbsr	l_0fc0                            	| [$21ae: CALL    $0FC0]
	jra	animate_mothership_24c4                             	| [$21b1: JP      $24C4]

l_21ba:
	move.b	d1,d0                           	| [$21ba: LD      A,B]
	ror.b	#1,d0                            	| [$21bb: RRCA]
	jcc	l_2204                             	| [$21bc: JP      NC,$2204]
	jbsr	l_0c40                            	| [$21bf: CALL    $0C40]
	jbsr	l_0fc0                            	| [$21c2: CALL    $0FC0]
	jbsr	animate_mothership_24c4                            	| [$21c5: CALL    $24C4]
	move.b	current_stage_43B8,d0           	| [$21c8: LD      A,(current_stage_43B8)]
	and.b	#0x0F,d0                         	| [$21cb: AND     $0F]
	cmp.b	#0x0B,d0                         	| [$21cd: CP      $0B]
	jcs	l_2204                             	| [$21cf: JP      C,$2204]
	move.b	#0x10,d0                        	| [$21d2: LD      A,$10]
	move.b	d0,nb_birds_to_kill_before_stage_completed_43BA	| [$21d4: LD      (nb_birds_to_kill_before_stage_completed_43BA),A]
	jra	l_0526                             	| [$21d7: JP      $0526]
	
	* vulture appearing from a star, flying and disappearing into a star
	* during title sequence
	*

animate_title_vulture_21dc:
	move.b	(a0),d0                         	| [$21dc: LD      A,(HL)]
	                                    	| [$21dd: NOP]
	move.b	d0,d1                           	| [$21de: LD      B,A]
	lea	title_vulture_struct_4B73,a0                	| [$21df: LD      HL,title_vulture_struct_4B73]
	and.b	#0x07,d0                         	| [$21e2: AND     $07]
	move.b	d0,(a0)                         	| [$21e4: LD      (HL),A] animation frame
	* push coordinates
	                           	| [$21e5: DEC     L]
	move.b	#0xEF,-(a0)                      	| [$21e6: LD      (HL),$EF]
	                           	| [$21e8: DEC     L]
	move.b	#0x49,-(a0)                      	| [$21e9: LD      (HL),$49]
	                           	| [$21eb: DEC     L]
 	move.b	d1,d0                           	| [$21ec: LD      A,B]
	and.b	#0xF8,d0                         	| [$21ed: AND     $F8]
	ror.b	#3,d0                            	| [$21ef: RRCA] * 3
	add.b	#0x3A,d0                         	| [$21f2: ADD     $3A]
	move.b	d0,d4                           	| [$21f4: LD      E,A]
	move.b	#0x23,d3                        	| [$21f5: LD      D,$23]
	bsr		load_rom_in_a1_from_d3d4
	move.b	(a1),d0                         	| [$21f7: LD      A,(DE)]
	* push current state: 7: full blown vulture
	move.b	d0,-(a0)                         	| [$21f8: LD      (HL),A]
	jbsr	animate_vulture_34c0                            	| [$21f9: CALL    $34C0]
	jra	l_1ee0                             	| [$21fc: JP      $1EE0]

l_2204:
	lea	unknown_43B6,a0                	| [$2204: LD      HL,unknown_43B6]
	subq.b	#1,(a0)                         	| [$2207: DEC     (HL)]
	move.b	(a0),d0                         	| [$2208: LD      A,(HL)]
	cmp.b	#0xA0,d0                         	| [$2209: CP      $A0]
	bcs.b	0f                               	| [...]
	rts                                    	| [$220b: RET     NC] [...]
0:
	lea	game_state_43A4,a0                        	| [$220c: LD      L,$A4]
	move.b	#STATE_INIT_NEW_PLAY_STEP_2,(a0)                      	| [$220e: LD      (HL),$02]
	lea	shield_timer_43A6,a0                        	| [$2210: LD      L,$A6]
	clr.b	(a0)                             	| [$2212: LD      (HL),$00]
	lea	current_stage_43B8,a0                        	| [$2214: LD      L,$B8]
	addq.b	#1,(a0)                         	| [$2216: INC     (HL)]
	move.b	(a0),d0                         	| [$2217: LD      A,(HL)]
	and.b	#0x0E,d0                         	| [$2218: AND     $0E]
	ror.b	#1,d0                            	| [$221a: RRCA]
	add.b	#0x60,d0                         	| [$221b: ADD     $60]
	move.b	d0,d4                           	| [$221d: LD      E,A]
	move.b	#0x17,d3                        	| [$221e: LD      D,$17]
	addq.w	#2,a0                           	| [$2220: INC     L]
	bsr		load_rom_in_a1_from_d3d4
	move.b	(a1),d0                         	| [$2222: LD      A,(DE)]
	                               	| [$2223: AND     A]
	jpl	l_222a                             	| [$2224: JP      P,$222A]
	addq.w	#1,a0                           	| [$2227: INC     L]
	and.b	#0x7F,d0                         	| [$2228: AND     $7F]
l_222a:
	move.b	d0,(a0)                         	| [$222a: LD      (HL),A]
	jra	clear_foreground_tiles_0380                             	| [$222b: JP      $0380]

* screen fills with stars to announce vultures
transition_to_vultures_and_last_level_2230:
	lea	unknown_439C,a0                	| [$2230: LD      HL,unknown_439C]
	move.b	(a0),d0                         	| [$2233: LD      A,(HL)]
	addq.b	#1,(a0)                         	| [$2234: INC     (HL)]
	                                    	| [$2235: NOP]
	ror.b	#1,d0                            	| [$2236: RRCA]
	and.b	#0x3F,d0                         	| [$2237: AND     $3F]
	cmp.b	#0x0D,d0                         	| [$2239: CP      $0D]
	jeq	setup_boss_background_sceen_2292                             	| [$223b: JP      Z,$2292]
	jcs	fill_screen_2260_1                             	| [$2240: JP      C,$2260]
	clr.b	d1                               	| [$2243: LD      B,$00]
	sub.b	#0x0E,d0                         	| [$2245: SUB     $0E]
	cmp.b	#0x0D,d0                         	| [$2247: CP      $0D]
	jne	fill_screen_2260                             	| [$2249: JP      NZ,$2260]

l_224c:
	lea	current_stage_43B8,a0          	| [$224c: LD      HL,current_stage_43B8]
	addq.b	#1,(a0)                         	| [$224f: INC     (HL)]
	lea	game_state_43A4,a0                        	| [$2250: LD      L,$A4]
	move.b	#STATE_INIT_NEW_PLAY_STEP_2,(a0)                      	| [$2252: LD      (HL),$02]
	rts                                    	| [$2254: RET]
		| [$2255: LD      E,B]
	      	| [$2256: LD      L,$A4]
	                      	| [$2258: LD      (HL),$02]
	| [$225a: RET]

* used for star transitions
fill_screen_2260_1:
	move.b	#0x1F,d1                        	| [$223e: LD      B,$1F] with stars please

fill_screen_2260:
	move.b	d0,d2                           	| [$2260: LD      C,A]
	ror.b	#3,d0                            	| [$2261: RRCA] * 3
	move.b	d0,d3                           	| [$2264: LD      D,A]
	and.b	#0x1F,d0                         	| [$2265: AND     $1F]
	move.b	d0,d4                           	| [$2267: LD      E,A]
	move.b	d3,d0                           	| [$2268: LD      A,D]
	and.b	#0xE0,d0                         	| [$2269: AND     $E0]
	add.b	#0xB0,d0                         	| [$226b: ADD     $B0]
	move.b	d0,d6                           	| [$226d: LD      L,A]
	move.b	d4,d0                           	| [$226e: LD      A,E]
	move.b	#0x41,d7
	addx.b	d7,d0                           	| [$226f: ADC     $41]
	move.b	d0,d5                           	| [$2271: LD      H,A]
	move.b	d6,d0                           	| [$2272: LD      A,L]
	sub.b	d2,d0                            	| [$2273: SUB     C]
	move.b	d0,d6                           	| [$2274: LD      L,A]
	move.b	d2,d0                           	| [$2275: LD      A,C]
	addq.b	#1,d0                           	| [$2276: INC     A]
	move.b	d0,d2                           	| [$2277: LD      C,A]
	rol.b	#1,d0                            	| [$2278: RLCA]
	move.b	d0,d4                           	| [$2279: LD      E,A]
l_227a:
	move.b	d2,d3                           	| [$227a: LD      D,C]	
	LOAD_D5_16_FROM_D5D6
	move.w	d5,d7
	move.b	d1,d0
l_227b:
	jbsr	osd_w_videoram                         	| [$227b: LD      (HL),B]
	addq.w	#1,d7                           	| [$227c: INC     HL]
	jbsr	osd_w_videoram                         	| [$227d: LD      (HL),B]
	addq.w	#1,d7                           	| [$227c: INC     HL]
	                           	| [$227e: INC     HL]
	subq.b	#1,d3                           	| [$227f: DEC     D]
	jne	l_227b                             	| [$2280: JP      NZ,$227B]
	move.w	d7,d5
	LOAD_D5D6_FROM_D5_16
	move.b	d6,d0                           	| [$2283: LD      A,L]
	sub.b	d2,d0                            	| [$2284: SUB     C]
	sub.b	d2,d0                            	| [$2285: SUB     C]
	sub.b	#0x20,d0                         	| [$2286: SUB     $20]
	move.b	d0,d6                           	| [$2288: LD      L,A]
	move.b	d5,d0                           	| [$2289: LD      A,H]
	clr		d7
	subx.b	d7,d0                        	| [$228a: SBC     $00]
 	move.b	d0,d5                           	| [$228c: LD      H,A]
	subq.b	#1,d4                           	| [$228d: DEC     E]
 	jne	l_227a                             	| [$228e: JP      NZ,$227A]
	rts                                    	| [$2291: RET]
	
	DECL_ADDRESS	2292
	
setup_boss_background_sceen_2292:
	lea	current_stage_43B8,a0          	| [$2292: LD      HL,current_stage_43B8]
	move.b	(a0),d0                         	| [$2295: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$2296: AND     $08]
	jeq	l_22f0                             	| [$2298: JP      Z,$22F0]
	* boss screen: copy memory
	lea	game_rom+0x1C00,a0                      	| [$229b: LD      HL,$1C00]
	move.w	#0x4B3F,d7                	| [$229e: LD      DE,unknown_4B3F]
	move.b	#0x47,d1                        	| [$22a1: LD      B,$47]
	clr.w	d5
l_22a3:
	move.b	(a0,d5.w),d0                         	| [$22a3: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$22a4: LD      (DE),A]
	                           	| [$22a5: INC     L]
 	subq.w	#1,d7                           	| [$22a6: DEC     DE]
	move.b	(1,a0,d5.w),d0                         	| [$22a7: LD      A,(HL)]
	jbsr	osd_w_videoram                         	| [$22a8: LD      (DE),A]
	                           	| [$22a9: INC     L]
 	subq.w	#1,d7                           	| [$22aa: DEC     DE]
	                           	| [$22ab: LD      A,B]
	addq.b	#2,d5				| we need it to wrap
	move.w	d7,d3
	lsr.w	#8,d3
	cmp.b	d3,d1                            	| [$22ac: CP      D]
	jne	l_22a3                             	| [$22ad: JP      NZ,$22A3]
	jra	l_22e0                             	| [$22b0: JP      $22E0]


mothership_arrives_22B4:
	jbsr	update_scrolling_067A             	| [$22b4: CALL    update_scrolling_067A]
	lea	unknown_43B4,a0                	| [$22b7: LD      HL,unknown_43B4]
	subq.b	#1,(a0)                         	| [$22ba: DEC     (HL)]
	move.b	(a0),d0                         	| [$22bb: LD      A,(HL)]
	cmp.b	#0x28,d0                         	| [$22bc: CP      $28]
	jne	l_0848                             	| [$22be: JP      NZ,$0848]
	lea	unknown_4367,a0                        	| [$22c1: LD      L,$67]
	move.b	#0xFF,(a0)                      	| [$22c3: LD      (HL),$FF]
	rts                                    	| [$22c5: RET]

mothership_level_22CA:
	lea	unknown_43B4,a0                	| [$22ca: LD      HL,unknown_43B4]
	move.b	(a0),d0                         	| [$22cd: LD      A,(HL)]
	cmp.b	#0xC0,d0                         	| [$22ce: CP      $C0]
	jne	transition_to_birds_level_0834     	| [$22d0: JP      NZ,transition_to_birds_level_0834]
	move.b	#0x30,(a0)                      	| [$22d3: LD      (HL),$30]
	lea	unknown_4367,a0                        	| [$22d5: LD      L,$67]
	move.b	#0xFF,(a0)                      	| [$22d7: LD      (HL),$FF]
	lea	unknown_43BC,a0                        	| [$22d9: LD      L,$BC]
	move.b	#0x3F,(a0)                      	| [$22db: LD      (HL),$3F]
	rts                                    	| [$22dd: RET]

l_22e0:
	move.b	#0x71,d0                        	| [$22e0: LD      A,$71]
l_22e2:
	move.b	d0,current_scroll_value_43B9    	| [$22e2: LD      (current_scroll_value_43B9),A]
	jbsr	osd_set_scroll_value                       	| [$22e5: LD      ($5800),A] 58xx scroll register
 	rts                                    	| [$22e8: RET]

l_22f0:
	jbsr	clear_background_tiles_03a0                            	| [$22f0: CALL    $03A0]
	clr.b	d0                               	| [$22f3: XOR     A]
	jra	l_22e2                             	| [$22f4: JP      $22E2]

l_22fa:
	move.w	#0x488A,d7
	bsr		read_ram                 	| [$22ff: LD      A,(unknown_488A)]
	move.w	#0x4AAA,d7                	| [$22fa: LD      HL,unknown_4AAA]
	move.b	#0x12,d1                        	| [$22fd: LD      B,$12]
	move.b	d0,d2                           	| [$2302: LD      C,A]
l_2303:
	move.b	d2,d0                           	| [$2303: LD      A,C]
	and.b	#0x03,d0                         	| [$2304: AND     $03]
	rol.b	#2,d0                            	| [$2306: RLCA] * 2
	move.b	d0,d3                           	| [$2308: LD      D,A]
	jbsr	read_ram
	move.b	d0,d2                         	| [$2309: LD      C,(HL)]
	                           	| [$230a: LD      A,C]
	and.b	#0x0C,d0                         	| [$230b: AND     $0C]
	ror.b	#2,d0                            	| [$230d: RRCA] * 2
	or.b	d3,d0                             	| [$230f: OR      D]
	or.b	#0x60,d0                          	| [$2310: OR      $60]
	jbsr	osd_w_videoram                         	| [$2312: LD      (HL),A]
	                           	| [$2313: LD      A,L]
	sub.w	#0x20,d7                         	| [$2314: SUB     $20]
	                           	| [$2316: LD      L,A]
										| [$2317: JP      NC,$231B]
										| [$231a: DEC     H]
l_231b:
	subq.b	#1,d1                           	| [$231b: DEC     B]
	jne	l_2303                             	| [$231c: JP      NZ,$2303]
	rts                                    	| [$231f: RET]

l_2322:
	lea	unknown_43A7,a0                	| [$2322: LD      HL,unknown_43A7]
	addq.b	#1,(a0)                         	| [$2325: INC     (HL)]
	move.b	(a0),d0                         	| [$2326: LD      A,(HL)]
	and.b	#0x07,d0                         	| [$2327: AND     $07]
	rol.b	#3,d0                            	| [$2329: RLCA] * 3
	add.b	#0xC0,d0                         	| [$232c: ADD     $C0]
	move.b	d0,d6                           	| [$232e: LD      L,A]
	move.b	#0x1B,d5                        	| [$232f: LD      H,$1B]
	bsr		load_rom_in_a0_from_d5d6
	move.w	#0x49A6,d3                	| [$2331: LD      DE,unknown_49A6]
	move.w	#0x04,d1
	move.w	#0x02,d2                      	| [$2334: LD      BC,$0402]
	jra	copy_block_to_screen_0ad6                             	| [$2337: JP      $0AD6]

* < A1: shot structure
* < A0: ram_pointer_on_flying_enemies_table_43E6

handle_player_shot_vs_mothership_2351:
	move.b	(a1),d0                             | [$2351: LD      A,(DE)]
	and.b	#0x08,d0                         	| [$2352: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$2354: RET     Z] [...]
0:
	* shot active
	move.b	(a0)+,d0                         	| [$2355: LD      A,(HL)]
	                           	| [$2356: INC     L]
	move.b	(a0),d6                         	| [$2357: LD      L,(HL)]
	add.b	#0x08,d0                         	| [$2358: ADD     $08]
	move.b	d0,d5                           	| [$235a: LD      H,A]
	* HL is completely replaced by D5/D6 from now
	move.b	current_scroll_value_43B9,d0    	| [$235b: LD      A,(current_scroll_value_43B9)]
	ror.b	#3,d0                            	| [$235e: RRCA] * 3
	add.b	d6,d0                            	| [$2361: ADD     A,L]
	and.b	#0x1F,d0                         	| [$2362: AND     $1F]
	move.b	d0,d1                           	| [$2364: LD      B,A]
	move.b	d6,d0                           	| [$2365: LD      A,L]
	and.b	#0xE0,d0                         	| [$2366: AND     $E0]
	or.b	d1,d0                             	| [$2368: OR      B]
	move.b	d0,d6                           	| [$2369: LD      L,A]
	* reconvert to screen address
	LOAD_D5_16_FROM_D5D6
	move.w	d5,d7
	bsr		read_ram                       	| [$236a: LD      A,(HL)]
	move.b	d0,d1                           	| [$236b: LD      B,A]
	and.b	#0xFC,d0                         	| [$236c: AND     $FC]
	cmp.b	#0x4C,d0                         	| [$236e: CP      $4C]
	jeq	l_237b                             	| [$2370: JP      Z,$237B]
	and.b	#0xF0,d0                         	| [$2373: AND     $F0]
	cmp.b	#0x60,d0                         	| [$2375: CP      $60]
	jeq	l_2398                             	| [$2377: JP      Z,$2398]
	rts                                    	| [$237a: RET]
l_237b:
	move.b	(a1),d0                         	| [$237b: LD      A,(DE)]
	and.b	#0xF7,d0                         	| [$237c: AND     $F7]
	move.b	d0,(a1)                         	| [$237e: LD      (DE),A]	disable player shot
	st.b	d0                                	| [$237f: LD      A,$FF]
	move.b	d0,unknown_4366                 	| [$2381: LD      (unknown_4366),A]
	
	move.w	#BOSS_SHIELD_SHOT_1,d0
	eor.b	#1,vulture_sound_toggle
	bne.b	0f
	move.w	#BOSS_SHIELD_SHOT_2,d0
0:
	jbsr	osd_sound_start
	
	move.b	d1,d0                           	| [$2384: LD      A,B]
	* weaken the shield
	subq.b	#1,d0                           	| [$2385: DEC     A]
	jbsr	osd_w_videoram	                 	| [$2386: LD      (HL),A]
	cmp.b	#0x4B,d0                         	| [$2387: CP      $4B]
	beq.b	0f                               	| [...]
	rts                                    	| [$2389: RET     NZ] [...]
0:
	* no more shield on that character
	moveq	#0,d0
	jbsr	osd_w_videoram			| [$238a: LD      (HL),$00]
	                           	| [$238c: DEC     L]
	subq.w	#1,d7
	bsr		read_ram                        	| [$238d: LD      A,(HL)]
	cmp.b	#0x5E,d0                         	| [$238e: CP      $5E]
	beq.b	0f                               	| [...]
	rts                                    	| [$2390: RET     NZ] [...]
0:
	move.b	#0x4F,d0                      	| [$2391: LD      (HL),$4F]
	jbsr	osd_w_videoram
	rts                                    	| [$2393: RET]

l_2398:
	move.b	(a1),d0                         	| [$2398: LD      A,(DE)]
	and.b	#0xF7,d0                         	| [$2399: AND     $F7]
	move.b	d0,(a1)                         	| [$239b: LD      (DE),A]  	disable player shot
	addq.w	#2,a1                           	| [$239c: INC     E]
	move.b	(a1),d0                         	| [$239e: LD      A,(DE)]
	and.b	#0x04,d0                         	| [$239f: AND     $04]
	jne	l_2030                             	| [$23a2: JP      NZ,$2030]
	move.b	d1,d0                           	| [$23a1: LD      A,B]
	and.b	#0x0C,d0                         	| [$23a5: AND     $0C]
	lea	game_rom+0x1B40,a1                      	| [$23a9: LD      DE,$1B40]
	cmp.b	#0x04,d0                         	| [$23a7: CP      $04]
l_23ac:
	jeq	l_23c0                             	| [$23ac: JP      Z,$23C0]
	move.b	d1,d0                           	| [$23af: LD      A,B]
	and.w	#0x0F,d0                         	| [$23b0: AND     $0F]
	add.w	d0,a1                            	| [$23b2: ADD     A,E]
												| [$23b3: LD      E,A]
	move.b	(a1),d0                         	| [$23b4: LD      A,(DE)]
	jbsr	osd_w_videoram                         	| [$23b5: LD      (HL),A]
	st.b	d0                                	| [$23b6: LD      A,$FF]
	move.b	d0,unknown_4366                 	| [$23b8: LD      (unknown_4366),A]
	rts                                    	| [$23bb: RET]

l_23c0:
	subq.w	#1,d7                           	| [$23c0: DEC     L]
 	bsr		read_ram                         	| [$23c1: LD      A,(HL)]
	and.b	#0xF0,d0                         	| [$23c2: AND     $F0]
	cmp.b	#0x70,d0                         	| [$23c4: CP      $70]
	beq.b	0f                               	| [...]
	rts                                    	| [$23c6: RET     NZ] [...]
0:
	* bull's eye: we got the boss
	jbsr	osd_sound_stop			| stop all loops
	move.w	#EXPLOSION_SND,d0
	jbsr	osd_sound_start
	
	lea	game_state_43A4,a0             	| [$23c7: LD      HL,game_state_43A4]
	move.b	#STATE_BOSS_STAGE_COMPLETED,(a0)+                      	| [$23ca: LD      (HL),$06]
	                           	| [$23cc: INC     L]
 	move.b	#0x60,(a0)                      	| [$23cd: LD      (HL),$60]
	lea	unknown_4363,a0                        	| [$23cf: LD      L,$63]
	move.b	#0xFF,(a0)                      	| [$23d1: LD      (HL),$FF]
	rts                                    	| [$23d3: RET]

play_stage_ambient_sound_23d6:
	lea	current_stage_43B8,a0          	| [$23d6: LD      HL,current_stage_43B8]
	move.b	(a0),d0                         	| [$23d9: LD      A,(HL)]
	and.b	#0x0F,d0                         	| [$23da: AND     $0F]
	cmp.b	#0x01,d0                         	| [$23dc: CP      $01]
	jeq	birds_ambient_sound_3a98                             	| [$23de: JP      Z,$3A98]
	cmp.b	#0x03,d0                         	| [$23e1: CP      $03]
	jeq	birds_ambient_sound_3a98                             	| [$23e3: JP      Z,$3A98]
	cmp.b	#0x05,d0                         	| [$23e6: CP      $05]
	jeq	vultures_background_sound_3ad0                             	| [$23e8: JP      Z,$3AD0]
	cmp.b	#0x07,d0                         	| [$23eb: CP      $07]
	jeq	vultures_background_sound_3ad0                             	| [$23ed: JP      Z,$3AD0]
	cmp.b	#0x09,d0                         	| [$23f0: CP      $09]
	bcc.b	0f                               	| [...]
	rts                                    	| [$23f2: RET     C] [...]
0:
	cmp.b	#0x0B,d0                         	| [$23f3: CP      $0B]
	jcs	boss_ambient_sound_3b02                             	| [$23f5: JP      C,$3B02]
	jbsr	boss_ambient_sound_3b02                            	| [$23f8: CALL    $3B02]
	jra	birds_ambient_sound_3a98                             	| [$23fb: JP      $3A98]

boss_stage_completed_2400:
	jbsr	l_242c                            	| [$2400: CALL    $242C]
	jeq	l_2552                             	| [$2403: JP      Z,$2552]
	cmp.b	#0x20,d0                         	| [$2406: CP      $20]
	jcs	l_246a                             	| [$2408: JP      C,$246A]
	jeq	display_boss_score_2520                             	| [$240b: JP      Z,$2520]
	move.b	d0,d1                           	| [$240e: LD      B,A]
	ror.b	#1,d0                            	| [$240f: RRCA]
	                                    	| [$2410: NOP]
	jcc	l_20e8_2                             	| [$2412: JP      NC,$20E8]
	move.b	d4,d0                           	| [$2415: LD      A,E]
	subq.b	#0x05,d0                        	| [$2416: SUB     $05]
	add.b	#0xC0,d0                         	| [$2418: ADD     $C0]
	move.b	d0,d2                           	| [$241a: LD      C,A]
	move.b	d3,d0                           	| [$241b: LD      A,D]
	move.b	#0x00,d7                        	| [$241c: ADC     $00]
	addx.b	d7,d0                           	| [$241c: ADC     $00]
 	move.b	d0,d1                           	| [$241e: LD      B,A]
	move.b	(a0),d0                         	| [$241f: LD      A,(HL)]
	move.w	#0x2A00,d3                      	| [$2420: LD      DE,$2A00]
	move.w	#0x2B00,d6                      	| [$2423: LD      HL,$2B00]
	jra	l_2085                             	| [$2426: JP      $2085]

	DECL_ADDRESS	242c

l_242c:
	lea	current_scroll_value_43B9,a0   	| [$242c: LD      HL,current_scroll_value_43B9]
	move.b	(a0),d0                         	| [$242f: LD      A,(HL)]
	and.b	#0xF8,d0                         	| [$2430: AND     $F8]
	move.b	d0,(a0)                         	| [$2432: LD      (HL),A]
	jbsr	osd_set_scroll_value                       	| [$2433: LD      ($5800),A] 58xx scroll register
	* load a screen address
 	move.b	#0x41,d3                	| [$2436: LD      DE,unknown_41C6]
 	move.b	#0xc6,d4                	| [$2436: LD      DE,unknown_41C6]
	ror.b	#3,d0                            	| [$2439: RRCA] * 3
	move.b	d0,d1                           	| [$243c: LD      B,A]
	move.b	d4,d0                           	| [$243d: LD      A,E]
	sub.b	d1,d0                            	| [$243e: SUB     B]
	and.b	#0x1F,d0                         	| [$243f: AND     $1F]
	move.b	d0,d1                           	| [$2441: LD      B,A]
	move.b	d4,d0                           	| [$2442: LD      A,E]
	and.b	#0xE0,d0                         	| [$2443: AND     $E0]
	or.b	d1,d0                             	| [$2445: OR      B]
	move.b	d0,d4                           	| [$2446: LD      E,A]
	lea	timer_43A5,a0                        	| [$2447: LD      L,$A5]
	subq.b	#1,(a0)                         	| [$2449: DEC     (HL)]
	move.b	(a0),d0                         	| [$244a: LD      A,(HL)]
	rts                                    	| [$244b: RET]
	
	DECL_ADDRESS	244c

* called when boss has exploded, wraps back to level 1
end_of_level_transition_244C:
	lea	timer_43A5,a0                  	| [$244c: LD      HL,timer_43A5]
	subq.b	#1,(a0)                         	| [$244f: DEC     (HL)]
	move.b	(a0),d0                         	| [$2450: LD      A,(HL)]
	ror.b	#1,d0                            	| [$2451: RRCA]
	jcs	l_06f0                             	| [$2452: JP      C,$06F0]
	                               	| [$2455: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$2456: RET     NZ] [...]
0:
	                           	| [$2457: DEC     L]
 	move.b	#0x02,-(a0)                      	| [$2458: LD      (HL),$02] sets 43A4 to 2 (restart game state)
	lea	current_stage_43B8,a0                        	| [$245a: LD      L,$B8]
	move.b	(a0),d0                         	| [$245c: LD      A,(HL)]
	and.b	#0xF0,d0                         	| [$245d: AND     $F0]
	add.b	#0x10,d0                         	| [$245f: ADD     $10]
	move.b	d0,(a0)                         	| [$2461: LD      (HL),A]
	lea	nb_birds_to_kill_before_stage_completed_43BA,a0                        	| [$2462: LD      L,$BA]
	move.b	#0x10,(a0)                      	| [$2464: LD      (HL),$10]
	jra	clear_foreground_tiles_0380                             	| [$2466: JP      $0380]

	DECL_ADDRESS	246a

l_246a:
	move.w	#0x09,d1
	move.w	#0x14,d2                      	| [$246a: LD      BC,$0914]
	move.w	#0x4AC6,d3                	| [$246d: LD      DE,unknown_4AC6]
	lea	game_rom+0x1C00,a0                      	| [$2470: LD      HL,$1C00]
	jra	copy_block_to_screen_0ad6                             	| [$2473: JP      $0AD6]
	
	DECL_ADDRESS	2476
* enters here called from update_vulture_random_26aa where H=$4B
* < D1: kind of pos-height of swarm
* < D2:	derived from random 1-4
l_2476:
	move.b	d1,d0                           	| [$2476: LD      A,B]
	add.b	d2,d0                            	| [$2477: ADD     A,C]
	jbsr	compute_direction_change_timer_2495                            	| [$2478: CALL    $2495]
	lea	swarm_vertical_direction_change_timer_4BD3,a0                        	| [$247b: LD      L,$D3]
	move.b	d0,(a0)                         	| [$247d: LD      (HL),A]
	lea	nb_vultures_to_kill_before_stage_completed_43BB,a0                	| [$247e: LD      HL,nb_vultures_to_kill_before_stage_completed_43BB]
	move.b	#0x08,d0                        	| [$2481: LD      A,$08]
	sub.b	(a0),d0                          	| [$2483: SUB     (HL)] nb killed vultures
	rol.b	#1,d0                            	| [$2484: RLCA]
	lea	counter_439A,a0                        	| [$2485: LD      L,$9A]
	add.b	(a0),d0                          	| [$2487: ADD     A,(HL)]
	rol.b	#1,d0                            	| [$2488: RLCA]
	move.b	d0,d1                           	| [$2489: LD      B,A]
	* computes aggressivity depending on number of remaining vultures?
	lea	repeated_bits_random_436F,a0                        	| [$248a: LD      L,$6F]
	move.b	(a0),d0                         	| [$248c: LD      A,(HL)]
	and.b	#0x1E,d0                         	| [$248d: AND     $1E]
	add.b	d1,d0                            	| [$248f: ADD     A,B]
	move.b	d0,vultures_aggressivity_4BD1                 	| [$2490: LD      (vultures_aggressivity_4BD1),A]
	rts                                    	| [$2493: RET]
compute_direction_change_timer_2495:
	add.b	d1,d0                            	| [$2495: ADD     A,B]
	subq.b	#1,d2                           	| [$2496: DEC     C]
	bne.b	0f                               	| [...]
	rts                                    	| [$2497: RET     Z] [...]
0:
	add.b	d1,d0                            	| [$2498: ADD     A,B]
	subq.b	#1,d2                           	| [$2499: DEC     C]
	bne.b	0f                               	| [...]
	rts                                    	| [$249a: RET     Z] [...]
0:
	add.b	d1,d0                            	| [$249b: ADD     A,B]
	subq.b	#1,d2                           	| [$249c: DEC     C]
 	bne.b	0f                               	| [...]
	rts                                    	| [$249d: RET     Z] [...]
0:
	add.b	d0,d0                            	| [$249e: ADD     A,A]
	rts                                    	| [$249f: RET]
		
	DECL_ADDRESS	24a0

mothership_shot_collision_24a0:
	move.b	current_stage_43B8,d0           	| [$24a0: LD      A,(current_stage_43B8)]
	and.b	#0x0F,d0                         	| [$24a3: AND     $0F]
	cmp.b	#0x08,d0                         	| [$24a5: CP      $08]
	bcc.b	0f                               	| [...]
	* not mothership stage: return
	rts                                    	| [$24a7: RET     C] [...]
0:
	lea	player_shot_1_structure_43C4,a1	| [$24a8: LD      DE,player_shot_1_structure_43C4]
	lea	ram_pointer_on_flying_enemies_table_43E6,a0	| [$24ab: LD      HL,ram_pointer_on_flying_enemies_table_43E6]
	jbsr	handle_player_shot_vs_mothership_2351                            	| [$24ae: CALL    $2351]
	move.b	random_seed_counter_value_439B,d0                    	| [$24b1: LD      A,(random_seed_counter_value_439B)]
	and.b	#0x03,d0                         	| [$24b4: AND     $03]
	cmp.b	#0x03,d0                         	| [$24b6: CP      $03]
	beq.b	0f                               	| [...]
	rts                                    	| [$24b8: RET     NZ] [...]
0:
	jra	l_24f2                             	| [$24b9: JP      $24F2]
	                           	| [$24bc: CALL    $2351]
	                                    	| [$24bf: RET]

	DECL_ADDRESS	24c4
	
animate_mothership_24c4:
	move.b	current_stage_43B8,d0           	| [$24c4: LD      A,(current_stage_43B8)]
	and.b	#0x0F,d0                         	| [$24c7: AND     $0F]
	cmp.b	#0x08,d0                         	| [$24c9: CP      $08]
	jcs	l_06f0                             	| [$24cb: JP      C,$06F0]
	* mothership stage
	jbsr	l_24e0                            	| [$24ce: CALL    $24E0]
	lea	unknown_43AA,a0                	| [$24d1: LD      HL,unknown_43AA]
	addq.b	#1,(a0)                         	| [$24d4: INC     (HL)]
	move.b	(a0),d0                         	| [$24d5: LD      A,(HL)]
	and.b	#0x03,d0                         	| [$24d6: AND     $03]
	jeq	l_22fa                             	| [$24d8: JP      Z,$22FA]
	jra	l_2322                             	| [$24db: JP      $2322]
	                           	| [$24de: INC     H]
	                            	| [$24df: CP      A]
l_24e0:
	move.b	unknown_43AA,d0                 	| [$24e0: LD      A,(unknown_43AA)]
	and.b	#0x0F,d0                         	| [$24e3: AND     $0F]
	beq.b	0f                               	| [...]
	rts                                    	| [$24e5: RET     NZ] [...]
0:
	move.b	current_scroll_value_43B9,d0    	| [$24e6: LD      A,(current_scroll_value_43B9)]
	cmp.b	#0xA0,d0                         	| [$24e9: CP      $A0]
	bcc.b	0f                               	| [...]
	rts                                    	| [$24eb: RET     C] [...]
0:
	jra	update_scrolling_067A              	| [$24ec: JP      update_scrolling_067A]
l_24f2:
	jbsr	get_random_value_30aa                            	| [$24f2: CALL    $30AA]
	add.b	#0x60,d0                         	| [$24f5: ADD     $60]
	                                    	| [$24f7: NOP]
	move.b	d0,d1                           	| [$24f8: LD      B,A]
	lea	random_seed_counter_value_439B,a0                	| [$24f9: LD      HL,random_seed_counter_value_439B]
	and.b	#0x0E,d0                         	| [$24fc: AND     $0E]
	and.b	(a0),d0                          	| [$24fe: AND     (HL)]
	beq.b	0f                               	| [...]
	rts                                    	| [$24ff: RET     NZ] [...]
0:
	move.b	player_ship_left_x_439E,d0                 	| [$2500: LD      A,(player_ship_left_x_439E)]
	cmp.b	d1,d0                            	| [$2503: CP      B]
	bcs.b	0f                               	| [...]
	rts                                    	| [$2504: RET     NC] [...]
0:
	move.b	player_ship_right_x_439F,d0                 	| [$2505: LD      A,(player_ship_right_x_439F)]
	cmp.b	d1,d0                            	| [$2508: CP      B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$2509: RET     C] [...]
0:
	move.b	d1,d0                           	| [$250a: LD      A,B]
	subq.b	#0x04,d0                        	| [$250b: SUB     $04]
	move.b	d0,d1                           	| [$250d: LD      B,A]
	move.b	current_scroll_value_43B9,d0    	| [$250e: LD      A,(current_scroll_value_43B9)]
	not.b	d0                               	| [$2511: CPL]
	addq.b	#1,d0                           	| [$2512: INC     A]
	and.b	#0xF8,d0                         	| [$2513: AND     $F8]
	add.b	#0x48,d0                         	| [$2515: ADD     $48]
	move.b	d0,d2                           	| [$2517: LD      C,A]

	move.l	a0,-(sp)                        	| [$2518: PUSH    HL]

	move.l	a0,-(sp)                        	| [$2519: PUSH    HL]
	jra	enemy_starts_shooting_25b7                             	| [$251a: JP      $25B7]
	
	DECL_ADDRESS	2520

display_boss_score_2520:
	move.w	#BOSS_END_MUSIC_SND,d0
	jbsr	osd_sound_start
	
	movem.w	d3/d4,-(sp)                    	| [$2520: PUSH    DE]
	jbsr	clear_foreground_tiles_0380                            	| [$2521: CALL    $0380]
	movem.w	(sp)+,d3/d4                    	| [$2524: POP     DE]
	LOAD_D3_16_FROM_D3D4
	* scroll value is be used as a time bonus. Starts around $F8 (ship high)
	* the higher the value the higher the bonus score
	move.b	current_scroll_value_43B9,d0    	| [$2525: LD      A,(current_scroll_value_43B9)]
	add.b	#0x60,d0                         	| [$2528: ADD     $60]
	ror.b	#1,d0                            	| [$252a: RRCA]
	move.b	d0,d7                           	| [$252b: LD      B,A]
	move.b	current_stage_43B8,d0           	| [$252c: LD      A,(current_stage_43B8)]
	and.b	#0xF0,d0                         	| [$252f: AND     $F0] number of rounds already completed
	move.b	#0x90,d1                        	| [$2532: LD      B,$90]
	add.b	d7,d0                            	| [$2531: ADD     A,B]
	jcs	l_253d                             	| [$2534: JP      C,$253D]
	cmp.b	#0x90,d0                         	| [$2537: CP      $90]
	jcc	l_253d                             	| [$2539: JP      NC,$253D] maxed out to 9000 points
	move.b	d0,d1                           	| [$253c: LD      B,A]
l_253d:
	clr.b	d0                               	| [$253d: XOR     A]
	move.b	d1,d0                           	| [$253e: LD      A,B]
	bsr		daa									| [$253f: DAA]
	lea	unknown_439D,a0                	| [$2540: LD      HL,unknown_439D]
	move.b	d0,(a0)+                         	| [$2543: LD      (HL),A]
	                           	| [$2544: INC     L]
	clr.b	(a0)                             	| [$2545: LD      (HL),$00]
	                           	| [$2547: LD      A,E]
	sub.w	#0x5E,d3                         	| [$2548: SUB     $5E]
	                           	| [$254a: LD      E,A]
	move.b	#0x04,d1                        	| [$254b: LD      B,$04]
	jra	write_digits_to_screen_00c4                             	| [$254d: JP      $00C4]

	* here HL=$43xx
l_2552:
	lea		game_state_43A4,a0                       	| [$2552: LD      L,$A4]
	move.b	#STATE_END_OF_LEVEL_TRANSITION,(a0)+                      	| [$2554: LD      (HL),$07]
                           	| [$2556: INC     L]
	move.b	#0x40,(a0)                      	| [$2557: LD      (HL),$40]
	st.b		unknown_436B                        	| [$2559: LD      L,$6B]
	                      	| [$255b: LD      (HL),$FF]
	rts                                    	| [$255d: RET]

	DECL_ADDRESS	2560
	
l_2560:
	lea	birds_attack_counter_4393,a0                	| [$2560: LD      HL,birds_attack_counter_4393]
	move.b	(a0),d0                         	| [$2563: LD      A,(HL)]
	and.b	#0x01,d0                         	| [$2564: AND     $01]
	rol.b	#5,d0                            	| [$2566: RLCA] * 5
	add.b	#0x70,d0                         	| [$256b: ADD     $70]
	move.b	d0,d6                           	| [$256d: LD      L,A]
	move.b	#0x4B,d5                        	| [$256e: LD      H,$4B]
	move.b	#0x08,d4                        	| [$2570: LD      E,$08]
	move.b	unknown_4357,d0                 	| [$2572: LD      A,(unknown_4357)]
	rol.b	#3,d0                            	| [$2575: RLCA] * 3
	                               	| [$2578: NOP]
	add.b	#0xAD,d0                         	| [$2579: ADD     $AD]
	move.b	d0,d3                           	| [$257b: LD      D,A]
	move.b	player_ship_right_x_439F,d0                 	| [$257c: LD      A,(player_ship_right_x_439F)]
	addq.b	#0x03,d0                        	| [$257f: ADD     $03]
	move.b	d0,d2                           	| [$2581: LD      C,A]
	move.b	player_ship_left_x_439E,d0                 	| [$2582: LD      A,(player_ship_left_x_439E)]
	sub.b	#0x0A,d0                         	| [$2585: SUB     $0A]
	move.b	d0,d1                           	| [$2587: LD      B,A]
	bsr		load_ram_in_a0_from_d5d6
l_2588:

	move.l	a0,-(sp)                        	| [$2588: PUSH    HL]
	jbsr	l_2596                            	| [$2589: CALL    $2596]
	move.l	(sp)+,a0                        	| [$258c: POP     HL]
												| [$258d: LD      A,L]
	addq.w	#0x04,a0                        	| [$258e: ADD     $04]
												| [$2590: LD      L,A]
	subq.b	#1,d4                           	| [$2591: DEC     E]
 	jne	l_2588                             	| [$2592: JP      NZ,$2588]
	rts                                    	| [$2595: RET]
l_2596:
	move.b	(a0),d0                         	| [$2596: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$2597: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$2599: RET     Z] [...]
0:
	addq.w	#1,a0                           	| [$259a: INC     L]
	move.b	(a0),d0                         	| [$259b: LD      A,(HL)]
	cmp.b	#0x08,d0                         	| [$259c: CP      $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$259e: RET     Z] [...]
0:
	cmp.b	#0x88,d0                         	| [$259f: CP      $88]
	bcs.b	0f                               	| [...]
	rts                                    	| [$25a1: RET     NC] [...]
0:
	addq.w	#1,a0                           	| [$25a2: INC     L]
	move.b	(a0),d0                         	| [$25a3: LD      A,(HL)]
	cmp.b	d1,d0                            	| [$25a4: CP      B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$25a5: RET     C] [...]
0:
	cmp.b	d2,d0                            	| [$25a6: CP      C]
	bcs.b	0f                               	| [...]
	rts                                    	| [$25a7: RET     NC] [...]
0:
	addq.w	#1,a0                           	| [$25a8: INC     L]
	move.b	(a0),d0                         	| [$25a9: LD      A,(HL)]
	cmp.b	d3,d0                            	| [$25aa: CP      D]
	bcs.b	0f                               	| [...]
	rts                                    	| [$25ab: RET     NC] [...]
0:
	cmp.b	#0x80,d0                         	| [$25ac: CP      $80]
	bcc.b	0f                               	| [...]
	rts                                    	| [$25ae: RET     C] [...]
0:
	                                    	| [$25af: NOP]
	                                    	| [$25b0: NOP]
	                                    	| [$25b1: NOP]
	                                    	| [$25b2: NOP]
	                                    	| [$25b3: NOP]
	move.b	d0,d2                           	| [$25b4: LD      C,A]
	                           	| [$25b5: DEC     L]
	move.b	-(a0),d1                         	| [$25b6: LD      B,(HL)]
enemy_starts_shooting_25b7:
	move.b	current_stage_43B8,d0           	| [$25b7: LD      A,(current_stage_43B8)]
	move.b	#0x03,d3                        	| [$25ba: LD      D,$03]
	cmp.b	#0x10,d0                         	| [$25bc: CP      $10]
	jcs	l_25ca                             	| [$25be: JP      C,$25CA]
	move.b	#0x04,d3                        	| [$25c1: LD      D,$04]
	cmp.b	#0x20,d0                         	| [$25c3: CP      $20]
	jcs	l_25ca                             	| [$25c5: JP      C,$25CA]
	move.b	#0x05,d3                        	| [$25c8: LD      D,$05]
l_25ca:
	lea	player_shot_3_structure_43CC,a0	| [$25ca: LD      HL,player_shot_3_structure_43CC]
l_25cd:
	move.b	(a0),d0                         	| [$25cd: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$25ce: AND     $08]
	jeq	l_25e0                             	| [$25d0: JP      Z,$25E0]
	                           	| [$25d3: LD      A,L]
	addq.w	#0x04,a0                        	| [$25d4: ADD     $04]
	                           	| [$25d6: LD      L,A]
	subq.b	#1,d3                           	| [$25d7: DEC     D]
	jne	l_25cd                             	| [$25d8: JP      NZ,$25CD]
	move.l	(sp)+,a0                        	| [$25db: POP     HL]
	move.l	(sp)+,a0                        	| [$25dc: POP     HL]
	rts                                    	| [$25dd: RET]
	
	DECL_ADDRESS	25e0

l_25e0:
	move.b	d1,d0                           	| [$25e0: LD      A,B]
	addq.b	#0x04,d0                        	| [$25e1: ADD     $04]
	move.b	d0,d1                           	| [$25e3: LD      B,A]
	move.b	d2,d0                           	| [$25e4: LD      A,C]
	add.b	#0x0C,d0                         	| [$25e5: ADD     $0C]
	move.b	d0,d2                           	| [$25e7: LD      C,A]
	move.b	#0x08,(a0)+                      	| [$25e8: LD      (HL),$08]
	                           	| [$25ea: INC     L]
 	ror.b	#1,d0                            	| [$25ec: RRCA]
	and.b	#0x03,d0                         	| [$25ed: AND     $03]
	move.b	d0,d3                           	| [$25ef: LD      D,A]
	move.b	d2,d0                           	| [$25f0: LD      A,C]
	and.b	#0x04,d0                         	| [$25f1: AND     $04]
	add.b	d3,d0                            	| [$25f3: ADD     A,D]
	add.b	#0x58,d0                         	| [$25f4: ADD     $58]
	move.b	d0,(a0)+                         	| [$25f6: LD      (HL),A]
	                           	| [$25f7: INC     L]
	move.b	d1,(a0)+                         	| [$25f8: LD      (HL),B]
	                           	| [$25f9: INC     L]
 	move.b	d2,(a0)                         	| [$25fa: LD      (HL),C]
	move.l	(sp)+,a0                        	| [$25fb: POP     HL]
	move.l	(sp)+,a0                        	| [$25fc: POP     HL]
	rts                                    	| [$25fd: RET]

	DECL_ADDRESS	2600
	
* the game uses hardware scroll to move vultures vertically, allowing smooth
* y positionning that can't be achieved with chars only, or we'd need a lot more
* chars

handle_vultures_y_2600:
	move.b	current_scroll_value_43B9,d0    	| [$2605: LD      A,(current_scroll_value_43B9)]
	not.b	d0                               	| [$2608: CPL]    256-value
	lsr.b	#3,d0                            	| [$2609: RRCA] * 3  divide by 8
												| [$260c: AND     $1F]  to get 0-31 scroll (for chars)
	lea	current_char_scroll_value_4BD2,a0                	| [$260e: LD      HL,current_char_scroll_value_4BD2]
	move.b	d0,(a0)+                         	| [$2611: LD      (HL),A]
	                           	| [$2612: INC     L]
 	move.b	vultures_aggressivity_4BD1,d0     | [$2613: LD      A,(vultures_aggressivity_4BD1)]
	cmp.b	(a0),d0                          	| [$2616: CP      (HL)] compare to swarm_vertical_direction_change_timer_4BD3
	
	* up or down, the delta y to move all vultures vertically
	* uses a table in ROM from 0x3ED0
	jcs	vultures_go_up_2650                             	| [$2617: JP      C,$2650]
	* vultures go down
	move.b	unknown_vulture_value_4BD5,d0                 	| [$261a: LD      A,(unknown_vulture_value_4BD5)]
	move.b	d0,d3                           	| [$261d: LD      D,A]
	and.b	#0x03,d0                         	| [$261e: AND     $03]
	move.b	d0,d4                           	| [$2620: LD      E,A]
	move.b	random_seed_counter_value_439B,d0                    	| [$2621: LD      A,(random_seed_counter_value_439B)]
	rol.b	#2,d0                            	| [$2624: RLCA] * 2
	and.b	#0x0C,d0                         	| [$2626: AND     $0C]
	add.b	d4,d0                            	| [$2628: ADD     A,E] random variation +0 +4 +8 +12
	moveq	#0,d6                         	| [$2629: ADD     $D0]
	move.b	d0,d6                           	| [$262b: LD      L,A]
	lea		vulture_y_delta_table_3ED0(pc),a0    	| [$262c: LD      H,$3E]
	move.b	d3,d0                           	| [$262e: LD      A,D]
	ror.b	#2,d0                            	| [$262f: RRCA] * 2
	and.b	#0x07,d0                         	| [$2631: AND     $07]
	add.b	(a0,d6.w),d0                          	| [$2633: ADD     A,(HL)] adds 1 or 0 (adding 1 makes vultures go up)
	move.b	d0,d3                           	| [$2634: LD      D,A]
	move.b	current_scroll_value_43B9,d0    	| [$2635: LD      A,(current_scroll_value_43B9)]
	sub.b	d3,d0                            	| [$2638: SUB     D]
set_vultures_scroll_value_2639:
	move.b	d0,current_scroll_value_43B9    	| [$2639: LD      (current_scroll_value_43B9),A]
	jbsr	osd_set_scroll_value                       	| [$263c: LD      ($5800),A] 58xx scroll register
	move.b	random_seed_counter_value_439B,d0                    	| [$263f: LD      A,(random_seed_counter_value_439B)]
	ror.b	#1,d0                            	| [$2642: RRCA]
	* calls one time out of two either compute_vulture_swarm_dimensions_26d0 or update_vulture_random_26aa
	* maybe not to overload the modest CPU tick?
	jcc	compute_vulture_swarm_dimensions_26d0                             	| [$2643: JP      NC,$26D0] compute swarm dimensions 50% of time
	jbsr	l_2668                            	| [$2646: CALL    $2668]
	jra	update_vulture_random_26aa                             	| [$2649: JP      $26AA]

	DECL_ADDRESS	2650
	
* jotd: I don't really know what is the problem here, but I have to change things as random_03_4BD4
* is not or rarely updated, which often leads to it selecting 0 in the table
* in vultures_go_up_2650, so the vultures almost never go up... I don't know why it works in the original
* game and not here... but I'm changing the code so the vultures can go up if too many zero adds
* in a row: updating random in that case if more than 30 zeroes in a row seems to do the trick
*

vultures_go_up_2650:
    * avoid that vultures go up and warp from top to bottom of screen. Preventing scroll counter to wrap does the trick
												| [$2650: INC     L]
	move.b	current_scroll_value_43B9,d0    	| [$2651: LD      A,(current_scroll_value_43B9)]
	cmp.b	#0xFC,d0
	bcc.b	set_vultures_scroll_value_2639
	
	
	rol.b	#2,d0                            	| [$2654: RLCA] * 2
	and.b	#0x0C,d0                         	| [$2656: AND     $0C] effectively random on scroll value ! 0 4 8 12
	add.b	random_03_4BD4,d0                          	| [$2658: ADD     A,(HL)] add random_03_4BD4 (range 0-3)
	moveq	#0,d6
	lea		vulture_y_delta_table_3ED0(pc),a0
	move.b	d0,d6
	                         	| [$2659: ADD     $D0]
	                       	| [$265b: LD      L,A]
	                       	| [$265c: LD      H,$3E]
	move.b	current_scroll_value_43B9,d0    	| [$265e: LD      A,(current_scroll_value_43B9)]
	move.b	(a0,d6.w),d6                          	| [$2661: ADD     A,(HL)] adds 1 or 0
	bne.b	0f
	* zero:
	addq.w	#1,zero_added
	cmp.w	#30,zero_added		| completely empric value
	bne.b	0f
	clr.w	zero_added
	move.w	d0,-(a7)
	move.b	repeated_bits_random_436F,d0                 	| [$26bf: LD      A,(repeated_bits_random_436F)]
	and.b	#0x03,d0                         	| [$26c2: AND     $03]
	* compute 0-3 value from random value above
	                        	| [$26c4: LD      L,$D4]
	move.b	d0,random_03_4BD4                         	| [$26c6: LD      (HL),A]
	move.w	(a7)+,d0

0:
	add.b	d6,d0
	jra	set_vultures_scroll_value_2639                             	| [$2662: JP      $2639]
	
	                             	| [$2665: JP      NC,$26AE]
l_2668:
	move.b	unknown_436E,d0                 	| [$2668: LD      A,(unknown_436E)]
	                                    	| [$266b: NOP]
	move.b	d0,d1                           	| [$266c: LD      B,A]
	move.b	counter_439A,d0                      	| [$266d: LD      A,(counter_439A)]
	cmp.b	#0x18,d0                         	| [$2670: CP      $18]
	jcs	l_2676                             	| [$2672: JP      C,$2676]
	addq.b	#1,d1                           	| [$2675: INC     B]
l_2676:
	cmp.b	#0x10,d0                         	| [$2676: CP      $10]
	jcs	l_267c                             	| [$2678: JP      C,$267C]
	addq.b	#1,d1                           	| [$267b: INC     B]
l_267c:
	move.b	nb_birds_to_kill_before_stage_completed_43BA,d0	| [$267c: LD      A,(nb_birds_to_kill_before_stage_completed_43BA)]
	cmp.b	#0x03,d0                         	| [$267f: CP      $03]
	jcc	l_2685                             	| [$2681: JP      NC,$2685]
	addq.b	#1,d1                           	| [$2684: INC     B]
l_2685:
	move.b	average_vulture_y_pos_in_chars_4BD6,d0                 	| [$2685: LD      A,(average_vulture_y_pos_in_chars_4BD6)]
	* check from table in $3EE0
	add.b	#0xE0,d0                         	| [$2688: ADD     $E0]
	move.b	d0,d6                           	| [$268a: LD      L,A]
	move.b	#0x3E,d5                        	| [$268b: LD      H,$3E]
	move.b	d1,d0                           	| [$268d: LD      A,B]
	jbsr	load_rom_in_a0_from_d5d6
	cmp.b	(a0),d0                          	| [$268e: CP      (HL)]
	jcs	l_2693                             	| [$268f: JP      C,$2693]
	move.b	(a0),d0                         	| [$2692: LD      A,(HL)]
l_2693:
	move.b	d0,d3                           	| [$2693: LD      D,A]
	move.b	nb_vultures_to_kill_before_stage_completed_43BB,d0                 	| [$2694: LD      A,(nb_vultures_to_kill_before_stage_completed_43BB)]
	cmp.b	#0x04,d0                         	| [$2697: CP      $04]
	jcc	l_269d                             	| [$2699: JP      NC,$269D]
	addq.b	#1,d3                           	| [$269c: INC     D]
l_269d:
	cmp.b	#0x02,d0                         	| [$269d: CP      $02]
	jcc	l_26a3                             	| [$269f: JP      NC,$26A3]
	addq.b	#1,d3                           	| [$26a2: INC     D]
l_26a3:
	move.b	d3,d0                           	| [$26a3: LD      A,D]
	move.b	d0,unknown_vulture_value_4BD5                 	| [$26a4: LD      (unknown_vulture_value_4BD5),A]
	rts                                    	| [$26a7: RET]
	                          	| [$26a8: NOP]
	                           	| [$26a9: LD      E,B]
update_vulture_random_26aa:
	lea	swarm_vertical_direction_change_timer_4BD3,a0   | [$26aa: LD      HL,swarm_vertical_direction_change_timer_4BD3]
	move.b	(a0),d0                         	| [$26ad: LD      A,(HL)]
	subq.b	#1,(a0)                         	| [$26ae: DEC     (HL)]
	tst.b	d0                               	| [$26af: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$26b0: RET     NZ] [...]
0:
	* time to change swarm vertical direction
	addq.b	#1,(a0)                         	| [$26b1: INC     (HL)]
	lea	average_vulture_y_pos_in_chars_4BD6,a0                        	| [$26b2: LD      L,$D6]
	move.b	(a0),d0                         	| [$26b4: LD      A,(HL)]
	cmp.b	#0x16,d0                         	| [$26b5: CP      $16]
	bcs.b	0f                               	| [...]
	rts                                    	| [$26b7: RET     NC] [...]
0:
	cmp.b	#0x08,d0                         	| [$26b8: CP      $08]
	bcc.b	0f                               	| [...]
	rts                                    	| [$26ba: RET     C] [...]
0:
	* only enters if vulture swarm is not too high or not too low
													| [$26bb: INC     L]
	sub.b	vulture_swarm_height_in_chars_4BD7,d0    | [$26bc: SUB     (HL)] subtract vulture_swarm_height_in_chars_4BD7
	rol.b	#1,d0                            	| [$26bd: RLCA] times 2
	move.b	d0,d1                           	| [$26be: LD      B,A]
	* this contains only XX where X is a digit, ex 11, EE, 33 ...
	move.b	repeated_bits_random_436F,d0                 	| [$26bf: LD      A,(repeated_bits_random_436F)]
	and.b	#0x03,d0                         	| [$26c2: AND     $03]
	* compute 0-3 value from random value above
	                        	| [$26c4: LD      L,$D4]
	move.b	d0,random_03_4BD4                         	| [$26c6: LD      (HL),A]
	not.b	d0                               	| [$26c7: CPL]
	and.b	#0x03,d0                         	| [$26c8: AND     $03]
	addq.b	#1,d0                           	| [$26ca: INC     A]
	move.b	d0,d2                           	| [$26cb: LD      C,A]
	jra	l_2476                             	| [$26cc: JP      $2476]
	                                    	| [$26cf: RET]
											
* entering here HL=$4Bxx
*

	
	DECL_ADDRESS	26d0
	
compute_vulture_swarm_dimensions_26d0:
	* compute d3 and d4 according to vultures positions
	lea	unknown_4BA8,a0                	| [$26d0: LD      HL,unknown_4BA8] end of vulture params
	move.w	#0x08,d1                      	| [$26d3: LD      BC,$0800] vulture struct size
	move.b	#0,d2
	move.b	#0x80,d3			| invalid init value
	move.b	#0,d4                      	| [$26d6: LD      DE,$8000]
l_26d9:
	tst.b	(a0)                         	| [$26d9: LD      A,(HL)] is vulture alive?
	                               	| [$26da: AND     A]
	jeq	l_26e5                             	| [$26db: JP      Z,$26E5] free slot? skip
	move.b	d3,d0                           	| [$26de: LD      A,D]
	rol.b	#1,d0                            	| [$26df: RLCA]	is it init value?
	jcc	l_26e4                             	| [$26e0: JP      NC,$26E4]
	move.b	d2,d3                           	| [$26e3: LD      D,C] first time: init with d2: index of lowest alive vulture
l_26e4:
	move.b	d2,d4                           	| [$26e4: LD      E,C]
l_26e5:
	addq.w	#1,d2                           	| [$26e5: INC     C]
 	                           	| [$26e6: LD      A,L]
	sub.w	d1,a0                            	| [$26e7: SUB     B]
	                           	| [$26e8: LD      L,A]
	cmp.l	#unknown_4BA8-0x40,a0                         	| [$26e9: CP      $68]
	jne	l_26d9                             	| [$26eb: JP      NZ,$26D9]
	* in the end:
	* d3: index of last alive vulture (starting from bottom)
	* d4: index of first alive vulture (starting from bottom)
	move.b	current_char_scroll_value_4BD2,d0                 	| [$26ee: LD      A,(current_char_scroll_value_4BD2)]
	add.b	d3,d0                            	| [$26f1: ADD     A,D]
	add.b	d4,d0                            	| [$26f2: ADD     A,E]
	and.b	#0x1F,d0                         	| [$26f3: AND     $1F]
	* average y position of the swarm
	move.b	d0,average_vulture_y_pos_in_chars_4BD6                 	| [$26f5: LD      (average_vulture_y_pos_in_chars_4BD6),A]
	move.b	d4,d0                           	| [$26f8: LD      A,E]
	sub.b	d3,d0                            	| [$26f9: SUB     D]
	* at start, it's 7, in the end it's 1 (2 adjacent vultures remaining)
	move.b	d0,vulture_swarm_height_in_chars_4BD7                 	| [$26fa: LD      (vulture_swarm_height_in_chars_4BD7),A]
	rts                                    	| [$26fd: RET]

	DECL_ADDRESS	2700
	
l_2700:
	lea	game_in_play_43A2,a0           	| [$2700: LD      HL,game_in_play_43A2]
	move.b	(a0),d0                         	| [$2703: LD      A,(HL)]
	                               	| [$2704: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$2705: RET     Z] [...]
0:
	addq.w	#1,a0                           	| [$2706: INC     L]
	move.b	(a0),d0                         	| [$2707: LD      A,(HL)] loads current_player_is_p2_43A3
	and.b	#0x01,d0                         	| [$2708: AND     $01]
	rol.b	#2,d0                            	| [$270a: RLCA] * 2
	add.b	#0x83,d0                         	| [$270c: ADD     $83] 4383 or 4387
	lea		fg_videoram_4000+0x300,a0
	moveq	#0,d6
	move.b	d0,d6                           	| [$270e: LD      L,A]
	add.w	d6,a0			| score end for player 1 or player 2
	st.b	d0                                	| [$270f: LD      A,$FF]
	move.b	d0,unknown_4397                 	| [$2711: LD      (unknown_4397),A]
	* check all enemies, see if we need to award scores
	lea	slot_for_regular_animation_4370,a1                	| [$2714: LD      DE,slot_for_regular_animation_4370]
l_2717:
	jbsr	award_enemy_score_if_needed_2748                            	| [$2717: CALL    $2748]
	addq.w	#3,a1                           	| [$271a: INC     E]
												| [$271d: LD      A,E]
	cmp.l	#slot_for_regular_animation_4370+0x10,a1                         	| [$271e: CP      $80]
	jne	l_2717                             	| [$2720: JP      NZ,$2717]
	lea		slot_for_regular_animation_4370+0x2D,a1                        	| [$2723: LD      E,$9D]
	move.b	game_state_43A4,d0              	| [$2725: LD      A,(game_state_43A4)]
	cmp.b	#STATE_BOSS_STAGE_COMPLETED,d0                         	| [$2728: CP      $06]
	jne	l_2739                             	| [$272a: JP      NZ,$2739]
	* boss stage completed!
	move.b	(a1),d0                         	| [$272d: LD      A,(DE)]
	move.b	d0,d1                           	| [$272e: LD      B,A]
	clr.b	d2                               	| [$272f: LD      C,$00]
	jbsr	AddToScore_0220                   	| [$2731: CALL    AddToScore_0220]
	clr.b	d0                               	| [$2734: XOR     A]
	move.b	d0,(a1)                         	| [$2735: LD      (DE),A]
	move.b	d0,unknown_4397                 	| [$2736: LD      (unknown_4397),A]
l_2739:
	move.b	unknown_4397,d0                 	| [$2739: LD      A,(unknown_4397)]
	                               	| [$273c: AND     A]
	bne.b	0f                               	| [...]
	jbsr	l_2768                            	| [$273d: CALL    Z,$2768]
0:
	*jbsr	handle_sounds_27a8                            	| [$2740: CALL    $27A8]
	jra	l_3a10                             	| [$2743: JP      $3A10]


award_enemy_score_if_needed_2748:
	move.b	(a1)+,d0                         	| [$2748: LD      A,(DE)]
	                           	| [$2749: INC     E]
 	cmp.b	#0x01,d0                         	| [$274a: CP      $01]
	beq.b	0f                               	| [...]
	rts                                    	| [$274c: RET     NZ] [...]
0:
	move.b	(a1),d0                         	| [$274d: LD      A,(DE)]
	                               	| [$274e: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$274f: RET     Z] [...]
0:
	ror.b	#4,d0                            	| [$2750: RRCA] * 4
	move.b	d0,d1                           	| [$2754: LD      B,A]
	and.b	#0xF0,d0                         	| [$2755: AND     $F0]
	move.b	d0,d2                           	| [$2757: LD      C,A]
	move.b	d1,d0                           	| [$2758: LD      A,B]
	and.b	#0x0F,d0                         	| [$2759: AND     $0F]
	move.b	d0,d1                           	| [$275b: LD      B,A]
	jbsr	AddToScore_0220                   	| [$275c: CALL    AddToScore_0220]
	clr.b	d0                               	| [$275f: XOR     A]
	move.b	d0,(a1)                         	| [$2760: LD      (DE),A]
	move.b	d0,unknown_4397                 	| [$2761: LD      (unknown_4397),A]
	rts                                    	| [$2764: RET]
	
	
l_2768:
	move.l	a0,-(sp)                        	| [$2768: PUSH    HL]
	move.w	#0x4261,d3                	| [$2769: LD      DE,unknown_4261]
	move.b	#0x06,d1                        	| [$276c: LD      B,$06]
	tst.b	current_player_is_p2_43A3                 	| [$276e: LD      A,(current_player_is_p2_43A3)]
	                               	| [$2771: AND     A]
	jeq	l_2778                             	| [$2772: JP      Z,$2778]
	move.w	#0x4021,d3                	| [$2775: LD      DE,unknown_4021]
l_2778:
	jbsr	write_digits_to_screen_00c4                            	| [$2778: CALL    $00C4]
	move.l	(sp)+,a0                        	| [$277b: POP     HL]
	lea	score_to_award_extra_life_43BD,a1                	| [$277c: LD      DE,score_to_award_extra_life_43BD]
	exg	a1,a0                              	| [$277f: EX      DE,HL]
	move.b	(a0)+,d0                         	| [$2780: LD      A,(HL)]
	                           	| [$2781: INC     L]
 	or.b	(a0),d0                           	| [$2782: OR      (HL)]
	bne.b	0f                               	| [...]
	rts                                    	| [$2783: RET     Z] [...]
0:
	addq.w	#1,a0                           	| [$2784: INC     L]
	exg	a1,a0                              	| [$2785: EX      DE,HL]
	jbsr	compare_scores_0314                            	| [$2786: CALL    $0314]
	bcs.b	0f                               	| [...]
	rts                                    	| [$2789: RET     NC] [...]
0:
	* score milestone reached, add one life to current player
	moveq	#0,d0
	move.b	current_player_is_p2_43A3,d0                 	| [$278a: LD      A,(current_player_is_p2_43A3)]
												| [$278d: ADD     $90]
	lea		nb_lives_p1_4390,a0
	add.w	d0,a0                           	| [$278f: LD      L,A]
	addq.b	#1,(a0)                         	| [$2790: INC     (HL)]
	jbsr	display_players_lives_0367                            	| [$2791: CALL    $0367]
	                                	| [$2794: LD      A,$FF]
	st.b	extra_life_beep_timer_436A                 	| [$2796: LD      (extra_life_beep_timer_436A),A]
	lea	extra_life_at_thousands_43BE,a0                        	| [$2799: LD      L,$BE]
	move.b	(a0),d0                         	| [$279b: LD      A,(HL)]
	clr.b	(a0)                             	| [$279c: LD      (HL),$00]
	* multiply by 10 (BCD), if at 3000, next life at 30000, if at 30000... never
	ror.b	#4,d0                            	| [$279e: RRCA] * 4
	                           	| [$27a2: DEC     L]
	move.b	d0,-(a0)                         	| [$27a3: LD      (HL),A]
	rts                                    	| [$27a4: RET]
	
handle_sounds_27a8:
	lea	sound_buffer_438C,a0                	| [$27a8: LD      HL,sound_buffer_438C]
	move.b	(a0)+,d0                         	| [$27ab: LD      A,(HL)]
	*move.b	d0,sound_6000                 	| [$27ac: LD      (sound_6000),A] 60xx sound A
	                           	| [$27af: INC     L]
 	move.b	(a0),d0                         	| [$27b0: LD      A,(HL)]
	*move.b	d0,sound_6800                 	| [$27b1: LD      (sound_6800),A] 68xx sound B
	or.b	#0x0F,d0                          	| [$27b4: OR      $0F]
	move.b	d0,(a0)                         	| [$27b6: LD      (HL),A]
	                           	| [$27b7: DEC     L]
 	move.b	#0x0F,-(a0)                      	| [$27b8: LD      (HL),$0F] acknowledge?
	rts                                    	| [$27ba: RET]
	
* used for player shots and explosions

noise_generation_27bd:
	lea	unknown_4363,a0                	| [$27bd: LD      HL,unknown_4363]
	move.b	(a0),d0                         	| [$27c0: LD      A,(HL)]
	                               	| [$27c1: AND     A]
	jne	l_27e2                             	| [$27c2: JP      NZ,$27E2]
	lea	shot_sound_counter_4361,a0                        	| [$27c5: LD      L,$61]
	move.b	(a0),d0                         	| [$27c7: LD      A,(HL)]
	                               	| [$27c8: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$27c9: RET     Z] [...]
0:
	* player shot noise
	cmp.b	#0x19,d0                         	| [$27ca: CP      $19]
	jcc	l_27d8                             	| [$27cc: JP      NC,$27D8]
	subq.b	#1,(a0)                         	| [$27cf: DEC     (HL)]
	lea	sound_buffer_438C,a0                        	| [$27d0: LD      L,$8C]
	move.b	(a0),d0                         	| [$27d2: LD      A,(HL)]
	or.b	#0x40,d0                          	| [$27d3: OR      $40]
	move.b	d0,(a0)                         	| [$27d5: LD      (HL),A]
	rts                                    	| [$27d6: RET]
	                         	| [$27d7: LD      (HL),A]
l_27d8:
	move.b	#0x18,(a0)                      	| [$27d8: LD      (HL),$18]
	lea	sound_buffer_438C,a0                        	| [$27da: LD      L,$8C]
	move.b	(a0),d0                         	| [$27dc: LD      A,(HL)]
	and.b	#0xBF,d0                         	| [$27dd: AND     $BF]
	move.b	d0,(a0)                         	| [$27df: LD      (HL),A]
	rts                                    	| [$27e0: RET]
	
	
l_27e2:
	cmp.b	#0x40,d0                         	| [$27e2: CP      $40]
	jcs	l_27e9                             	| [$27e4: JP      C,$27E9]
	move.b	#0x40,(a0)                      	| [$27e7: LD      (HL),$40]
l_27e9:
	subq.b	#1,(a0)                         	| [$27e9: DEC     (HL)]
	lea	sound_buffer_438C,a0                        	| [$27ea: LD      L,$8C]
	move.b	#0x8F,(a0)                      	| [$27ec: LD      (HL),$8F] noise
	rts                                    	| [$27ee: RET]

* if not called, birds just move left and right
handle_small_birds_attacks_3000:
	lea	birds_attack_counter_4393,a0                	| [$3000: LD      HL,birds_attack_counter_4393]
	move.b	(a0),d0                         	| [$3003: LD      A,(HL)]
	addq.b	#1,(a0)                         	| [$3004: INC     (HL)]
	and.w	#0x07,d0                         	| [$3005: AND     $07]
	lea	jump_table_3018,a0             	| [$3007: LD      HL,jump_table_3018]
	add.w	d0,d0                         	| [$300a: RLCA]
	add.w	d0,d0                         	| [$300b: ADD     A,L]
	move.l	(a0,d0.w),a0               	| [$300c: LD      L,A]
	                        	| [$300d: LD      A,(HL)]
	                        	| [$300e: INC     HL]
	                        	| [$300f: LD      L,(HL)]
	                        	| [$3010: LD      H,A]
	jra	(a0)                               	| [$3011: JP      (HL)]
l_3012:
	rts                                    	| [$3012: RET]


jump_table_3018:
	.long	l_3264
	.long	l_3028
	.long	l_30ba
	.long	l_3124
	.long	l_315a
	.long	l_31b4
	.long	l_322c
	.long	l_3012

l_3028:
	lea	unknown_4357,a0                	| [$3028: LD      HL,unknown_4357]
	move.b	(a0),d0                         	| [$302b: LD      A,(HL)]
	cmp.b	#0x03,d0                         	| [$302c: CP      $03]
	bcs.b	0f                               	| [...]
	rts                                    	| [$302e: RET     NC] [...]
0:
	lea	unknown_4350,a0                        	| [$302f: LD      L,$50]
	move.b	(a0),d0                         	| [$3031: LD      A,(HL)]
	cmp.b	#0x04,d0                         	| [$3032: CP      $04]
	bcs.b	0f                               	| [...]
	rts                                    	| [$3034: RET     NC] [...]
0:
	lea	unknown_4358,a0                        	| [$3035: LD      L,$58]
	move.b	(a0),d0                         	| [$3037: LD      A,(HL)]
	                               	| [$3038: AND     A]
	jeq	l_305c                             	| [$3039: JP      Z,$305C]
	subq.b	#1,(a0)                         	| [$303c: DEC     (HL)]
	beq.b	0f                               	| [...]
	rts                                    	| [$303d: RET     NZ] [...]
0:
	                           	| [$303e: DEC     L]
 	addq.b	#1,-(a0)                         	| [$303f: INC     (HL)]
	lea	unknown_4350,a0                        	| [$3040: LD      L,$50]
	move.b	#0x04,(a0)                      	| [$3042: LD      (HL),$04]
	lea	unknown_4353,a0                        	| [$3044: LD      L,$53]
	move.b	#0x10,(a0)+                      	| [$3046: LD      (HL),$10]
	                           	| [$3048: INC     L]
	move.b	#0x50,(a0)                      	| [$3049: LD      (HL),$50]
	lea	unknown_4351,a0                        	| [$304b: LD      L,$51]
	move.b	#0x2E,(a0)+                      	| [$304d: LD      (HL),$2E]
	                           	| [$304f: INC     L]
 	clr.b	(a0)                             	| [$3050: LD      (HL),$00]
	move.b	player_ship_x_43C2,d0           	| [$3052: LD      A,(player_ship_x_43C2)]
	ror.b	#1,d0                            	| [$3055: RRCA]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3056: RET     C] [...]
0:
	move.b	#0x40,(a0)                      	| [$3057: LD      (HL),$40]
	rts                                    	| [$3059: RET]
l_305c:
	jbsr	l_3074                            	| [$305c: CALL    $3074]
	lea	unknown_4357,a0                	| [$305f: LD      HL,unknown_4357]
	move.b	(a0),d0                         	| [$3062: LD      A,(HL)]
	rol.b	#2,d0                            	| [$3063: RLCA] * 2
	                                    	| [$3065: NOP]
	                                    	| [$3066: NOP]
	add.b	d2,d0                            	| [$3067: ADD     A,C]
	addq.b	#0x07,d0                        	| [$3068: ADD     $07]
	lea	unknown_4358,a0                        	| [$306a: LD      L,$58]
	move.b	d0,(a0)                         	| [$306c: LD      (HL),A]
	rts                                    	| [$306d: RET]

l_3074:
	lea	current_stage_43B8,a0          	| [$3074: LD      HL,current_stage_43B8]
	move.b	(a0),d0                         	| [$3077: LD      A,(HL)]
	ror.b	#1,d0                            	| [$3078: RRCA]
	                                    	| [$3079: NOP]
	and.b	#0x07,d0                         	| [$307a: AND     $07]
	move.b	d0,d1                           	| [$307c: LD      B,A]
	move.b	#0x07,d0                        	| [$307d: LD      A,$07]
	sub.b	d1,d0                            	| [$307f: SUB     B]
	move.b	d0,d2                           	| [$3080: LD      C,A]
	move.b	(a0),d0                         	| [$3081: LD      A,(HL)]
	cmp.b	#0x80,d0                         	| [$3082: CP      $80]
	jcs	l_3089                             	| [$3084: JP      C,$3089]
	move.b	#0x70,d0                        	| [$3087: LD      A,$70]
l_3089:
	ror.b	#1,d0                            	| [$3089: RRCA]
	ror.b	#3,d0                            	| [$308a: RRCA] * 3
	and.b	#0x07,d0                         	| [$308d: AND     $07]
	move.b	d0,d1                           	| [$308f: LD      B,A]
	move.b	#0x07,d0                        	| [$3090: LD      A,$07]
	sub.b	d1,d0                            	| [$3092: SUB     B]
	add.b	d2,d0                            	| [$3093: ADD     A,C]
	move.b	d0,d2                           	| [$3094: LD      C,A]
	move.b	nb_birds_to_kill_before_stage_completed_43BA,d0	| [$3095: LD      A,(nb_birds_to_kill_before_stage_completed_43BA)]
	subq.b	#0x05,d0                        	| [$3098: SUB     $05]
	jcc	l_309f                             	| [$309a: JP      NC,$309F]
	move.b	#0x10,d0                        	| [$309d: LD      A,$10]
l_309f:
	add.b	d2,d0                            	| [$309f: ADD     A,C]
	move.b	d0,d2                           	| [$30a0: LD      C,A]
	jbsr	get_random_value_30aa                            	| [$30a1: CALL    $30AA]
	and.b	#0x07,d0                         	| [$30a4: AND     $07]
	add.b	d2,d0                            	| [$30a6: ADD     A,C]
	move.b	d0,d2                           	| [$30a7: LD      C,A]
	rts                                    	| [$30a8: RET]
	
* random value influenced by player ship X
get_random_value_30aa:
	lea	random_seed_counter_value_439B,a0                	| [$30aa: LD      HL,random_seed_counter_value_439B] counter
	move.b	(a0),d0                         	| [$30ad: LD      A,(HL)]
	rol.b	#3,d0                            	| [$30ae: RLCA] * 3
	and.b	#0x07,d0                         	| [$30b1: AND     $07]
	lea	player_ship_x_43C2,a0                        	| [$30b3: LD      L,$C2]
	add.b	(a0),d0                          	| [$30b5: ADD     A,(HL)]
	and.b	#0x0F,d0                         	| [$30b6: AND     $0F]
	rts                                    	| [$30b8: RET]

l_30ba:
	lea	unknown_4358,a0                	| [$30ba: LD      HL,unknown_4358]
	jbsr	l_30da                            	| [$30bd: CALL    $30DA]
	jbsr	l_30da                            	| [$30c0: CALL    $30DA]
	jbsr	l_30da                            	| [$30c3: CALL    $30DA]
	lea	unknown_4350,a0                        	| [$30c6: LD      L,$50]
	move.b	(a0),d0                         	| [$30c8: LD      A,(HL)]
	                               	| [$30c9: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$30ca: RET     NZ] [...]
0:
	lea	unknown_4355,a0                        	| [$30cb: LD      L,$55]
	move.b	(a0),d0                         	| [$30cd: LD      A,(HL)]
	                               	| [$30ce: AND     A]
	jeq	l_30e4                             	| [$30cf: JP      Z,$30E4]
	subq.b	#1,(a0)                         	| [$30d2: DEC     (HL)]
	beq.b	0f                               	| [...]
	rts                                    	| [$30d3: RET     NZ] [...]
0:
	lea	unknown_4350,a0                        	| [$30d4: LD      L,$50]
	move.b	#0x01,(a0)                      	| [$30d6: LD      (HL),$01]
	rts                                    	| [$30d8: RET]
	
l_30da:
	addq.w	#1,a0                         	| [$30da: INC     L]
	move.b	(a0),d0                         	| [$30db: LD      A,(HL)]
	                               	| [$30dc: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$30dd: RET     Z] [...]
0:
	subq.b	#1,(a0)                         	| [$30de: DEC     (HL)]
	rts                                    	| [$30df: RET]
											| [$30e0: LD      A,(HL)]
											| [$30e1: CP      $01]
											| [...]
										| [$30e3: RET     NC] [...]
						
l_30e4:
	jbsr	l_3074                            	| [$30e4: CALL    $3074]
	lea	counter_439A,a0                	| [$30e7: LD      HL,counter_439A]
	move.b	(a0),d0                         	| [$30ea: LD      A,(HL)]
	cmp.b	#0x10,d0                         	| [$30eb: CP      $10]
	jcs	l_30f2                             	| [$30ed: JP      C,$30F2]
	move.b	#0x0F,d0                        	| [$30f0: LD      A,$0F]
l_30f2:
	move.b	d0,d1                           	| [$30f2: LD      B,A]
	move.b	#0x0F,d0                        	| [$30f3: LD      A,$0F]
	sub.b	d1,d0                            	| [$30f5: SUB     B]
	add.b	d2,d0                            	| [$30f6: ADD     A,C]
	move.b	d0,d2                           	| [$30f7: LD      C,A]
	move.b	#0x01,d1                        	| [$30f8: LD      B,$01]
	lea	unknown_4358,a0                        	| [$30fa: LD      L,$58]
	jbsr	l_3112                            	| [$30fc: CALL    $3112]
	jbsr	l_3112                            	| [$30ff: CALL    $3112]
	jbsr	l_3112                            	| [$3102: CALL    $3112]
	move.b	d2,d0                           	| [$3105: LD      A,C]
	ror.b	#2,d0                            	| [$3106: RRCA] * 2
	and.b	#0x3F,d0                         	| [$3108: AND     $3F]
	addq.b	#0x01,d0                        	| [$310a: ADD     $01]
	lea	unknown_4355,a0                        	| [$310c: LD      L,$55]
	move.b	d0,(a0)                         	| [$310e: LD      (HL),A]
	rts                                    	| [$310f: RET]
	
l_3112:
	addq.w	#1,a0                | [$3112: INC     L]
	move.b	(a0),d0                         	| [$3113: LD      A,(HL)]
	                               	| [$3114: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$3115: RET     NZ] [...]
0:
	move.b	d2,d0                           	| [$3116: LD      A,C]
	ror.b	#1,d0                            	| [$3117: RRCA]
	and.b	#0x7F,d0                         	| [$3118: AND     $7F]
	move.b	d0,d2                           	| [$311a: LD      C,A]
	move.b	d1,d0                           	| [$311b: LD      A,B]
	                               	| [$311c: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$311d: RET     Z] [...]
0:
	subq.b	#1,d1                           	| [$311e: DEC     B]
	move.b	#0x0C,(a0)                      	| [$311f: LD      (HL),$0C]
	rts                                    	| [$3121: RET]
									| [$3122: ADD     A,(HL)]
									| [$3123: LD      B,A]
l_3124:
	lea	unknown_4350,a0                	| [$3124: LD      HL,unknown_4350]
	move.b	(a0),d0                         	| [$3127: LD      A,(HL)]
	cmp.b	#0x01,d0                         	| [$3128: CP      $01]
	beq.b	0f                               	| [...]
	rts                                    	| [$312a: RET     NZ] [...]
0:
	move.b	#0x02,(a0)                      	| [$312b: LD      (HL),$02]
	lea	current_stage_43B8,a0                        	| [$312d: LD      L,$B8]
	move.b	(a0),d0                         	| [$312f: LD      A,(HL)]
	ror.b	#2,d0                            	| [$3130: RRCA] * 2
	and.b	#0x0F,d0                         	| [$3132: AND     $0F]
	addq.b	#0x05,d0                        	| [$3134: ADD     $05]
	cmp.b	#0x11,d0                         	| [$3136: CP      $11]
	jcs	l_313d                             	| [$3138: JP      C,$313D]
	move.b	#0x05,d0                        	| [$313b: LD      A,$05]
l_313d:
	lea	unknown_4357,a0                        	| [$313d: LD      L,$57]
	sub.b	(a0),d0                          	| [$313f: SUB     (HL)]
	move.b	d0,d1                           	| [$3140: LD      B,A]
	jbsr	get_random_value_30aa                            	| [$3141: CALL    $30AA]
	addq.b	#1,d0                           	| [$3144: INC     A]
	cmp.b	d1,d0                            	| [$3145: CP      B]
	jcs	l_314b                             	| [$3146: JP      C,$314B]
	move.b	#0x01,d0                        	| [$3149: LD      A,$01]
l_314b:
	lea	unknown_4353,a0                        	| [$314b: LD      L,$53]
	move.b	d0,(a0)                         	| [$314d: LD      (HL),A]
	rts                                    	| [$314e: RET]

l_315a:
	lea	unknown_4350,a0                	| [$315a: LD      HL,unknown_4350]
	move.b	(a0),d0                         	| [$315d: LD      A,(HL)]
	cmp.b	#0x02,d0                         	| [$315e: CP      $02]
	beq.b	0f                               	| [...]
	rts                                    	| [$3160: RET     NZ] [...]
0:
	jbsr	get_random_value_30aa                            	| [$3161: CALL    $30AA]
	                                    	| [$3164: NOP]
	move.b	d0,d1                           	| [$3165: LD      B,A]
	rol.b	#1,d0                            	| [$3166: RLCA]
	add.b	#0x50,d0                         	| [$3167: ADD     $50]
	move.b	d0,d6                           	| [$3169: LD      L,A]
	move.b	#0x4B,d5                        	| [$316a: LD      H,$4B]
	move.b	d1,d0                           	| [$316c: LD      A,B]
	rol.b	#2,d0                            	| [$316d: RLCA] * 2
	add.b	#0x70,d0                         	| [$316f: ADD     $70]
	move.b	d0,d4                           	| [$3171: LD      E,A]
	move.b	#0x4B,d3                        	| [$3172: LD      D,$4B]
	move.b	#0x10,d2                        	| [$3174: LD      C,$10]
	move.b	d2,d0                           	| [$3176: LD      A,C]
	sub.b	d1,d0                            	| [$3177: SUB     B]
	move.b	d0,d1                           	| [$3178: LD      B,A]
	bsr		load_ram_in_a1_from_d3d4
	bsr		load_ram_in_a0_from_d5d6
l_3179:
	jbsr	l_3192                            	| [$3179: CALL    $3192]
	addq.w	#4,a1                           	| [$317c: INC     DE] * 4
	addq.w	#2,a0                           	| [$3180: INC     HL] * 2
	subq.b	#1,d1                           	| [$3182: DEC     B]
	jne	l_318a                             	| [$3183: JP      NZ,$318A]
	lea 	bird_data_4B70,a1                        	| [$3186: LD      E,$70] D3=$4B above
	lea		unknown_4B50,a0                        	| [$3188: LD      L,$50] D5=$4B above
l_318a:
	subq.b	#1,d2                           	| [$318a: DEC     C]
	jne	l_3179                             	| [$318b: JP      NZ,$3179]
	rts                                    	| [$318e: RET]

l_3192:
	move.b	(a1),d0                         	| [$3192: LD      A,(DE)]
	and.b	#0x08,d0                         	| [$3193: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$3195: RET     Z] [...]
0:
	move.b	unknown_4394,d0                 	| [$3196: LD      A,(unknown_4394)]
	cmp.b	(a0),d0                          	| [$3199: CP      (HL)]
	beq.b	0f                               	| [...]
	rts                                    	| [$319a: RET     NZ] [...]
0:
	move.b	unknown_4356,d0                 	| [$319b: LD      A,(unknown_4356)]
												| [$319e: INC    L]
	move.b	(1,a0),d1                         	| [$319f: LD      B,(HL)]
												| [$31a0: DEC     L]
 	cmp.b	d1,d0                            	| [$31a1: CP      B]
	beq.b	0f                               	| [...]
	rts                                    	| [$31a2: RET     NZ] [...]
0:
	* recompute low-nibble offset from base address
	move.l	a0,d0
	sub.l	#unknown_4350-0x50,d0                           	| [$31a3: LD      A,L]
	move.b	d0,offset_from_4300_4354                 	| [$31a4: LD      (offset_from_4300_4354),A]
	move.b	#0x03,d0                        	| [$31a7: LD      A,$03]
	move.b	d0,unknown_4350                 	| [$31a9: LD      (unknown_4350),A]
	move.l	(sp)+,a0                        	| [$31ac: POP     HL]
	rts                                    	| [$31ad: RET]

l_31b4:
	move.b	unknown_4350,d0                 	| [$31b4: LD      A,(unknown_4350)]
	cmp.b	#0x03,d0                         	| [$31b7: CP      $03]
	beq.b	0f                               	| [...]
	rts                                    	| [$31b9: RET     NZ] [...]
0:
	move.b	offset_from_4300_4354,d0                 	| [$31ba: LD      A,(offset_from_4300_4354)]
	sub.b	#0x50,d0                         	| [$31bd: SUB     $50]
	rol.b	#1,d0                            	| [$31bf: RLCA]
	add.b	#0x72,d0                         	| [$31c0: ADD     $72]
	move.b	d0,d6                           	| [$31c2: LD      L,A]
	move.b	#0x4B,d5                        	| [$31c3: LD      H,$4B]
	jbsr	load_ram_in_a0_from_d5d6
	move.b	(a0)+,d1                         	| [$31c5: LD      B,(HL)]
	                           	| [$31c6: INC     L]
	move.b	(a0),d3                         	| [$31c7: LD      D,(HL)]
	move.b	player_ship_x_43C2,d0           	| [$31c8: LD      A,(player_ship_x_43C2)]
	move.b	#0x04,d2                        	| [$31cb: LD      C,$04]
	cmp.b	d1,d0                            	| [$31cd: CP      B]
	jcc	l_31d6                             	| [$31ce: JP      NC,$31D6]
	move.b	d0,d2                           	| [$31d1: LD      C,A]
	move.b	d1,d0                           	| [$31d2: LD      A,B]
	move.b	d2,d1                           	| [$31d3: LD      B,C]
	clr.b	d2                               	| [$31d4: LD      C,$00]
l_31d6:
	sub.b	d1,d0                            	| [$31d6: SUB     B]
	rol.b	#3,d0                            	| [$31d7: RLCA] * 3
	and.b	#0x07,d0                         	| [$31da: AND     $07]
	                        	| [$31dc: ADD     $00]
	move.b	d0,d6                           	| [$31de: LD      L,A]
	move.b	#0x33,d5                        	| [$31df: LD      H,$33]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0),d0                         	| [$31e1: LD      A,(HL)]
	add.b	d2,d0                            	| [$31e2: ADD     A,C]
	rol.b	#2,d0                            	| [$31e3: RLCA] * 2
	move.b	d0,d2                           	| [$31e5: LD      C,A]
														| [$31e6: NOP]
														| [$31e7: NOP]
														| [$31e8: NOP]
	move.b	unknown_4357,d0                 	| [$31e9: LD      A,(unknown_4357)]
	move.b	d0,d1                           	| [$31ec: LD      B,A]
	jbsr	l_3210                            	| [$31ed: CALL    $3210]
	move.b	d2,d0                           	| [$31f0: LD      A,C]
	add.b	d1,d0                            	| [$31f1: ADD     A,B]
	add.b	#0x10,d0                         	| [$31f2: ADD     $10]
	move.b	d0,d6                           	| [$31f4: LD      L,A]
	move.b	#0x33,d5                        	| [$31f5: LD      H,$33]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0),d2                         	| [$31f7: LD      C,(HL)]
	jbsr	get_random_value_30aa                            	| [$31f8: CALL    $30AA]
	and.b	#0x06,d0                         	| [$31fb: AND     $06]
	add.b	d2,d0                            	| [$31fd: ADD     A,C]
	move.b	d0,d6                           	| [$31fe: LD      L,A]
	move.b	#0x33,d5                        	| [$31ff: LD      H,$33]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0)+,d0                         	| [$3201: LD      A,(HL)]
	                           	| [$3202: INC     L]
 	move.b	(a0),d1                         	| [$3203: LD      B,(HL)]
	lea	unknown_4350,a0                	| [$3204: LD      HL,unknown_4350]
	move.b	#0x05,(a0)+                      	| [$3207: LD      (HL),$05]
	                           	| [$3209: INC     L]
 	move.b	d0,(a0)+                         	| [$320a: LD      (HL),A]
	                           	| [$320b: INC     L]
	move.b	d1,(a0)                         	| [$320c: LD      (HL),B]
	rts                                    	| [$320d: RET]
l_3210:
	move.b	unknown_4353,d0                 	| [$3210: LD      A,(unknown_4353)]
	cmp.b	#0x01,d0                         	| [$3213: CP      $01]
	beq.b	0f                               	| [...]
	rts                                    	| [$3215: RET     NZ] [...]
0:
	move.b	d3,d0                           	| [$3216: LD      A,D]
	clr.b	d1                               	| [$3217: LD      B,$00]
	cmp.b	#0x58,d0                         	| [$3219: CP      $58]
	bcc.b	0f                               	| [...]
	rts                                    	| [$321b: RET     C] [...]
0:
	move.b	#0x01,d1                        	| [$321c: LD      B,$01]
	cmp.b	#0x78,d0                         	| [$321e: CP      $78]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3220: RET     C] [...]
0:
	move.b	#0x02,d1                        	| [$3221: LD      B,$02]
	cmp.b	#0x98,d0                         	| [$3223: CP      $98]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3225: RET     C] [...]
0:
	move.b	#0x03,d1                        	| [$3226: LD      B,$03]
	rts                                    	| [$3228: RET]
	beq.b	0f                               	| [...]
	rts                                    	| [$3229: RET     NZ] [...]
0:
l_322c:
	move.b	unknown_4350,d0                 	| [$322C: LD      A,(unknown_4350)
	cmp.b	#0x04,d0                         	| [$322f: CP      $04]
	beq.b	0f                               	| [...]
	rts                                    	| [$3231: RET     NZ] [...]
0:
	lea	unknown_4B50,a0                	| [$3232: LD      HL,unknown_4B50]
	lea	bird_data_4B70,a1                	| [$3235: LD      DE,bird_data_4B70]
	move.b	unknown_4356,d0                 	| [$3238: LD      A,(unknown_4356)]
	move.b	d0,d2                           	| [$323b: LD      C,A]
	move.b	unknown_4394,d0                 	| [$323c: LD      A,(unknown_4394)]
	move.b	d0,d1                           	| [$323f: LD      B,A]
l_3240:
	move.b	(a1),d0                         	| [$3240: LD      A,(DE)]
	and.b	#0x08,d0                         	| [$3241: AND     $08]
	jeq	l_324e                             	| [$3243: JP      Z,$324E]
	move.b	(a0),d0                         	| [$3246: LD      A,(HL)]
	cmp.b	d1,d0                            	| [$3247: CP      B]
	beq.b	0f                               	| [...]
	rts                                    	| [$3248: RET     NZ] [...]
0:
	                           	| [$3249: INC     L]
	move.b	(1,a0),d0                         	| [$324a: LD      A,(HL)]
	                           	| [$324b: DEC     L]
	cmp.b	d2,d0                            	| [$324c: CP      C]
	beq.b	0f                               	| [...]
	rts                                    	| [$324d: RET     NZ] [...]
0:
l_324e:
	addq.w	#2,a0                           	| [$324e: INC     L]
	                           	| [$324f: INC     L]
	                           	| [$3250: LD      A,E]
	addq.w	#0x04,a1                        	| [$3251: ADD     $04]
	                           	| [$3253: LD      E,A]
	cmp.l	#unknown_4BB0,a1                         	| [$3254: CP      $B0]
	jne	l_3240                             	| [$3256: JP      NZ,$3240]
	move.b	#0x06,d0                        	| [$3259: LD      A,$06]
	move.b	d0,unknown_4350                 	| [$325b: LD      (unknown_4350),A]
	rts                                    	| [$325e: RET]
	
l_3264:
	lea	unknown_4395,a0                	| [$3264: LD      HL,unknown_4395]
	move.b	(a0),d0                         	| [$3267: LD      A,(HL)]
	move.b	d0,unknown_4356                 	| [$3268: LD      (unknown_4356),A]
	addq.b	#1,d0                           	| [$326b: INC     A]
	and.b	#0x0F,d0                         	| [$326c: AND     $0F]
	move.b	d0,(a0)                         	| [$326e: LD      (HL),A]
	lea	unknown_4350,a0                        	| [$326f: LD      L,$50]
	move.b	(a0),d0                         	| [$3271: LD      A,(HL)]
	cmp.b	#0x05,d0                         	| [$3272: CP      $05]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3274: RET     C] [...]
0:
	clr.b	(a0)                             	| [$3275: LD      (HL),$00]
	lea	unknown_4353,a0                        	| [$3277: LD      L,$53]
	move.b	(a0)+,d2                         	| [$3279: LD      C,(HL)]
	                           	| [$327a: INC     L]
	moveq	#0,d6
	move.b	(a0),d6                         	| [$327b: LD      L,(HL)]
	lea		unknown_4B50-0x50,a0				| [$327c: LD      H,$4B]
	add.w	d6,a0
	                        	
	move.b	unknown_4356,d0                 	| [$327e: LD      A,(unknown_4356)]
	move.b	d0,d3                           	| [$3281: LD      D,A]
	move.b	unknown_4394,d0                 	| [$3282: LD      A,(unknown_4394)]
	move.b	d0,d4                           	| [$3285: LD      E,A]
	move.b	d6,d0                           	| [$3286: LD      A,L]
	sub.b	#0x50,d0                         	| [$3287: SUB     $50]
	ror.b	#1,d0                            	| [$3289: RRCA]
	move.b	d0,d1                           	| [$328a: LD      B,A]
	move.b	#0x10,d0                        	| [$328b: LD      A,$10]
	sub.b	d1,d0                            	| [$328d: SUB     B]
	move.b	d0,d1                           	| [$328e: LD      B,A]
l_328f:
	move.b	(a0)+,d0                         	| [$328f: LD      A,(HL)]
												| [$3290: INC     L]
	cmp.b	d4,d0                            	| [$3291: CP      E]
	jne	l_32a4                             	| [$3292: JP      NZ,$32A4]
	move.b	(a0),d0                         	| [$3295: LD      A,(HL)]
	cmp.b	d3,d0                            	| [$3296: CP      D]
	jne	l_32a4                             	| [$3297: JP      NZ,$32A4]
	subq.w	#1,a0                           	| [$329a: DEC     L]
	move.b	unknown_4351,d0                 	| [$329b: LD      A,(unknown_4351)]
	move.b	d0,(a0)+                         	| [$329e: LD      (HL),A]
	                           	| [$329f: INC     L]
	move.b	unknown_4352,d0                 	| [$32a0: LD      A,(unknown_4352)]
	move.b	d0,(a0)                         	| [$32a3: LD      (HL),A]
l_32a4:
	addq.w	#1,a0                           	| [$32a4: INC     L]
	subq.b	#1,d1                           	| [$32a5: DEC     B]
	jne	l_32ab                             	| [$32a6: JP      NZ,$32AB]
	lea	unknown_4350,a0                        	| [$32a9: LD      L,$50]
l_32ab:
	subq.b	#1,d2                           	| [$32ab: DEC     C]
	jne	l_328f                             	| [$32ac: JP      NZ,$328F]
	rts                                    	| [$32af: RET]

	DECL_ADDRESS	32b0
	
l_32b0:
	lea	unknown_4350,a0                	| [$32b0: LD      HL,unknown_4350]
	move.b	#0x30,d1                        	| [$32b3: LD      B,$30]
	jbsr	clear_area_05D8                   	| [$32b5: CALL    clear_area_05D8]
	lea	counter_439A,a0                        	| [$32b8: LD      L,$9A]
	move.b	#0x04,d1                        	| [$32ba: LD      B,$04]
	jbsr	clear_area_05D8                   	| [$32bc: CALL    clear_area_05D8]
	move.b	nb_vultures_to_kill_before_stage_completed_43BB,d0                 	| [$32bf: LD      A,(nb_vultures_to_kill_before_stage_completed_43BB)]
	                               	| [$32c2: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$32c3: RET     Z] [...]
0:
	rol.b	#3,d0                            	| [$32c4: RLCA] * 3
	move.b	d0,d2                           	| [$32c7: LD      C,A]
	lea	bird_data_4B70,a0                	| [$32c8: LD      HL,bird_data_4B70]
	move.b	#0x40,d1                        	| [$32cb: LD      B,$40]
	jbsr	clear_area_05D8                   	| [$32cd: CALL    clear_area_05D8]
	move.b	#0x4B,d3                        	| [$32d0: LD      D,$4B]
	move.b	#0x3F,d5                        	| [$32d2: LD      H,$3F]
	move.b	#0x40,d0                        	| [$32d4: LD      A,$40]
	sub.b	d2,d0                            	| [$32d6: SUB     C]
	add.b	#0x70,d0                         	| [$32d7: ADD     $70]
	move.b	d0,d4                           	| [$32d9: LD      E,A]
	add.b	#0x10,d0                         	| [$32da: ADD     $10]
	move.b	d0,d6                           	| [$32dc: LD      L,A]
	move.b	d2,d1                           	| [$32dd: LD      B,C]
	jbsr	load_rom_in_a0_from_d5d6
	jbsr	load_ram_in_a1_from_d3d4
	move.b	current_stage_43B8,d0           	| [$32de: LD      A,(current_stage_43B8)]
	ror.b	#2,d0                            	| [$32e1: RRCA] * 2
	jcc	copy_memory_05e0                             	| [$32e3: JP      NC,$05E0]
	                           	| [$32e6: LD      A,L]
	add.w	#0x40,a0                         	| [$32e7: ADD     $40]
	                           	| [$32e9: LD      L,A]
	
	jra	copy_memory_05e0                             	| [$32ea: JP      $05E0]
	
	                  	| [$32ed: CALL    $05E0]
	                          	| [$32f0: JP      $03A0]



vultures_level_3400:
	jbsr	common_game_routines_0876                            	| [$3400: CALL    $0876]
	jbsr	player_shots_vs_vultures_collision_3800	| [$3403: CALL    player_shots_vs_vultures_collision_3800]
	jbsr	handle_vultures_y_2600                            	| [$3406: CALL    $2600]
	jbsr	player_shots_vs_vultures_collision_3800	| [$3409: CALL    player_shots_vs_vultures_collision_3800]
	jbsr	l_3980                            	| [$340c: CALL    $3980]
	move.b	nb_vultures_to_kill_before_stage_completed_43BB,d0                 	| [$340f: LD      A,(nb_vultures_to_kill_before_stage_completed_43BB)]
	                               	| [$3412: AND     A]
	jeq	l_3462                             	| [$3413: JP      Z,$3462]
	cmp.b	#0x04,d0                         	| [$3416: CP      $04]
	jcc	l_3438                             	| [$3418: JP      NC,$3438]
	jbsr	animate_vultures_3474                            	| [$341b: CALL    $3474]
	jbsr	animate_vultures_3486                            	| [$341e: CALL    $3486]
	jbsr	animate_vulture_wings_3560                            	| [$3421: CALL    $3560]
	jbsr	l_3498                            	| [$3424: CALL    $3498]
	jbsr	l_34aa                            	| [$3427: CALL    $34AA]
	move.b	random_seed_counter_value_439B,d0                    	| [$342a: LD      A,(random_seed_counter_value_439B)]
	ror.b	#1,d0                            	| [$342d: RRCA]
	jcs	l_0fc0                             	| [$342e: JP      C,$0FC0]
	jbsr	vultures_shoot_decision_3930                            	| [$3431: CALL    $3930]
	jra	l_0c40                             	| [$3434: JP      $0C40]
l_3438:
	move.b	random_seed_counter_value_439B,d0                    	| [$3438: LD      A,(random_seed_counter_value_439B)]
	ror.b	#1,d0                            	| [$343b: RRCA]
	jcs	l_3452                             	| [$343c: JP      C,$3452]
	jbsr	animate_vultures_3474                            	| [$343f: CALL    $3474]
	jbsr	animate_vulture_wings_3560                            	| [$3442: CALL    $3560]
	jbsr	l_3498                            	| [$3445: CALL    $3498]
	jbsr	vultures_shoot_decision_3930                            	| [$3448: CALL    $3930]
	jra	l_0c40                             	| [$344b: JP      $0C40]

l_3452:
	jbsr	animate_vultures_3486                            	| [$3452: CALL    $3486]
	jbsr	animate_vulture_wings_3560                            	| [$3455: CALL    $3560]
	jbsr	l_34aa                            	| [$3458: CALL    $34AA]
	jra	l_0fc0                             	| [$345b: JP      $0FC0]

l_3462:
	move.b	random_seed_counter_value_439B,d0                    	| [$3462: LD      A,(random_seed_counter_value_439B)]
	ror.b	#1,d0                            	| [$3465: RRCA]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3466: RET     C] [...]
0:
	jbsr	l_0c40                            	| [$3467: CALL    $0C40]
	jbsr	l_0fc0                            	| [$346a: CALL    $0FC0]
	jra	l_2204                             	| [$346d: JP      $2204]

animate_vultures_3474:
	lea	bird_data_4B70,a0                	| [$3474: LD      HL,bird_data_4B70]
l_3477:

	move.l	a0,-(sp)                        	| [$3477: PUSH    HL]
	jbsr	animate_vulture_34c0                            	| [$3478: CALL    $34C0]
	move.l	(sp)+,a0                        	| [$347b: POP     HL]
	addq.w	#8,a0                        	| [$347c: LD      A,L]
											| [$347d: ADD     $08]
											| [$347f: LD      L,A]
	cmp.l	#bird_data_4B70+0x20,a0                         	| [$3480: CP      $90]
	jne	l_3477                             	| [$3482: JP      NZ,$3477]
	rts                                    	| [$3485: RET]
	
animate_vultures_3486:
	lea	unknown_4B90,a0                	| [$3486: LD      HL,unknown_4B90]
l_3489:

	move.l	a0,-(sp)                        	| [$3489: PUSH    HL]
	jbsr	animate_vulture_34c0                            	| [$348a: CALL    $34C0]
	move.l	(sp)+,a0                        	| [$348d: POP     HL]
	addq.w	#8,a0         	| [$348e: LD      A,L]
	                       	| [$348f: ADD     $08]
	                      	| [$3491: LD      L,A]
	cmp.l	#unknown_4B90+0x20,a0                         	| [$3492: CP      $B0]
	jne	l_3489                             	| [$3494: JP      NZ,$3489]
	rts                                    	| [$3497: RET]
l_3498:
	lea	bird_data_4B70,a0                	| [$3498: LD      HL,bird_data_4B70]
l_349b:

	move.l	a0,-(sp)                        	| [$349b: PUSH    HL]
	jbsr	evolve_vultures_35b0                            	| [$349c: CALL    $35B0]
	move.l	(sp)+,a0                        	| [$349f: POP     HL]
	addq.w	#8,a0                       	| [$34a0: LD      A,L]
	                        	| [$34a1: ADD     $08]
	                       	| [$34a3: LD      L,A]
	cmp.l	#bird_data_4B70+0x20,a0        	| [$34a4: CP      $90]
	jne	l_349b                             	| [$34a6: JP      NZ,$349B]
	rts                                    	| [$34a9: RET]
l_34aa:
	lea	unknown_4B90,a0                	| [$34aa: LD      HL,unknown_4B90]
l_34ad:

	move.l	a0,-(sp)                        	| [$34ad: PUSH    HL]
	jbsr	evolve_vultures_35b0                            	| [$34ae: CALL    $35B0]
	move.l	(sp)+,a0                        	| [$34b1: POP     HL]
	addq.w	#8,a0                           	| [$34b2: LD      A,L]
											| [$34b3: ADD     $08]
											| [$34b5: LD      L,A]
	cmp.l	#unknown_4B90+0x20,a0                         	| [$34b6: CP      $B0]
	jne	l_34ad                             	| [$34b8: JP      NZ,$34AD]
	rts                                    	| [$34bb: RET]

* used in title & in game
* < A0: vulture structure

animate_vulture_34c0:
	move.b	(a0),d0                         	| [$34c0: LD      A,(HL)]
	                               	| [$34c1: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$34c2: RET     Z] [...]
0:
	* state is not 0: alive
	move.b	d0,d1                           	| [$34c3: LD      B,A]
	add.b	#0xC0,d0                         	| [$34c4: ADD     $C0]
	move.b	d0,d4                           	| [$34c6: LD      E,A]
	move.b	#0x3E,d3                        	| [$34c7: LD      D,$3E]
	* this table contains base number of columns to draw according to state
	bsr		load_rom_in_a1_from_d3d4
	move.b	(a1),d2                         	| [$34c9: LD      A,(DE)]
	                           	| [$34ca: LD      C,A]
	addq.w	#1,a0                           	| [$34cb: INC     L] skip alive status
	* screen address of the vulture
	move.b	(a0)+,d3                         	| [$34cc: LD      D,(HL)]
	                           	| [$34cd: INC     L]
 	move.b	(a0)+,d4                         	| [$34ce: LD      E,(HL)]
	                           	| [$34cf: INC     L]
 	move.b	d1,d0                           	| [$34d0: LD      A,B]
	rol.b	#3,d0                            	| [$34d1: RLCA] * 3
	add.b	(a0),d0                          	| [$34d4: ADD     A,(HL)]
	and.b	#0x7E,d0                         	| [$34d5: AND     $7E]
	move.b	d0,d6                           	| [$34d7: LD      L,A]
	move.b	#0x3E,d5                        	| [$34d8: LD      H,$3E]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0)+,d0                         	| [$34da: LD      A,(HL)]
	                           	| [$34db: INC     L]
 	move.b	(a0),d6                         	| [$34dc: LD      L,(HL)]
	move.b	d0,d5                           	| [$34dd: LD      H,A]
display_clipped_vulture_34de:
	bsr		load_rom_in_a0_from_d5d6
	* now we have to clip display on the borders, set d1 to a value that allows
	* to select the proper drawing routine
	move.b	d3,d0                           	| [$34de: LD      A,D]
	cmp.b	#0x4B,d0                         	| [$34df: CP      $4B]
	jne	l_350c                             	| [$34e1: JP      NZ,$350C]
	move.b	d4,d0                           	| [$34e4: LD      A,E]
	cmp.b	#0x50,d0                         	| [$34e5: CP      $50]
	jcs	l_350c                             	| [$34e7: JP      C,$350C]
	move.b	#0x08,d1                        	| [$34ea: LD      B,$08]
	addq.w	#2,a0                           	| [$34ec: INC     L]
	sub.b	#0x20,d0                         	| [$34ee: SUB     $20]
	move.b	d0,d4                           	| [$34f0: LD      E,A]
	cmp.b	#0x50,d0                         	| [$34f1: CP      $50]
	jcs	l_3509                             	| [$34f3: JP      C,$3509]
	move.b	#0x10,d1                        	| [$34f6: LD      B,$10]
	addq.w	#2,a0                           	| [$34f8: INC     L]
	sub.b	#0x20,d0                         	| [$34fa: SUB     $20]
	move.b	d0,d4                           	| [$34fc: LD      E,A]
	cmp.b	#0x50,d0                         	| [$34fd: CP      $50]
	jcs	l_3509                             	| [$34ff: JP      C,$3509]
	move.b	#0x18,d1                        	| [$3502: LD      B,$18]
	addq.w	#2,a0                           	| [$3504: INC     L]
	sub.b	#0x20,d0                         	| [$3506: SUB     $20]
	move.b	d0,d4                           	| [$3508: LD      E,A]
l_3509:
	                           	| [$3509: LD      A,C]
	add.b	d1,d2                            	| [$350a: ADD     A,B]
	                           	| [$350b: LD      C,A]
l_350c:
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d7
	                     	| [$350c: LD      B,$35]
	                    	| [$350e: PUSH    BC]
	move.w	#0xFFDF,d1                      	| [$350f: LD      BC,$FFDF]
	move.l	a0,a1                              	| [$3512: EX      DE,HL] source for params
	moveq	#0,d0                             	| [$3513: LD      (HL),$00]
	jbsr	osd_w_videoram									| [$3515: INC     HL]
	addq	#1,d7
	jbsr	osd_w_videoram                             	| [$3516: LD      (HL),$00]
	add.w	d1,d7                            	| [$3518: ADD     HL,BC]
	
	* d2 contains the LSB of $35xx address to jump to
	* it can only be 3520, 28... to draw one or more strips
	sub.w	#0x20,d2
	lsr.w	#3,d2
	and.w	#0x07,d2
	add.w	d2,d2
	add.w	d2,d2
	lea		jump_table_35xx(pc),a0
	move.l	(a0,d2.w),a0                                    	| [$3519: RET]
	jmp	(a0)
	
jump_table_35xx:
	.long	copy_7_columns_to_screen_3520
	.long	copy_6_columns_to_screen_3528
	.long	copy_5_columns_to_screen_3530
	.long	copy_4_columns_to_screen_3538
	.long	copy_3_columns_to_screen_3540
	.long	copy_2_columns_to_screen_3548
	.long	copy_1_column_to_screen_3550
	.long	clear_1_column_from_screen_3558
	
* kind of Duff's device/switch case
	DECL_ADDRESS	3520
	
* < A1: char data
* < D7: screen address
copy_7_columns_to_screen_3520:
	bsr		copy_2_byte_column_to_screen
						| [$3520: LD      A,(DE)]
						| [$3521: LD      (HL),A]
						| [$3522: INC     DE]
						| [$3523: INC     HL]
						| [$3524: LD      A,(DE)]
						| [$3525: LD      (HL),A]
						| [$3526: INC     DE]
							| [$3527: ADD     HL,BC]
	
copy_6_columns_to_screen_3528:
	bsr		copy_2_byte_column_to_screen

	                       	| [$3528: LD      A,(DE)]
	                       	| [$3529: LD      (HL),A]
	         	| [$352a: INC     DE]
	         	| [$352b: INC     HL]
	                       	| [$352c: LD      A,(DE)]
	                      	| [$352d: LD      (HL),A]
	         	| [$352e: INC     DE]
	                       	| [$352f: ADD     HL,BC]
copy_5_columns_to_screen_3530:
	bsr		copy_2_byte_column_to_screen
	                       	| [$3530: LD      A,(DE)]
	                       	| [$3531: LD      (HL),A]
	        	| [$3532: INC     DE]
	        	| [$3533: INC     HL]
	                       	| [$3534: LD      A,(DE)]
	                      	| [$3535: LD      (HL),A]
	        	| [$3536: INC     DE]
	                       	| [$3537: ADD     HL,BC]
copy_4_columns_to_screen_3538:
	bsr		copy_2_byte_column_to_screen                        	| [$3538: LD      A,(DE)]
	                        	| [$3539: LD      (HL),A]
	          	| [$353a: INC     DE]
	          	| [$353b: INC     HL]
	                        	| [$353c: LD      A,(DE)]
	                       	| [$353d: LD      (HL),A]
	          	| [$353e: INC     DE]
	                        	| [$353f: ADD     HL,BC]
copy_3_columns_to_screen_3540:
	bsr		copy_2_byte_column_to_screen
    	| [$3540: LD      A,(DE)]
    	| [$3541: LD      (HL),A]
    	| [$3542: INC     DE]
    	| [$3543: INC     HL]
    	| [$3544: LD      A,(DE)]
    	| [$3545: LD      (HL),A]
    	| [$3546: INC     DE]
     	| [$3547: ADD     HL,BC]
  
copy_2_columns_to_screen_3548:
	bsr		copy_2_byte_column_to_screen
	  	| [$3548: LD      A,(DE)]
	  	| [$3549: LD      (HL),A]
	  	| [$354a: INC     DE]
	  	| [$354b: INC     HL]
	  	| [$354c: LD      A,(DE)]
	  	| [$354d: LD      (HL),A]
	  	| [$354e: INC     DE]
	   	| [$354f: ADD     HL,BC]
copy_1_column_to_screen_3550:
	bsr		copy_2_byte_column_to_screen
	  	| [$3550: LD      A,(DE)]
	  	| [$3551: LD      (HL),A]
	  	| [$3552: INC     DE]
	  	| [$3553: INC     HL]
	  	| [$3554: LD      A,(DE)]
	  	| [$3555: LD      (HL),A]
	  	| [$3556: INC     DE]
	   	| [$3557: ADD     HL,BC]
clear_1_column_from_screen_3558:
	moveq	#0,d0
	jbsr	osd_w_videoram
	addq	#1,d7
	jbsr	osd_w_videoram
 	                             	| [$3558: LD      (HL),$00]
	              	| [$355a: INC     HL]
	                            	| [$355b: LD      (HL),$00]
	rts                                    	| [$355d: RET]

	DECL_ADDRESS	3560
	
animate_vulture_wings_3560:
	jbsr	get_random_value_30aa                            	| [$3560: CALL    $30AA]
	move.b	d0,d1                           	| [$3563: LD      B,A]
	rol.b	#2,d0                            	| [$3564: RLCA] * 2
	move.b	d0,d2                           	| [$3566: LD      C,A]
	rol.b	#2,d0                            	| [$3567: RLCA] * 2
	or.b	d1,d0                             	| [$3569: OR      B] effectively duplicates 4 lower bits to upper bits
	move.b	d0,repeated_bits_random_436F        | [$356a: LD      (repeated_bits_random_436F),A] ex 11, 33, EE, ...
	move.b	current_stage_43B8,d0           	| [$356d: LD      A,(current_stage_43B8)]
	cmp.b	#0x40,d0                         	| [$3570: CP      $40]
	jcs	l_3577                             	| [$3572: JP      C,$3577]
	move.b	#0x30,d0                        	| [$3575: LD      A,$30]
l_3577:
	and.b	#0x30,d0                         	| [$3577: AND     $30]
	ror.b	#1,d0                            	| [$3579: RRCA]
	move.b	d0,d1                           	| [$357a: LD      B,A]
	move.b	nb_vultures_to_kill_before_stage_completed_43BB,d0                 	| [$357b: LD      A,(nb_vultures_to_kill_before_stage_completed_43BB)]
	subq.b	#1,d0                           	| [$357e: DEC     A]
	cmp.b	#0x04,d0                         	| [$357f: CP      $04]
	jcs	l_3586                             	| [$3581: JP      C,$3586]
	move.b	#0x03,d0                        	| [$3584: LD      A,$03]
l_3586:
	rol.b	#1,d0                            	| [$3586: RLCA]
	or.b	d1,d0                             	| [$3587: OR      B]
	move.b	d0,d1                           	| [$3588: LD      B,A]
	move.b	counter_439A,d0                      	| [$3589: LD      A,(counter_439A)]
	rol.b	#2,d0                            	| [$358c: RLCA] * 2
	and.b	#0x20,d0                         	| [$358e: AND     $20]
	or.b	d1,d0                             	| [$3590: OR      B]
	add.b	#0x80,d0                         	| [$3591: ADD     $80]
	move.b	d0,d6                           	| [$3593: LD      L,A]
	move.b	#0x3E,d5                        	| [$3594: LD      H,$3E]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0)+,d0                         	| [$3596: LD      A,(HL)]
	move.b	d0,unknown_436E                 	| [$3597: LD      (unknown_436E),A]
	                           	| [$359a: INC     L]
 	move.b	(a0),d0                         	| [$359b: LD      A,(HL)]
	add.b	d2,d0                            	| [$359c: ADD     A,C]
	and.b	#0xF8,d0                         	| [$359d: AND     $F8]
	move.b	d0,unknown_436D                 	| [$359f: LD      (unknown_436D),A]
	rts                                    	| [$35a2: RET]

	DECL_ADDRESS	35b0
	
* skipping this, the vulture stage just consists in tiny blue
* dots organized in a diagonal, going up and down
* this routine allows to make vultures grow, then move

evolve_vultures_35b0:
	move.b	(a0),d0                         	| [$35b0: LD      A,(HL)]
	                               	| [$35b1: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$35b2: RET     Z] [...]
0:
	move.b	d0,d1                           	| [$35b3: LD      B,A]
	addq.w	#4,a0                           	| [$35b4: INC     L] * 4
 	move.b	(a0),d0                         	| [$35b8: LD      A,(HL)]
	                               	| [$35b9: AND     A]
	jeq	l_35be                             	| [$35ba: JP      Z,$35BE]
	subq.b	#1,(a0)                         	| [$35bd: DEC     (HL)]
l_35be:
	* kind of jump table
	exg	a1,a0                              	| [$35be: EX      DE,HL]
	
	move.l	a1,-(sp)                        	| [$35bf: PUSH    DE]
	moveq	#0,d0
	move.b	d1,d0                           	| [$35c0: LD      A,B]
	rol.b	#4,d0                            	| [$35c1: RLCA] * 3, *2 32 bit table
	lea		jump_table_chain_3F00(pc),a0
	add.w	d0,a0                           	| [$35c4: LD      L,A]
	move.l	(a0)+,a4                        	| [$35c5: LD      H,$3F]
	                      	| [$35c7: LD      B,(HL)]
	                      	| [$35c8: INC     HL]
	                      	| [$35c9: LD      C,(HL)]
	move.l	a4,-(sp)                        	| [$35ca: PUSH    BC]
	                           	| [$35cb: INC     HL]
	move.l	(a0)+,a4                         	| [$35cc: LD      B,(HL)]
	                    	| [$35cd: INC     HL]
	                    	| [$35ce: LD      C,(HL)]
	move.l	a4,-(sp)                        	| [$35cf: PUSH    BC]
	                           	| [$35d0: INC     HL]
	move.l	(a0)+,a4                         	| [$35d1: LD      B,(HL)]
	                       	| [$35d2: INC     HL]
	                       	| [$35d3: LD      C,(HL)]
	move.l	a4,-(sp)                        	| [$35d4: PUSH    BC]
	                           	| [$35d5: INC     HL]
	move.l	(a0)+,a4                         	| [$35d6: LD      B,(HL)]
											| [$35d7: INC     HL]
                        	| [$35d8: LD      C,(HL)]
	move.l	a4,-(sp)                        	| [$35d9: PUSH    BC]
	exg	a1,a0                              	| [$35da: EX      DE,HL]
	* start the call chain
	rts                                    	| [$35db: RET]

* this command doesn't have any parameters
vulture_command_move_vultures_laterally_35e0:	
	addq.w	#2,a0                           	| [$35e0: INC     L]*2
	move.b	(a0),d0                         	| [$35e2: LD      A,(HL)]
	cmp.b	#0x10,d0                         	| [$35e3: CP      $10]
	jcc	l_3628                             	| [$35e5: JP      NC,$3628]
	move.b	d0,d1                           	| [$35e8: LD      B,A]
	                           	| [$35e9: DEC     L]
	add.b	-(a0),d0                          	| [$35ea: ADD     A,(HL)]
	move.b	d0,(a0)                         	| [$35eb: LD      (HL),A]
	subq.w	#2,a0                           	| [$35ec: DEC     L]*2
	move.b	d1,d0                           	| [$35ee: LD      A,B]
	add.b	(a0),d0                          	| [$35ef: ADD     A,(HL)]
	move.b	d0,(a0)                         	| [$35f0: LD      (HL),A]
	cmp.b	#0x08,d0                         	| [$35f1: CP      $08]
	jcs	l_366a                             	| [$35f3: JP      C,$366A]
	and.b	#0x07,d0                         	| [$35f6: AND     $07]
	move.b	d0,(a0)                         	| [$35f8: LD      (HL),A]
	                           	| [$35f9: DEC     L]
 	                         	| [$35fa: LD      A,(HL)]
	sub.b	#0x20,-(a0)        | [$35fb: SUB     $20] move vulture to the right
	                         	| [$35fd: LD      (HL),A]
	jcc	l_3604                             	| [$35fe: JP      NC,$3604]
	                           	| [$3601: DEC     L]
	subq.b	#1,(-1,a0)                         	| [$3602: DEC     (HL)] propagate carry
	                           	| [$3603: INC     L]
l_3604:
	addq.w	#3,a0                           	| [$3604: INC     L]*3	                       
	move.b	(a0),d2                         	| [$3607: LD      C,(HL)]
	addq.w	#2,a0                           	| [$3608: INC     L]
	move.b	(a0),d0                         	| [$360a: LD      A,(HL)]
											| [$360b: DEC     L]
 	move.b	#0x10,-(a0)                      	| [$360c: LD      (HL),$10]
	sub.b	d2,d0                            	| [$360e: SUB     C]
	jeq	l_3672                             	| [$360f: JP      Z,$3672]
	subq.b	#1,d0                           	| [$3612: DEC     A]
	ror.b	#3,d0                            	| [$3613: RRCA] * 3
	and.b	#0x1F,d0                         	| [$3616: AND     $1F]
	move.b	d0,d7
	addq.b	#1,d7                           	| [$3619: INC     A]
	move.b	d7,(a0)								| [$361a: LD      (HL),A]
	cmp.b	d1,d0                            	| [$3618: CP      B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$361b: RET     C] [...]
0:
	move.b	unknown_436E,d0                 	| [$361c: LD      A,(unknown_436E)]
	move.b	d0,(a0)                         	| [$361f: LD      (HL),A]
	cmp.b	d1,d0                            	| [$3620: CP      B]
	bne.b	0f                               	| [...]
	rts                                    	| [$3621: RET     Z] [...]
0:
	addq.b	#1,d1                           	| [$3622: INC     B]
	move.b	d1,(a0)                         	| [$3623: LD      (HL),B]
	rts                                    	| [$3624: RET]

	DECL_ADDRESS	3628
	
l_3628:
	and.b	#0x0F,d0                         	| [$3628: AND     $0F]
	jeq	l_3744                             	| [$362a: JP      Z,$3744]
	move.b	d0,d1                           	| [$362d: LD      B,A]
	                           	| [$362e: DEC     L]
	move.b	-(a0),d0                         	| [$362f: LD      A,(HL)]
	sub.b	d1,d0                            	| [$3630: SUB     B]
	move.b	d0,(a0)                         	| [$3631: LD      (HL),A]
	subq.w	#2,a0                           	| [$3632: DEC     L]*2
	move.b	(a0),d0                         	| [$3634: LD      A,(HL)]
	sub.b	d1,d0                            	| [$3635: SUB     B]
	jcc	l_3695                             	| [$3637: JP      NC,$3695]
	move.b	d0,(a0)                         	| [$3636: LD      (HL),A]
	and.b	#0x07,d0                         	| [$363a: AND     $07]
	move.b	d0,(a0)                         	| [$363c: LD      (HL),A]
	                           	| [$363d: DEC     L]
	                         	| [$363e: LD      A,(HL)]
	add.b	#0x20,-(a0)         | [$363f: ADD     $20]  move vulture to the left
	                         	| [$3641: LD      (HL),A]
	jcc	l_3648                             	| [$3642: JP      NC,$3648]
	                           	| [$3645: DEC     L]
	addq.b	#1,(-1,a0)                         	| [$3646: INC     (HL)] propagate carry
	                           	| [$3647: INC     L]
l_3648:
	addq.w	#3,a0                           	| [$3648: INC     L]
	                           	| [$3649: INC     L] * 2
	move.b	(a0),d0                         	| [$364b: LD      A,(HL)]
	addq.w	#2,a0                           	| [$364c: INC     L]
	sub.b	(a0),d0                          	| [$364e: SUB     (HL)]
	ror.b	#3,d0                            	| [$364f: RRCA] * 3
	and.b	#0x1F,d0                         	| [$3652: AND     $1F]
	subq.w	#1,a0                           	| [$3656: DEC     L]
	move.b	d0,d7
	addq.b	#1,d0                           	| [$3655: INC     A]
	cmp.b	d1,d7                            	| [$3654: CP      B]
	jcs	l_3663                             	| [$3657: JP      C,$3663]
	
	move.b	unknown_436E,d0                 	| [$365a: LD      A,(unknown_436E)]
	cmp.b	d1,d0                            	| [$365d: CP      B]
	jeq	l_3663                             	| [$365e: JP      Z,$3663]
	move.b	d1,d0                           	| [$3661: LD      A,B]
	addq.b	#1,d0                           	| [$3662: INC     A]
l_3663:
	or.b	#0x10,d0                          	| [$3663: OR      $10]
	move.b	d0,(a0)                         	| [$3665: LD      (HL),A]
	rts                                    	| [$3666: RET]
	                         	| [$3667: LD      (HL),A]
	                        	| [$3668: RET]

l_366a:
	move.b	d1,d0                           	| [$366a: LD      A,B]
	                               	| [$366b: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$366c: RET     NZ] [...]
0:
	addq.w	#3,a0                           	| [$366d: INC     L]
	addq.b	#1,(a0)                         	| [$3670: INC     (HL)]
	rts                                    	| [$3671: RET]
	
l_3672:
	                           	| [$3672: DEC     L]
	move.b	-(a0),d1                         	| [$3673: LD      B,(HL)]
	addq.w	#2,a0                           	| [$3674: INC     L]
	move.b	player_ship_x_43C2,d0           	| [$3676: LD      A,(player_ship_x_43C2)]
	and.b	#0xF8,d0                         	| [$3679: AND     $F8] align
	cmp.b	d1,d0                            	| [$367b: CP      B]
	jcc	l_3680                             	| [$367c: JP      NC,$3680]
	move.b	d0,d1                           	| [$367f: LD      B,A]
l_3680:
	move.b	unknown_436D,d0                 	| [$3680: LD      A,(unknown_436D)]
	move.b	d0,d2                           	| [$3683: LD      C,A]
	add.b	#0x08,d0                         	| [$3684: ADD     $08]
	move.b	d0,unknown_436D                 	| [$3686: LD      (unknown_436D),A]
	move.b	d1,d0                           	| [$3689: LD      A,B]
	move.b	#0x08,(a0)                      	| [$368b: LD      (HL),$08]
	sub.b	d2,d0                            	| [$368a: SUB     C]
	bcc.b	0f                               	| [...]
	rts                                    	| [$368d: RET     C] [...]
0:
	cmp.b	#0x08,d0                         	| [$368e: CP      $08]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3690: RET     C] [...]
0:
	move.b	d0,(a0)                         	| [$3691: LD      (HL),A]
	rts                                    	| [$3692: RET]

0:
l_3695:
	move.b	d0,(a0)
	addq.w	#2,a0                           	| [$3696: INC     L] * 2
	move.b	(a0),d1                         	| [$3697: LD      B,(HL)]
	addq.w	#2,a0                           	| [$3698: INC     L]
	move.b	(a0),d0                         	| [$369a: LD      A,(HL)]
	cmp.b	d1,d0                            	| [$369b: CP      B]
	beq.b	0f                               	| [...]
	rts                                    	| [$369c: RET     NZ] [...]
0:
	                           	| [$369d: DEC     L]
	clr.b	(-1,a0)                             	| [$369e: LD      (HL),$00]
	                           	| [$36a0: INC     L]
	move.b	player_ship_x_43C2,d0           	| [$36a1: LD      A,(player_ship_x_43C2)]
	and.b	#0xF8,d0                         	| [$36a4: AND     $F8]
	cmp.b	d1,d0                            	| [$36a6: CP      B]
	jcs	l_36ab                             	| [$36a7: JP      C,$36AB]
	move.b	d0,d1                           	| [$36aa: LD      B,A]
l_36ab:
	move.b	unknown_436D,d0                 	| [$36ab: LD      A,(unknown_436D)]
	add.b	#0x08,d0                         	| [$36ae: ADD     $08]
	move.b	d0,unknown_436D                 	| [$36b0: LD      (unknown_436D),A]
	move.b	#0xC8,(a0)                      	| [$36b4: LD      (HL),$C8]
	add.b	d1,d0                            	| [$36b3: ADD     A,B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$36b6: RET     C] [...]
0:
	cmp.b	#0xC8,d0                         	| [$36b7: CP      $C8]
	bcs.b	0f                               	| [...]
	rts                                    	| [$36b9: RET     NC] [...]
0:
	move.b	d0,(a0)                         	| [$36ba: LD      (HL),A]
	rts                                    	| [$36bb: RET]
	                        	| [$36bc: LD      (HL),A]
	                       	| [$36bd: RET]

vulture_command_36c0:
	move.b	(a0),d0                         	| [$36c0: LD      A,(HL)]
	ror.b	#1,d0                            	| [$36c1: RRCA]
	bcc.b	0f                               	| [...]
	rts                                    	| [$36c2: RET     C] [...]
0:
												| [$36c3: DEC     L]
	move.b	-(a0),d0                         	| [$36c4: LD      A,(HL)]
	addq.b	#1,d0                           	| [$36c5: INC     A]
	and.b	#0x07,d0                         	| [$36c6: AND     $07]
	move.b	d0,(a0)                         	| [$36c8: LD      (HL),A]
	rts                                    	| [$36c9: RET]

end_chained_calls_36cc:
	* drop 2 remaining parameters (0xFFFF)
	addq.w	#8,sp                        	| [$36cc: POP     DE]
	                        	| [$36cd: POP     BC]
	move.l	(sp)+,a0                        	| [$36ce: POP     HL]
	rts                                    	| [$36cf: RET]
	
vulture_command_36d2:
	move.l	(sp)+,d3                        	| [$36d2: POP     DE] pops param ex 03FF
	move.l	(sp)+,d1                        	| [$36d3: POP     BC] pops param ex 20FF
	move.l	(sp)+,a0                        	| [$36d4: POP     HL] pops address pushed at 35BF
	move.b	(a0),d0                         	| [$36d5: LD      A,(HL)]
	                               	| [$36d6: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$36d7: RET     NZ] [...]
0:
	LOAD_D1D2_FROM_D1_16
	LOAD_D3D4_FROM_D3_16
	move.b	d1,(a0)                         	| [$36d8: LD      (HL),B]
	subq.w	#4,a0                           	| [$36d9: DEC     L]
	move.b	d3,(a0)                         	| [$36dd: LD      (HL),D]
	move.b	unknown_4368,d0                 	| [$36de: LD      A,(unknown_4368)]
	or.b	#0x01,d0                          	| [$36e1: OR      $01]
	move.b	d0,unknown_4368                 	| [$36e3: LD      (unknown_4368),A]
	rts                                    	| [$36e6: RET]

vulture_command_36ea:
	move.l	(sp)+,d3                    	| [$36ea: POP     DE] pops params
	move.l	(sp)+,d1                    	| [$36eb: POP     BC]
	move.l	(sp)+,a0                        	| [$36ec: POP     HL]
	move.b	(a0),d0                         	| [$36ed: LD      A,(HL)]
	                               	| [$36ee: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$36ef: RET     NZ] [...]
0:
	LOAD_D1D2_FROM_D1_16
	LOAD_D3D4_FROM_D3_16
	addq.w	#2,a0                           	| [$36f0: INC     L]
	move.b	(a0),d0                         	| [$36f2: LD      A,(HL)]
	and.b	#0x0F,d0                         	| [$36f3: AND     $0F]
	beq.b	0f                               	| [...]
	rts                                    	| [$36f5: RET     NZ] [...]
0:
	subq.w	#2,a0                           	| [$36f6: DEC     L]
	move.b	d1,(a0)                         	| [$36f8: LD      (HL),B]
	subq.w	#4,a0                           	| [$36f9: DEC     L]
	move.b	d3,(a0)                         	| [$36fd: LD      (HL),D]
	move.b	unknown_4368,d0                 	| [$36fe: LD      A,(unknown_4368)]
	or.b	#0x02,d0                          	| [$3701: OR      $02]
	move.b	d0,unknown_4368                 	| [$3703: LD      (unknown_4368),A]
	rts                                    	| [$3706: RET]

vulture_command_370a:
	move.l	(sp)+,d3                     	| [$370a: POP     DE] pops params
	move.l	(sp)+,d1					 	| [$370b: POP     BC]
	move.l	(sp)+,a0                        	| [$370c: POP     HL]
	move.b	(a0),d0                         	| [$370d: LD      A,(HL)]
	                               	| [$370e: AND     A]
	beq.b	0f                               	| [...]
	rts                                    	| [$370f: RET     NZ] [...]
0:
	LOAD_D1D2_FROM_D1_16
	LOAD_D3D4_FROM_D3_16
	addq.w	#2,a0                           	| [$3710: INC     L]
	move.b	(a0),d0                         	| [$3712: LD      A,(HL)]
	and.b	#0x0F,d0                         	| [$3713: AND     $0F]
	beq.b	0f                               	| [...]
	rts                                    	| [$3715: RET     NZ] [...]
0:
	subq.w	#2,a0                           	| [$3716: DEC     L] * 2
	move.b	d1,(a0)                         	| [$3718: LD      (HL),B]
	subq.w	#4,a0                           	| [$3719: DEC     L] * 4
	move.b	d3,(a0)                         	| [$371d: LD      (HL),D]
	move.b	unknown_4368,d0                 	| [$371e: LD      A,(unknown_4368)]
	or.b	#0x04,d0                          	| [$3721: OR      $04]
	move.b	d0,unknown_4368                 	| [$3723: LD      (unknown_4368),A]
	move.b	repeated_bits_random_436F,d0                 	| [$3726: LD      A,(repeated_bits_random_436F)]
	and.b	d4,d0                            	| [$3729: AND     E]
	and.b	#0xF0,d0                         	| [$372a: AND     $F0]
	beq.b	0f                               	| [...]
	rts                                    	| [$372c: RET     NZ] [...]
0:
	move.b	d4,d0                           	| [$372d: LD      A,E]
	and.b	#0x0F,d0                         	| [$372e: AND     $0F]
	move.b	d0,(a0)                         	| [$3730: LD      (HL),A]
	addq.w	#4,a0                           	| [$3731: INC     L]
	move.b	d2,(a0)                         	| [$3735: LD      (HL),C]
	move.b	unknown_4368,d0                 	| [$3736: LD      A,(unknown_4368)]
	or.b	#0x08,d0                          	| [$3739: OR      $08]
	move.b	d0,unknown_4368                 	| [$373b: LD      (unknown_4368),A]
	rts                                    	| [$373e: RET]

l_3744:
	move.b	#0x11,(a0)                      	| [$3744: LD      (HL),$11]
	                           	| [$3746: DEC     L]
	subq.b	#1,-(a0)                         	| [$3747: DEC     (HL)]
	subq.w	#2,a0                           	| [$3748: DEC     L]
	move.b	#0x07,(a0)                      	| [$374a: LD      (HL),$07]
	                           	| [$374c: DEC     L]
	move.b	-(a0),d0                         	| [$374d: LD      A,(HL)]
	add.b	#0x20,(a0)                         	| [$374e: ADD     $20]
	                         	| [$3750: LD      (HL),A]
	bcs.b	0f                               	| [...]
	rts                                    	| [$3751: RET     NC] [...]
0:
	                          	| [$3752: DEC     L]
	addq.b	#1,-(a0)                         	| [$3753: INC     (HL)]
	rts                                    	| [$3754: RET]

	DECL_ADDRESS	3758
	
l_3758:
	move.b	(a0),d0                         	| [$3758: LD      A,(HL)] check if slot active
	                               	| [$3759: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$375a: RET     Z] [...]
0:
	subq.b	#1,(a0)                         	| [$375b: DEC     (HL)]
	jeq	clear_two_screen_rows_37cc                             	| [$375c: JP      Z,$37CC]
	move.b	(a0),d0                         	| [$375f: LD      A,(HL)]
	ror.b	#1,d0                            	| [$3760: RRCA]
	jcc	l_37b0                             	| [$3761: JP      NC,$37B0]
	move.b	#0x0F,d0                        	| [$3764: LD      A,$0F]
	sub.b	(a0),d0                          	| [$3766: SUB     (HL)]
	and.b	#0x0E,d0                         	| [$3767: AND     $0E]
	rol.b	#4,d0                            	| [$3769: RLCA] * 4
	addq.w	#2,a0                           	| [$376d: INC     L] * 2
	* get screen address for animation
	move.b	(a0)+,d3                         	| [$376f: LD      D,(HL)]
	                           	| [$3770: INC     L]
	move.b	(a0),d4                         	| [$3771: LD      E,(HL)]
	LOAD_D3_16_FROM_D3D4
	move.w	d0,-(sp)                        	| [$3772: PUSH    AF]
	move.w	d3,-(sp)                    	| [$3773: PUSH    DE]
	move.w	#0xFFDf,d1                      	| [$3774: LD      BC,$FFDF] offset for copy_2_columns_to_screen
	jbsr	explosion_special_animation_left_3796                            	| [$3777: CALL    $3796]
	move.w	(sp)+,d3                    	| [$377a: POP     DE]
	move.w	(sp)+,d0                        	| [$377b: POP     AF]
explosion_special_animation_right_377c:
	not.b	d0                               	| [$377c: CPL]
	move.b	d0,d6                           	| [$377d: LD      L,A]
	st.b	d5                                	| [$377e: LD      H,$FF]
	LOAD_D5_16_FROM_D5D6
	addq.w	#1,d5                           	| [$3780: INC     HL]
	add.w	d3,d5                            	| [$3781: ADD     HL,DE]
	exg	d3,d5                              	| [$3782: EX      DE,HL]
	move.w	#0xBFA0,d5                      	| [$3783: LD      HL,$BFA0]
	add.w	d3,d5                            	| [$3786: ADD     HL,DE]
	bcs.b	0f                               	| [...]
	rts                                    	| [$3787: RET     NC] [...]
0:
	exg	d3,d7                              	| [$3788: EX      DE,HL]
	lea	game_rom+0x17D6,a1                      	| [$3789: LD      DE,$17D6]
	moveq	#0,d0
	jbsr	osd_w_videoram
	addq	#1,d7
	jbsr	osd_w_videoram                             	| [$378c: LD      (HL),$00]
											| [$378e: INC     HL]
	                             	| [$378f: LD      (HL),$00]
	add.w	d1,d7                            	| [$3791: ADD     HL,BC]
	jra	copy_3_columns_to_screen_3540                             	| [$3792: JP      $3540]
	
	DECL_ADDRESS	3796
	
explosion_special_animation_left_3796:
	moveq	#0,d5                               	| [$3799: LD      H,$00]
	move.b	d0,d5
	add.w	#0x60,d5                         	| [$3796: ADD     $60] add lateral offset
                           	| [$3798: LD      L,A]
	jcc	l_379f                             	| [$379b: JP      NC,$379F]
	add.w	#0x100,d5                           	| [$379e: INC     H]
l_379f:
	* transform to screen address to display exploding flames 
	add.w	d3,d5                            	| [$379f: ADD     HL,DE]
	exg	d3,d5                              	| [$37a0: EX      DE,HL]
	* test if too much on the side?
	move.w	#0xBCC0,d5                      	| [$37a1: LD      HL,$BCC0]
	add.w	d3,d5                            	| [$37a4: ADD     HL,DE]
	bcc.b	0f                               	| [...]
	rts                                    	| [$37a5: RET     C] [...]
0:
	exg	d3,d7                              	| [$37a6: EX      DE,HL]
	lea	game_rom+0x17D0,a1                      	| [$37a7: LD      DE,$17D0]
	jra	copy_3_columns_to_screen_3540                             	| [$37aa: JP      $3540]

	DECL_ADDRESS	37b0
	
l_37b0:
	addq.w	#1,a0                           	| [$37b0: INC     L]
	move.b	(a0),d0                         	| [$37b1: LD      A,(HL)]
	bsr		daa               | DAA without add... something about scores
	move.b	d0,(a0)+                         	| [$37b3: LD      (HL),A]
	                           	| [$37b4: INC     L]
	move.b	(a0)+,d3                         	| [$37b5: LD      D,(HL)]
	                           	| [$37b6: INC     L]
	move.b	(a0),d4                         	| [$37b7: LD      E,(HL)]
	subq.w	#2,a0                           	| [$37b8: DEC     L] * 2
	                                    	| [$37ba: NOP]
	LOAD_D3_16_FROM_D3D4
	jbsr	SubtractOneRow_0217               	| [$37bb: CALL    SubtractOneRow_0217]
	move.b	#0x20,d0                        	| [$37be: LD      A,$20]
	move.w	d3,d7
	jbsr	osd_w_videoram                         	| [$37c0: LD      (DE),A]
	jbsr	AddOneRow_0210                    	| [$37c1: CALL    AddOneRow_0210]
	move.b	#0x02,d1                        	| [$37c4: LD      B,$02]
	jra	write_digits_to_screen_00c4                             	| [$37c6: JP      $00C4]

	DECL_ADDRESS	37cc
	
clear_two_screen_rows_37cc:
	addq.w	#3,a0                           	| [$37cc: INC     L]
	                          	| [$37cd: INC     L]
	move.b	(a0),d0                         	| [$37cf: LD      A,(HL)]
	and.b	#0x1F,d0                         	| [$37d0: AND     $1F]
	add.b	#0x20,d0                         	| [$37d2: ADD     $20]
	move.w	#0x4300,d7                        	| [$37d5: LD      H,$43]
	move.b	d0,d7                           	| [$37d4: LD      L,A]
	move.w	#0xFFDF,d1                      	| [$37d7: LD      BC,$FFDF]
	moveq	#0,d0											| [$37da: LD      DE,$001A] 26
	move.b	#0x1A,d4                      	| [$37da: LD      DE,$001A] 26
	
l_37dd:
	jbsr	osd_w_videoram                         	| [$37dd: LD      (HL),D]
	addq.w	#1,d7                           	| [$37de: INC     HL]
	jbsr	osd_w_videoram                         	| [$37df: LD      (HL),D]
	add.w	d1,d7                            	| [$37e0: ADD     HL,BC]
 	subq.b	#1,d4                           	| [$37e1: DEC     E]
	jne	l_37dd                             	| [$37e2: JP      NZ,$37DD]
	rts                                    	| [$37e5: RET]

* only 1 shot, 2-shots cheat doesn't work with vultures
player_shots_vs_vultures_collision_3800:
	move.b	player_shot_1_structure_43C4,d0 	| [$3800: LD      A,(player_shot_1_structure_43C4)]
	and.b	#0x08,d0                         	| [$3803: AND     $08]
	bne.b	0f                               	| [...]
	rts                                    	| [$3805: RET     Z] [...]
0:
	move.b	ram_pointer_on_flying_enemies_table_43E6,d3	| [$3806: LD      A,(ram_pointer_on_flying_enemies_table_43E6)]
	add.b	#0x08,d3                         	| [$3809: ADD     $08]
	                           	| [$380b: LD      D,A]
	move.b	current_char_scroll_value_4BD2,d4                 	| [$380c: LD      A,(current_char_scroll_value_4BD2)]
	                           	| [$380f: LD      E,A]
	move.b	ram_pointer_on_flying_enemies_table_lsb_43E7,d0                 	| [$3810: LD      A,(ram_pointer_on_flying_enemies_table_lsb_43E7)]
	and.b	#0xE0,d0                         	| [$3813: AND     $E0]
	move.b	d0,d1                           	| [$3815: LD      B,A]
	move.b	ram_pointer_on_flying_enemies_table_lsb_43E7,d0                 	| [$3816: LD      A,(ram_pointer_on_flying_enemies_table_lsb_43E7)]
	sub.b	d4,d0                            	| [$3819: SUB     E]
	                                    	| [$381a: NOP]
	and.b	#0x1F,d0                         	| [$381b: AND     $1F]
	or.b	d1,d0                             	| [$381d: OR      B]
	move.b	d0,d4                           	| [$381e: LD      E,A]
	bsr		load_ram_in_a1_from_d3d4
	move.b	(a1),d0                         	| [$381f: LD      A,(DE)]
	sub.b	#0x90,d0                         	| [$3820: SUB     $90]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3822: RET     C] [...]
0:
	move.b	d0,d1                           	| [$3823: LD      B,A]
	move.b	unknown_43C6,d0                 	| [$3824: LD      A,(unknown_43C6)]
	and.b	#0x07,d0                         	| [$3827: AND     $07]
	                        	| [$3829: ADD     $00]
	move.b	d0,d6                           	| [$382b: LD      L,A]
	move.b	#0x3E,d5                        	| [$382c: LD      H,$3E]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0),d2                         	| [$382e: LD      C,(HL)]
	move.b	d4,d0                           	| [$382f: LD      A,E]
	and.b	#0x0E,d0                         	| [$3830: AND     $0E]
	rol.b	#2,d0                            	| [$3832: RLCA] * 2
	move.b	d0,d4                           	| [$3834: LD      E,A]
	move.b	#0xA8,d0                        	| [$3835: LD      A,$A8]
	sub.b	d4,d0                            	| [$3837: SUB     E]
	move.b	d0,d4                           	| [$3838: LD      E,A]
	move.b	#0x4B,d3                        	| [$3839: LD      D,$4B]
	move.b	d1,d0                           	| [$383b: LD      A,B]
	bsr		load_ram_in_a1_from_d3d4
	cmp.b	#0x50,d0                         	| [$383c: CP      $50]
	bcc.b	0f                               	| [...]
	jbsr	l_3844                            	| [$383e: CALL    C,$3844]
0:
	jra	vulture_shot_sound_391c                             	| [$3841: JP      $391C]
l_3844:
	add.b	#0x60,d0                         	| [$3844: ADD     $60]
	move.b	d0,d6                           	| [$3846: LD      L,A]
	move.b	#0x3B,d5                        	| [$3847: LD      H,$3B]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0),d0                         	| [$3849: LD      A,(HL)]
	and.b	d2,d0                            	| [$384a: AND     C]
	bne.b	0f                               	| [...]
	rts                                    	| [$384b: RET     Z] [...]
0:
	jbsr	l_38a1                            	| [$384c: CALL    $38A1]
	exg	a1,a0                              	| [$384f: EX      DE,HL]
	move.b	(a0),d0                         	| [$3850: LD      A,(HL)]
	clr.b	(a0)                             	| [$3851: LD      (HL),$00]
	addq.w	#4,a0                           	| [$3853: INC     L] * 4
	move.b	(a0),d3                         	| [$3857: LD      D,(HL)]
	addq.w	#4,sp                        	| [$3858: POP     HL] pop stack
	lea	nb_vultures_to_kill_before_stage_completed_43BB,a0                	| [$3859: LD      HL,nb_vultures_to_kill_before_stage_completed_43BB]
	subq.b	#1,(a0)                         	| [$385c: DEC     (HL)]
	cmp.b	#0x0B,d0                         	| [$385d: CP      $0B]
	jcs	l_3894                             	| [$385f: JP      C,$3894]
	move.b	d0,d4                           	| [$3862: LD      E,A]
	st.b	d0                                	| [$3863: LD      A,$FF]
	move.b	d0,unknown_4369                 	| [$3865: LD      (unknown_4369),A]
	lea	slot_for_special_animation_4378,a0                	| [$3868: LD      HL,slot_for_special_animation_4378]
	
	move.w	#VULTURE_SHOT_SND,d0
	jbsr	osd_sound_start
	
	move.b	#0x10,d1
	move.b	#0x10,d2                      	| [$386b: LD      BC,$1010]
	move.b	d4,d0                           	| [$386e: LD      A,E]
	cmp.b	#0x0F,d0                         	| [$386f: CP      $0F]
	jeq	vulture_hit_38fb                             	| [$3871: JP      Z,$38FB]
	move.b	d3,d0                           	| [$3874: LD      A,D]
	ror.b	#1,d0                            	| [$3875: RRCA]
	and.b	#0x7C,d0                         	| [$3876: AND     $7C]
	add.b	#0x30,d0                         	| [$3878: ADD     $30]
	move.b	d0,d2                           	| [$387a: LD      C,A]
	move.b	d4,d0                           	| [$387b: LD      A,E]
	cmp.b	#0x0E,d0                         	| [$387c: CP      $0E]
	jeq	vulture_hit_38fb                             	| [$387e: JP      Z,$38FB]
	move.b	d2,d0                           	| [$3881: LD      A,C]
	ror.b	#1,d0                            	| [$3882: RRCA]
	move.b	d0,d2                           	| [$3883: LD      C,A]
	move.b	d4,d0                           	| [$3884: LD      A,E]
	cmp.b	#0x0C,d0                         	| [$3885: CP      $0C]
	jcc	vulture_hit_38fb                             	| [$3887: JP      NC,$38FB]
	move.b	d2,d0                           	| [$388a: LD      A,C]
	ror.b	#1,d0                            	| [$388b: RRCA]
	move.b	d0,d2                           	| [$388c: LD      C,A]
	jra	vulture_hit_38fb                             	| [$388d: JP      $38FB]

l_3894:
	move.b	#0x0D,d1                      	| [$3894: LD      BC,$0D05]
	move.b	#0x05,d2                      	| [$3894: LD      BC,$0D05]
	st.b	d0                                	| [$3897: LD      A,$FF]
	move.b	d0,killed_sfx_flag_4364                 	| [$3899: LD      (killed_sfx_flag_4364),A]

	move.w	#BIRD_SHOT_SND,d0
	jbsr	osd_sound_start	

	jra	vulture_simple_hit_38f8                             	| [$389c: JP      $38F8]

l_38a1:
	move.l	a1,-(sp)                    	| [$38a1: PUSH    DE]
	move.b	#0x20,d2                        	| [$38a2: LD      C,$20]
	exg	a1,a0                              	| [$38a4: EX      DE,HL]
	addq.w	#1,a0                           	| [$38a5: INC     HL]
	move.b	(a0)+,d3                         	| [$38a6: LD      D,(HL)]
	                           	| [$38a7: INC     HL]
	move.b	(a0),d4                         	| [$38a8: LD      E,(HL)]
	move.b	game_rom+0x198C,d0                       	| [$38a9: LD      A,($198C)]
	add.b	#0xde,d0                         	| [$38ac: ADD     $DE]
	move.b	d0,d6                           	| [$38ae: LD      L,A]
	move.b	#0x17,d5                        	| [$38af: LD      H,$17]
	jbsr	display_clipped_vulture_34de                            	| [$38b1: CALL    $34DE]
	move.l	(sp)+,a1                    	| [$38b4: POP     DE]
	rts                                    	| [$38b5: RET]
	
* < D0: offset
* < D2 ???
* < A1: enemy structure
l_38bc:
	add.b	#0xB0,d0                         	| [$38bc: ADD     $B0]
	move.b	d0,d6                           	| [$38be: LD      L,A]
	move.b	#0x3B,d5                        	| [$38bf: LD      H,$3B]
	jbsr	load_rom_in_a0_from_d5d6
	move.b	(a0),d0                         	| [$38c1: LD      A,(HL)]
	and.b	d2,d0                            	| [$38c2: AND     C]
	bne.b	0f                               	| [...]
	rts                                    	| [$38c3: RET     Z] [...]
0:
	jbsr	l_38a1                            	| [$38c4: CALL    $38A1]
	* get vulture state
	move.b	(a1),d0                         	| [$38c7: LD      A,(DE)]
	sub.b	#0x0B,d0                         	| [$38c8: SUB     $0B]
	jcs	l_38e9                             	| [$38ca: JP      C,$38E9]
	cmp.b	#0x03,d0                         	| [$38cd: CP      $03]
	jcc	l_38e9                             	| [$38cf: JP      NC,$38E9]
	move.b	d0,d1                           	| [$38d2: LD      B,A]

	* transfer/address shifts between DE/HL
	* amounting to just setting HL to DE+5
	lea		(5,a1),a0

												| [$38d3: LD      H,D]
												| [$38d4: LD      A,E]
												| [$38d5: ADD     $05]
												| [$38d7: LD      L,A]
	move.b	unknown_43C6,d0                 	| [$38d8: LD      A,(unknown_43C6)]
	cmp.b	(a0),d0                          	| [$38db: CP      (HL)]
	SET_X_FROM_C
	roxl.b	#1,d0                           	| [$38dc: RLA]
	rol.b	#2,d0                            	| [$38dd: RLCA] * 2
	and.b	#0x04,d0                         	| [$38df: AND     $04]
	or.b	d1,d0                             	| [$38e1: OR      B]
	add.b	#0xB8,d0                         	| [$38e2: ADD     $B8]
	move.b	d0,d6                           	| [$38e4: LD      L,A]
	move.b	#0x3D,d5                        	| [$38e5: LD      H,$3D]
	bsr		load_rom_in_a0_from_d5d6
	move.b	(a0),d0                         	| [$38e7: LD      A,(HL)]
	* change vulture state (ex: wing shot)
	move.b	d0,(a1)                         	| [$38e8: LD      (DE),A]
l_38e9:
	st.b	d0                                	| [$38e9: LD      A,$FF]
	move.b	d0,unknown_4366                 	| [$38eb: LD      (unknown_4366),A]
	move.b	#0x07,d1
	move.b	#0x02,d2                      	| [$38ee: LD      BC,$0702]
	                             	| [$38f1: JP      $38F8]

	move.w	#SHOT_BOUNCES_1_SND,D0
	jbsr	osd_sound_start
	
vulture_simple_hit_38f8:
	lea	slot_for_regular_animation_4370,a0                	| [$38f8: LD      HL,slot_for_regular_animation_4370]
vulture_hit_38fb:
	                              	| [$38fb: XOR     A]
	tst.b	(a0)                          	| [$38fc: CP      (HL)]
	jeq	l_3906                             	| [$38fd: JP      Z,$3906]	is animation slot free? yes: use it
	addq.w	#4,a0                           	| [$3900: INC     L]	next slot
	tst.b	(a0)                          	| [$3904: CP      (HL)]
	beq.b	l_3906                               	| [...]
	rts                                    	| [$3905: RET     NZ] [...] no slot free: no anim (can't really happen)
l_3906:

	* populate animation structure (4 bytes)
	move.b	d1,(a0)+                         	| [$3906: LD      (HL),B]
	                           	| [$3907: INC     L]
	move.b	d2,(a0)+                         	| [$3908: LD      (HL),C]
	                           	| [$3909: INC     L]
	move.b	ram_pointer_on_flying_enemies_table_43E6,d0	| [$390a: LD      A,(ram_pointer_on_flying_enemies_table_43E6)]
	move.b	d0,(a0)+                         	| [$390d: LD      (HL),A]
	                           	| [$390e: INC     L]
	move.b	ram_pointer_on_flying_enemies_table_lsb_43E7,d0                 	| [$390f: LD      A,(ram_pointer_on_flying_enemies_table_lsb_43E7)]
	move.b	d0,(a0)                         	| [$3912: LD      (HL),A]
	* enemy shot (or just wing shot): disable player shot
	move.b	player_shot_1_structure_43C4,d0 	| [$3913: LD      A,(player_shot_1_structure_43C4)]
	and.b	#0xF7,d0                         	| [$3916: AND     $F7]
	move.b	d0,player_shot_1_structure_43C4 	| [$3918: LD      (player_shot_1_structure_43C4),A]
	rts                                    	| [$391b: RET]
	
	* called when vulture is nearly shot, not lethally (like wing)
	
	DECL_ADDRESS	391c
* < A0:
* < D1:

vulture_shot_sound_391c:
	move.b	d1,d0                           	| [$391c: LD      A,B]
	cmp.b	#0x20,d0                         	| [$391d: CP      $20]
	jcc	l_38bc                             	| [$391f: JP      NC,$38BC]
	rts                                    	| [$3922: RET]
l_3923:
	bne.b	0f                               	| [...]
	rts                                    	| [$3923: RET     Z] [...]
0:
	subq.b	#1,(a0)                         	| [$3924: DEC     (HL)]
	lea	sound_control_438D,a0                        	| [$3925: LD      L,$8D]
	move.b	(a0),d0                         	| [$3927: LD      A,(HL)]
	and.b	#0x3F,d0                         	| [$3928: AND     $3F]
	or.b	#0x80,d0                          	| [$392a: OR      $80]
	move.b	d0,(a0)                         	| [$392c: LD      (HL),A]
	rts                                    	| [$392d: RET]
	                                    	| [$392e: RET]

vultures_shoot_decision_3930:
	move.b	current_char_scroll_value_4BD2,d0                 	| [$3930: LD      A,(current_char_scroll_value_4BD2)]
	and.w	#0x1E,d0                         	| [$3933: AND     $1E]
	add.b	#0xC0,d0                         	| [$3935: ADD     $C0]
	lea		game_rom+0x3D00,a0
	add.w	d0,a0                           	| [$3937: LD      L,A]
	                        	| [$3938: LD      H,$3D]
	move.b	(a0)+,d4                         	| [$393a: LD      E,(HL)]
	                           	| [$393b: INC     L]
	move.b	(a0),d0                         	| [$393c: LD      L,(HL)]
	lea		fg_videoram_4000+0xB00,a0                        	| [$393d: LD      H,$4B]
	add.w	d0,a0
	jbsr	l_3a00                            	| [$393f: CALL    $3A00]
	move.b	player_ship_right_x_439F,d0                 	| [$3942: LD      A,(player_ship_right_x_439F)]
	add.b	d3,d0                            	| [$3945: ADD     A,D]
	move.b	d0,d2                           	| [$3946: LD      C,A]
	move.b	player_ship_left_x_439E,d0                 	| [$3947: LD      A,(player_ship_left_x_439E)]
	sub.b	d3,d0                            	| [$394a: SUB     D]
	move.b	d0,d1                           	| [$394b: LD      B,A]
l_394c:

	move.l	a0,-(sp)                        	| [$394c: PUSH    HL]
	jbsr	l_395c                            	| [$394d: CALL    $395C]
	move.l	(sp)+,a0                        	| [$3950: POP     HL]
	                           	| [$3951: LD      A,L]
	add.w	#0x08,a0                         	| [$3952: ADD     $08]
	                           	| [$3954: LD      L,A]
	subq.b	#1,d4                           	| [$3955: DEC     E]
	jne	l_394c                             	| [$3956: JP      NZ,$394C]
	rts                                    	| [$3959: RET]

l_395c:
	move.b	(a0),d0                         	| [$395c: LD      A,(HL)]
	cmp.b	#0x05,d0                         	| [$395d: CP      $05]
	bcc.b	0f                               	| [...]
	rts                                    	| [$395f: RET     C] [...]
0:
												| [$3960: LD      A,L]
	addq.w	#0x05,a0                        	| [$3961: ADD     $05]
												| [$3963: LD      L,A]
	move.b	(a0),d0                         	| [$3964: LD      A,(HL)]
	cmp.b	d1,d0                            	| [$3965: CP      B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3966: RET     C] [...]
0:
	cmp.b	d2,d0                            	| [$3967: CP      C]
	bcs.b	0f                               	| [...]
	rts                                    	| [$3968: RET     NC] [...]
0:
	subq.b	#0x04,d0                        	| [$3969: SUB     $04]
	move.b	d0,d1                           	| [$396b: LD      B,A]
	subq.w	#3,a0                           	| [$396c: DEC     L]
	move.b	current_char_scroll_value_4BD2,d0                 	| [$396f: LD      A,(current_char_scroll_value_4BD2)]
	add.b	(a0),d0                          	| [$3972: ADD     A,(HL)]
	and.b	#0x1F,d0                         	| [$3973: AND     $1F]
	rol.b	#3,d0                            	| [$3975: RLCA] * 3
	add.b	#0x08,d0                         	| [$3978: ADD     $08]
	move.b	d0,d2                           	| [$397a: LD      C,A]
	jra	enemy_starts_shooting_25b7                             	| [$397b: JP      $25B7]

l_3980:
	move.b	current_char_scroll_value_4BD2,d0                 	| [$3980: LD      A,(current_char_scroll_value_4BD2)]
	sub.b	#0x0C,d0                         	| [$3983: SUB     $0C]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3985: RET     C] [...]
0:
	cmp.b	#0x10,d0                         	| [$3986: CP      $10]
	bcs.b	0f                               	| [...]
	rts                                    	| [$3988: RET     NC] [...]
0:
	lea	player_shot_1_structure_43C4,a0	| [$3989: LD      HL,player_shot_1_structure_43C4]
	lea	unknown_4BC0,a1                	| [$398c: LD      DE,unknown_4BC0]
	move.b	#0x04,d1                        	| [$398f: LD      B,$04]
	jbsr	copy_memory_05e0                            	| [$3991: CALL    $05E0]
	lea	ram_pointer_on_flying_enemies_table_43E6,a0                        	| [$3994: LD      L,$E6]
	move.b	#0x02,d1                        	| [$3996: LD      B,$02]
	jbsr	copy_memory_05e0                            	| [$3998: CALL    $05E0]
	lea	screen_address_43E2,a0                        	| [$399b: LD      L,$E2]
	lea	ram_pointer_on_flying_enemies_table_43E6,a1	| [$399d: LD      DE,ram_pointer_on_flying_enemies_table_43E6]
	move.b	#0x02,d1                        	| [$39a0: LD      B,$02]
	jbsr	copy_memory_05e0                            	| [$39a2: CALL    $05E0]
	lea	player_shot_1_structure_43C4,a0                        	| [$39a5: LD      L,$C4]
	move.b	#0x08,(a0)                      	| [$39a7: LD      (HL),$08]
	lea	player_ship_left_x_439E,a1                	| [$39a9: LD      DE,player_ship_left_x_439E]
	move.b	random_seed_counter_value_439B,d0                    	| [$39ac: LD      A,(random_seed_counter_value_439B)]
	ror.b	#1,d0                            	| [$39af: RRCA]
	jcs	l_39bf                             	| [$39b0: JP      C,$39BF]
	addq.w	#1,a1                           	| [$39b3: INC     E]
	lea	ram_pointer_on_flying_enemies_table_lsb_43E7,a0                        	| [$39b4: LD      L,$E7]
	move.b	(a0),d0                         	| [$39b6: LD      A,(HL)]
	sub.b	#0x20,d0                         	| [$39b7: SUB     $20]
	move.b	d0,(a0)                         	| [$39b9: LD      (HL),A]
	                           	| [$39ba: DEC     L]
	move.b	-(a0),d0                         	| [$39bb: LD      A,(HL)]
	clr		d7
	subx.b	d7,d0                        	| [$39bc: SBC     $00]
	move.b	d0,(a0)                         	| [$39be: LD      (HL),A]
l_39bf:
	move.b	(a1),d0                         	| [$39bf: LD      A,(DE)]
	move.b	d0,unknown_43C6                 	| [$39c0: LD      (unknown_43C6),A]
l_39c3:
	jbsr	player_shots_vs_vultures_collision_3800	| [$39c3: CALL    player_shots_vs_vultures_collision_3800]
	lea	player_shot_1_structure_43C4,a0	| [$39c6: LD      HL,player_shot_1_structure_43C4]
	move.b	(a0),d0                         	| [$39c9: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$39ca: AND     $08]
	jeq	l_39f0                             	| [$39cc: JP      Z,$39F0]
	lea	ram_pointer_on_flying_enemies_table_lsb_43E7,a0                	| [$39cf: LD      HL,ram_pointer_on_flying_enemies_table_lsb_43E7]
	addq.b	#1,(a0)                         	| [$39d2: INC     (HL)]
	move.b	(a0),d0                         	| [$39d3: LD      A,(HL)]
	and.b	#0x1F,d0                         	| [$39d4: AND     $1F]
	cmp.b	#0x1D,d0                         	| [$39d6: CP      $1D]
	jcs	l_39c3                             	| [$39d8: JP      C,$39C3]
l_39db:
	lea	unknown_4BC0,a0                	| [$39db: LD      HL,unknown_4BC0]
	lea	player_shot_1_structure_43C4,a1	| [$39de: LD      DE,player_shot_1_structure_43C4]
	move.b	#0x04,d1                        	| [$39e1: LD      B,$04]
	jbsr	copy_memory_05e0                            	| [$39e3: CALL    $05E0]
	lea	ram_pointer_on_flying_enemies_table_43E6,a1                        	| [$39e6: LD      E,$E6]
	move.b	#0x02,d1                        	| [$39e8: LD      B,$02]
	jra	copy_memory_05e0                             	| [$39ea: JP      $05E0]

l_39f0:
	lea	shield_timer_43A6,a0                        	| [$39f0: LD      L,$A6]
	move.b	(a0),d0                         	| [$39f2: LD      A,(HL)]
	cmp.b	#0xC0,d0                         	| [$39f3: CP      $C0]
	jcs	player_hit_0cc4                             	| [$39f5: JP      C,$0CC4]
	subq.b	#0x01,d0                        	| [$39f8: SUB     $01]
	move.b	d0,(a0)                         	| [$39fa: LD      (HL),A]
	jra	l_39db                             	| [$39fb: JP      $39DB]

l_3a00:
	move.b	nb_vultures_to_kill_before_stage_completed_43BB,d0                 	| [$3a00: LD      A,(nb_vultures_to_kill_before_stage_completed_43BB)]
	sub.b	#0x0C,d0                         	| [$3a03: SUB     $0C]
	not.b	d0                               	| [$3a05: CPL]
	addq.b	#1,d0                           	| [$3a06: INC     A]
	move.b	d0,d3                           	| [$3a07: LD      D,A]
	move.b	random_seed_counter_value_439B,d0                    	| [$3a08: LD      A,(random_seed_counter_value_439B)]
	ror.b	#2,d0                            	| [$3a0b: RRCA] * 2
	bcc.b	0f                               	| [...]
	rts                                    	| [$3a0d: RET     C] [...]
0:
	move.l	(sp)+,a0                        	| [$3a0e: POP     HL]
	rts                                    	| [$3a0f: RET]
l_3a10:
	lea	current_stage_43B8,a0          	| [$3a10: LD      HL,current_stage_43B8]
	move.b	(a0),d0                         	| [$3a13: LD      A,(HL)]
	                               	| [$3a14: AND     A]
	jne	l_3b43                             	| [$3a15: JP      NZ,$3B43]
	lea	sound_control_438D,a0                        	| [$3a18: LD      L,$8D]
	move.b	#0xCF,(a0)                      	| [$3a1a: LD      (HL),$CF]
	rts                                    	| [$3a1c: RET]
l_3a1d:
	lea	unknown_4369,a0                	| [$3a1d: LD      HL,unknown_4369]
	move.b	(a0),d0                         	| [$3a20: LD      A,(HL)]
	                               	| [$3a21: AND     A]
	jeq	l_3a40                             	| [$3a22: JP      Z,$3A40]
	cmp.b	#0x20,d0                         	| [$3a25: CP      $20]
	jcs	l_3a2c                             	| [$3a27: JP      C,$3A2C]
	move.b	#0x20,(a0)                      	| [$3a2a: LD      (HL),$20]
l_3a2c:
	subq.b	#1,(a0)                         	| [$3a2c: DEC     (HL)]
	move.b	(a0),d0                         	| [$3a2d: LD      A,(HL)]
	rol.b	#2,d0                            	| [$3a2e: RLCA] * 2
	                                    	| [$3a30: NOP]
	not.b	d0                               	| [$3a31: CPL]
	and.b	#0x0E,d0                         	| [$3a32: AND     $0E]
	lea	sound_control_438D,a0                        	| [$3a34: LD      L,$8D]
	move.b	d0,(a0)                         	| [$3a36: LD      (HL),A]
	lea	unknown_4368,a0                        	| [$3a37: LD      L,$68]
	clr.b	(a0)                             	| [$3a39: LD      (HL),$00]
	lea	unknown_4366,a0                        	| [$3a3b: LD      L,$66]
	clr.b	(a0)                             	| [$3a3d: LD      (HL),$00]
	rts                                    	| [$3a3f: RET]
l_3a40:
	lea	killed_sfx_flag_4364,a0                        	| [$3a40: LD      L,$64]
	move.b	(a0),d0                         	| [$3a42: LD      A,(HL)]
	                               	| [$3a43: AND     A]
	jeq	l_3a62                             	| [$3a44: JP      Z,$3A62]
	cmp.b	#0x10,d0                         	| [$3a47: CP      $10]
	jcs	l_3a4e                             	| [$3a49: JP      C,$3A4E]
	move.b	#0x10,(a0)                      	| [$3a4c: LD      (HL),$10]
l_3a4e:
	subq.b	#1,(a0)                         	| [$3a4e: DEC     (HL)]
	move.b	(a0),d0                         	| [$3a4f: LD      A,(HL)]
	ror.b	#1,d0                            	| [$3a50: RRCA]
	                                    	| [$3a51: NOP]
	                                    	| [$3a52: NOP]
	not.b	d0                               	| [$3a53: CPL]
	and.b	#0x07,d0                         	| [$3a54: AND     $07]
	or.b	#0x10,d0                          	| [$3a56: OR      $10]
	lea	sound_buffer_438C,a0                        	| [$3a58: LD      L,$8C]
	move.b	d0,(a0)                         	| [$3a5a: LD      (HL),A]
	lea	unknown_4366,a0                        	| [$3a5b: LD      L,$66]
	clr.b	(a0)                             	| [$3a5d: LD      (HL),$00]
	rts                                    	| [$3a5f: RET]
	                            	| [$3a60: RRCA]
	                                    	| [$3a61: NOP]
l_3a62:
	lea	unknown_4366,a0                        	| [$3a62: LD      L,$66]
	move.b	(a0),d0                         	| [$3a64: LD      A,(HL)]
	                               	| [$3a65: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$3a66: RET     Z] [...]
0:
	cmp.b	#0x10,d0                         	| [$3a67: CP      $10]
	jcs	l_3a78                             	| [$3a69: JP      C,$3A78]
	move.b	#0x10,(a0)                      	| [$3a6c: LD      (HL),$10]
	move.b	current_stage_43B8,d0           	| [$3a6e: LD      A,(current_stage_43B8)]
	and.b	#0x08,d0                         	| [$3a71: AND     $08]
	jeq	l_3a78                             	| [$3a73: JP      Z,$3A78]
	move.b	#0x05,(a0)                      	| [$3a76: LD      (HL),$05]
l_3a78:
	subq.b	#1,(a0)                         	| [$3a78: DEC     (HL)]
	lea	sound_buffer_438C,a0                        	| [$3a79: LD      L,$8C]
	move.b	(a0),d0                         	| [$3a7b: LD      A,(HL)]
	and.b	#0x08,d0                         	| [$3a7c: AND     $08]
	or.b	#0x04,d0                          	| [$3a7e: OR      $04]
	move.b	d0,(a0)                         	| [$3a80: LD      (HL),A]
	rts                                    	| [$3a81: RET]
l_3a82:
	lea	counter_439A,a0                	| [$3a82: LD      HL,counter_439A]
	move.b	(a0),d0                         	| [$3a85: LD      A,(HL)]
	cmp.b	#0x03,d0                         	| [$3a86: CP      $03]
	bcc.b	0f                               	| [...]
	rts                                    	| [$3a88: RET     C] [...]
0:
	lea	sound_control_438D,a0                        	| [$3a89: LD      L,$8D]
	move.b	(a0),d0                         	| [$3a8b: LD      A,(HL)]
	and.b	#0x3F,d0                         	| [$3a8c: AND     $3F]
	move.b	d0,(a0)                         	| [$3a8e: LD      (HL),A]
	rts                                    	| [$3a8f: RET]
	
	
l_3a90:
	lea	unknown_436B,a0                	| [$3a90: LD      HL,unknown_436B]
	move.b	(a0),d0                         	| [$3a93: LD      A,(HL)]
	                               	| [$3a94: AND     A]
	jra	l_3923                             	| [$3a95: JP      $3923]
	
birds_ambient_sound_3a98:
	* count how many birds are attacking
	lea		bird_data_4B70,a0                	| [$3a98: LD      HL,bird_data_4B70]
	move.b	#0x08,d1
	move.b	#0x00,d2                      	| [$3a9b: LD      BC,$0800]
	move.w	#0x03,d3					  	| [$3a9e: LD      DE,$03B0]
l_3aa1:
	move.b	(a0)+,d0                         	| [$3aa1: LD      A,(HL)]
	                           	| [$3aa2: INC     L]
	and.b	d1,d0                            	| [$3aa3: AND     B]
	jeq	l_3aae                             	| [$3aa4: JP      Z,$3AAE]
	move.b	(a0),d0                         	| [$3aa7: LD      A,(HL)]
	cmp.b	#0x28,d0                         	| [$3aa8: CP      $28]
	jcs	l_3aae                             	| [$3aaa: JP      C,$3AAE]
	addq.w	#1,d2                           	| [$3aad: INC     C]
l_3aae:
	                           	| [$3aae: LD      A,L]
	add.w	d3,a0                            	| [$3aaf: ADD     A,D]
	                           	| [$3ab0: LD      L,A]
	cmp.l	#unknown_4BB0,a0                            	| [$3ab1: CP      E]
	jne	l_3aa1                             	| [$3ab2: JP      NZ,$3AA1]
	move.b	d2,d0                           	| [$3ab5: LD      A,C]
	                               	| [$3ab6: AND     A]
	bne.b	0f                               	| [...]
	* don't play attack sound. Continuously exits there when no attack
	* because no bird is attacking
	jbsr	osd_sound_loop_stop
	rts                                    	| [$3ab7: RET     Z] [...]
0:
	* here play attack sound
	move.w	#ATTACK_LOOP_SND,d0
	jbsr	osd_sound_start
	
	cmp.b	#0x08,d0                         	| [$3ab8: CP      $08]
	jcs	l_3abf                             	| [$3aba: JP      C,$3ABF]
	move.b	#0x08,d0                        	| [$3abd: LD      A,$08]
l_3abf:
	add.b	#0x25,d0                         	| [$3abf: ADD     $25]
	move.b	d0,d2                           	| [$3ac1: LD      C,A]
	lea	sound_buffer_438C,a0                	| [$3ac2: LD      HL,sound_buffer_438C]
	move.b	(a0),d0                         	| [$3ac5: LD      A,(HL)]
	and.b	#0xC0,d0                         	| [$3ac6: AND     $C0]
	or.b	d2,d0                             	| [$3ac8: OR      C]
	move.b	d0,(a0)                         	| [$3ac9: LD      (HL),A]
	rts                                    	| [$3aca: RET]

* plays the changing frequency high pitched "alert" sound
* changes depending on how low the vultures are

vultures_background_sound_3ad0:
	lea	sound_control_438E,a0                	| [$3ad0: LD      HL,sound_control_438E]
	move.b	(a0),d0                         	| [$3ad3: LD      A,(HL)]
	and.b	#0x01,d0                         	| [$3ad4: AND     $01]
	rol.b	#2,d0                            	| [$3ad6: RLCA] * 2
	or.b	#0x20,d0                          	| [$3ad8: OR      $20]
	move.b	d0,d1     		                      	| [$3ada: LD      B,A]
	                           	| [$3adb: DEC     L]
	move.b	-(a0),d0                         	| [$3adc: LD      A,(HL)]
	and.b	#0xC0,d0                         	| [$3add: AND     $C0]
	or.b	d1,d0                             	| [$3adf: OR      B]
	move.b	d0,(a0)                         	| [$3ae0: LD      (HL),A]
	lea	unknown_4396,a0                        	| [$3ae1: LD      L,$96]
	move.b	(a0),d0                         	| [$3ae3: LD      A,(HL)]
	addq.b	#1,(a0)                         	| [$3ae4: INC     (HL)]
	tst.b	d0                               	| [$3ae5: AND     A]
	jeq	l_3af8                             	| [$3ae6: JP      Z,$3AF8]
	move.b	average_vulture_y_pos_in_chars_4BD6,d0                 	| [$3ae9: LD      A,(average_vulture_y_pos_in_chars_4BD6)]
	add.b	#0xE0,d0                         	| [$3aec: ADD     $E0]
	move.b	d0,d4                           	| [$3aee: LD      E,A]
	move.b	#0x3D,d3                        	| [$3aef: LD      D,$3D]
	bsr		load_rom_in_a1_from_d3d4
	move.b	(a1),d0                         	| [$3af1: LD      A,(DE)]
	cmp.b	(a0),d0                          	| [$3af2: CP      (HL)]
	bcs.b	0f                               	| [...]
	rts                                    	| [$3af3: RET     NC] [...]
0:
	* here it sets the decaying sound, there are 2 alternating decaying sounds
	move.w	#VULTURE_BACK_2_SND,d0
	eor.b	#1,vulture_sound_toggle
	beq		0f
	move.w	#VULTURE_BACK_1_SND,d0
0:
	jbsr	osd_sound_start

	clr.b	(a0)                             	| [$3af4: LD      (HL),$00]
	rts                                    	| [$3af6: RET]
	                           	| [$3af7: LD      E,A]
l_3af8:
	
	lea	sound_control_438E,a0                        	| [$3af8: LD      L,$8E]
	addq.b	#1,(a0)                         	| [$3afa: INC     (HL)]
	                           	| [$3afb: DEC     L]
	move.b	-(a0),d0                         	| [$3afc: LD      A,(HL)]
	or.b	#0x10,d0                          	| [$3afd: OR      $10]
	move.b	d0,(a0)                         	| [$3aff: LD      (HL),A]
	rts                                    	| [$3b00: RET]
	
boss_ambient_sound_3b02:
	lea	counter_439A,a0                	| [$3b02: LD      HL,counter_439A]
	move.b	(a0),d0                         	| [$3b05: LD      A,(HL)]
	cmp.b	#0x02,d0                         	| [$3b06: CP      $02]
	bcs.b	0f                               	| [...]
	rts                                    	| [$3b08: RET     NC] [...]
0:
	addq.w	#1,a0                           	| [$3b09: INC     L]
	move.b	(a0),d0                         	| [$3b0a: LD      A,(HL)]
	move.b	d0,d1                           	| [$3b0b: LD      B,A]
	lea	sound_control_438D,a0                        	| [$3b0e: LD      L,$8D]
	move.b	#0x0A,(a0)                      	| [$3b10: LD      (HL),$0A]
	and.b	#0x60,d0                         	| [$3b0c: AND     $60]
	beq.b	0f                               	| [...]
	rts                                    	| [$3b12: RET     NZ] [...]
0:
	addq.b	#1,boss_sound_counter
	cmp.b	#6,boss_sound_counter
	bne.b	0f
	clr.b	boss_sound_counter
	move.w	#BOSS_SND,d0
	jbsr	osd_sound_start
0:
	move.b	d1,d0                           	| [$3b13: LD      A,B]
	and.b	#0x02,d0                         	| [$3b14: AND     $02]
	add.b	#0x1C,d0                         	| [$3b16: ADD     $1C]
	move.b	d0,(a0)                         	| [$3b18: LD      (HL),A]
	rts                                    	| [$3b19: RET]
	                           	| [$3b1a: LD      A,B]
l_3b1b:
	lea	unknown_4362,a0                	| [$3b1b: LD      HL,unknown_4362]
	move.b	(a0),d0                         	| [$3b1e: LD      A,(HL)]
	                               	| [$3b1f: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$3b20: RET     Z] [...]
0:
	cmp.b	#0x40,d0                         	| [$3b21: CP      $40]
	jcs	l_3b28                             	| [$3b23: JP      C,$3B28]
	move.b	#0x40,(a0)                      	| [$3b26: LD      (HL),$40]
l_3b28:
	subq.b	#1,(a0)                         	| [$3b28: DEC     (HL)]
	move.b	(a0),d0                         	| [$3b29: LD      A,(HL)]
	and.b	#0x06,d0                         	| [$3b2a: AND     $06]
	rol.b	#1,d0                            	| [$3b2c: RLCA]
											| [$3b2d: NOP]
	lea	sound_control_438D,a0                        	| [$3b2e: LD      L,$8D]
	move.b	d0,(a0)                         	| [$3b30: LD      (HL),A]
	rts                                    	| [$3b31: RET]

play_extra_life_beep_timer_if_needed_3b33:
	lea	extra_life_beep_timer_436A,a0                	| [$3b33: LD      HL,extra_life_beep_timer_436A]
	move.b	(a0),d0                         	| [$3b36: LD      A,(HL)]
	                               	| [$3b37: AND     A]
	bne.b	0f                               	| [...]
	rts                                    	| [$3b38: RET     Z] [...]
0:
	subq.b	#1,(a0)                         	| [$3b39: DEC     (HL)]
	* adapted to play a sample every 16 calls
	and.b	#0x0F,d0                         	| [$3b3a: AND     $08]
	bne.b	0f
*	or.b	#0x07,d0                          	| [$3b3c: OR      $07]
	* play the extra life sound beep
*	lea	sound_control_438D,a0                        	| [$3b3e: LD      L,$8D]
*	move.b	d0,(a0)                         	| [$3b40: LD      (HL),A]
	move.w	#EXTRA_LIFE_SND,d0
	jbsr	osd_sound_start
0:
	rts                                    	| [$3b41: RET]
l_3b43:
	lea	game_state_43A4,a0             	| [$3b43: LD      HL,game_state_43A4]
	move.b	(a0),d0                         	| [$3b46: LD      A,(HL)]
	cmp.b	#STATE_GAME_PLAYING,d0                         	| [$3b47: CP      $03]
	bne.b	0f                               	| [...]
	jbsr	play_stage_ambient_sound_23d6                            	| [$3b49: CALL    Z,$23D6]
0:
	jbsr	play_extra_life_beep_timer_if_needed_3b33                            	| [$3b4c: CALL    $3B33]
	jbsr	l_3b1b                            	| [$3b4f: CALL    $3B1B]
	jbsr	l_3a1d                            	| [$3b52: CALL    $3A1D]
	jbsr	noise_generation_27bd                            	| [$3b55: CALL    $27BD]
	jbsr	l_3a82                            	| [$3b58: CALL    $3A82]
	jra	l_3a90                             	| [$3b5b: JP      $3A90]



* table in 3ED0 contains only zeroes and ones
vulture_y_delta_table_3ED0:
	.byte	0x01,0x01,0x01,0x01		| 100% of ones
	.byte	0x00,0x00,0x01,0x01		| 50% of ones
	.byte	0x00,0x01,0x01,0x01		| 75% of ones
	.byte	0x00,0x00,0x00,0x01		| 25% of ones
	
jump_table_chain_3F00:
	.long	0xFFFF 		| slot 0, not possible
	.long	0xFFFF 
	.long	0xFFFF 
	.long	0xFFFF

	.long	0x20FF 		| slot 1
	.long	0x02FF 
	.long	vulture_command_36d2 
	.long	vulture_command_36c0

	.long	0x20FF 		| slot 2
	.long	0x03FF 
	.long	vulture_command_36d2 
	.long	vulture_command_move_vultures_laterally_35e0 

	.long	0x30FF 		| slot 3 
	.long	0x04FF 
	.long	vulture_command_36d2 
	.long	vulture_command_move_vultures_laterally_35e0

	.long	0x10FF  		| slot 4
	.long	0x05FF 
	.long	vulture_command_36ea
	.long	vulture_command_move_vultures_laterally_35e0

	.long	0x10FF 		| slot 5
	.long	0x06FF
	.long	vulture_command_36ea
	.long	vulture_command_36c0

	.long	0x1060 		| slot 6
	.long	0x071F 
	.long	vulture_command_370a 
	.long	vulture_command_36c0 

	.long	0xF010 		| slot 7
	.long	0x0B1A		
	.long	vulture_command_370a
	.long	vulture_command_36c0

	.long	0x40FF 		| slot 8, bogus  
	.long	0x04FF 
	.long	vulture_command_36ea
	.long	vulture_command_36c0

	.long	0x10FF 		| slot 9
	.long	0x08FF
	.long	vulture_command_36ea 
	.long	vulture_command_36c0

	.long	0x4010 		| slot 10
	.long	0x0F17 
	.long	vulture_command_370a
	.long	vulture_command_36c0 

	.long	0x10FF 		| slot 11
	.long	0x0AFF
	.long	vulture_command_36ea
	.long	vulture_command_move_vultures_laterally_35e0 

	.long	0xFFFF 		| slot 12
	.long	0xFFFF
	.long	end_chained_calls_36cc
	.long	vulture_command_move_vultures_laterally_35e0

	.long	0xFFFF 		| slot 14
	.long	0xFFFF
	.long	end_chained_calls_36cc
	.long	vulture_command_move_vultures_laterally_35e0

	.long	0x10FF  		| slot 15
	.long	0x06FF 
	.long	vulture_command_36ea 
	.long	vulture_command_move_vultures_laterally_35e0

	.long	0x1010 		| slot 16
	.long	0x0779
	.long	vulture_command_370a 
	.long	vulture_command_move_vultures_laterally_35e0
